---
layout: lay_post
title: "JVM之指针压缩"
date: 2020-05-09
categories: 指针压缩
tags: jvm
author: lvyafei
---

## 1.指针压缩解决的问题

对于32位机器，进程能使用的最大内存是4G。如果进程需要使用更多的内存，需要使用64位机器。

对于Java进程，在oop(ordinary object pointer即普通对象指针),只有32位时，只能引用4G内存。如果需要使用更大的堆内存，需要部署64位JVM。

在堆中，32位的对象引用占4个字节，而64位的对象引用占8个字节。也就是说，64位的对象引用大小是32位的2倍。64位JVM在支持更大堆的同时，由于对象引用变大却带来了性能问题：
<!--more-->

**1.增加了GC开销**

64位对象引用需要占用更多的堆空间，留给其他数据的空间将会减少，从而加快了GC的发生，更频繁的进行GC。

**2.降低CPU缓存命中率**

64位对象引用增大了，CPU能缓存的oop将会更少，从而降低了CPU缓存的效率。

## 2.指针压缩的目的

为了能够保持32位的性能，oop必须保留32位。那么，如何用32位oop来引用更大的堆内存呢？答案是压缩指针（CompressedOops）。

## 3.指针压缩的实现原理

**原理：**

JVM不再保存所有引用，而是每隔8个字节保存一个引用。例如，原来保存每个引用0、1、2...，现在只保存0、8、16...。因此，指针压缩后，并不是所有引用都保存在堆中，
而是以8个字节为间隔保存引用。

**实现：**

堆中的引用其实还是按照0x0、0x1、0x2...进行存储。只不过当引用被存入64位的寄存器时，JVM将其左移3位（相当于末尾添加3个0），
例如0x0、0x1、0x2...分别被转换为0x0、0x8、0x10。而当从寄存器读出时，JVM又可以右移3位，丢弃末尾的0。
（oop在堆中是32位，在寄存器中是35位，2的35次方=32G。也就是说，使用32位，来达到35位oop所能引用的堆内存空间）

在JVM中（不管是32位还是64位），对象已经按8字节边界对齐了。对于大部分处理器，这种对齐方案都是最优的。所以，使用压缩的oop并不会带来什么损失，反而提升了性能。

Oracle JDK从6 update 23开始在64位系统上会默认开启压缩指针。32位HotSpot VM是不支持UseCompressedOops参数的，只有64位HotSpot VM才支持。

## 4.指针压缩的开启与关闭

开启压缩指针：

```
-XX:+UseCompressedOops
```

关闭压缩指针：

```
-XX:-UseCompressedOops
```

查看压缩指针的工作模式：

```
-XX:+UnlockDiagnosticVMOptions -XX:+PrintCompressedOopsMode
```

JDK7,JDK8下查看指针压缩模式

```
$ java -server -Xms2G -Xmx2G -XX:+UseConcMarkSweepGC -XX:+UnlockDiagnosticVMOptions -XX:+PrintCompressedOopsMode -version

heap address: 0x000000077ae00000, size: 2130 MB, zero based Compressed Oops

java version "1.7.0_79"
Java(TM) SE Runtime Environment (build 1.7.0_79-b15)
Java HotSpot(TM) 64-Bit Server VM (build 24.79-b02, mixed mode)

$ java -server -Xms2G -Xmx2G -XX:+UseConcMarkSweepGC -XX:+UnlockDiagnosticVMOptions -XX:+PrintCompressedOopsMode -version

heap address: 0x0000000080000000, size: 2048 MB, Compressed Oops mode: 32-bit

Narrow klass base: 0x0000000000000000, Narrow klass shift: 3
Compressed class space size: 1073741824 Address: 0x000000013fe20000 Req Addr: 0x0000000100000000
java version "1.8.0_121"
Java(TM) SE Runtime Environment (build 1.8.0_121-b13)
Java HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode)

```

关闭指针压缩后：

```
$ java -server -Xms2G -Xmx2G -XX:+UseConcMarkSweepGC -XX:-UseCompressedOops -XX:+UnlockDiagnosticVMOptions -XX:+PrintCompressedOopsMode -version
java version "1.8.0_121"
Java(TM) SE Runtime Environment (build 1.8.0_121-b13)
Java HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode)
```

## 5.指针压缩效果验证

一个Interge类型在关闭指针压缩时，占用24bytes

64(Mark Word)+64(Compressed oops)+32(int)=160bits=20bytes

但是，对于64位JVM，字宽为8个字节(64位/8=8)。由于JVM内存分配需要根据字宽进行对齐，因此，一个Integer实际占用24bytes(20bytes/8=2.5,取整为3。3*8=24)，即192bits(24*8=192)。

一个Interge类型在开启指针压缩时，占用16bytes

64(Mark Word)+32(Compressed oops)+32(int)=128bits=16bytes

## 6.面试问题

1、指针压缩是如何实现的？如何证明开启指针压缩节省了内存？

2、开启指针压缩后，一个oop所能表示的最大堆空间是多少？不开呢？

开启指针压缩，内存地址占4B=32位，使用时补三位，32+3=35bit，所以最大占2^35=32G

3、如何扩展开启指针压缩后一个oop所能表示的最大堆空间？

## 7.参考资料：

JVM之压缩指针（CompressedOops）：
https://juejin.im/post/5c4c8ad9f265da6179752b03

java对象和指针压缩：
https://www.yuque.com/haolihai/iuws1z/ys04eg