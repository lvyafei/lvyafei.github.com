---
layout: lay_post
title: "MySQL死锁排查手册"
date: 2019-08-19
categories: 数据库
tags: MySQL
author: lvyafei
---

## 1.查看死锁日志开关

show variables like 'innodb_print_all_deadlocks';

打开配置:
set global innodb_print_all_deadlocks=on
<!--more-->

配置文件修改：

/etc/my.cnf 中添加以下配置：

innodb_print_all_deadlocks=on

## 2.MySQL索引

mysql5.7中type的类型达到了14种之多，这里只记录和理解最重要且经常遇见的六种类型，
它们分别是all,index,range,ref,eq_ref，const。从左到右，它们的效率依次是增强的。撇开sql的具体应用环境以及其他因素，
你应当尽量优化你的sql语句，使它的type尽量靠右，但实际运用中还是要综合考虑各个方面的。

1.all: 这便是所谓的“全表扫描”
2.index: 这种连接类型只是另外一种形式的全表扫描，只不过它的扫描顺序是按照索引的顺序。
  而且index要先读索引而且要回表随机取数据，因此index不可能会比all快（取同一个表数据）
  如果type为index，而且extra列中的值为‘Using index’，那么称这种情况为"索引覆盖",既只需要查询索引即可
3.range：range指的是有范围的索引扫描，相对于index的全索引扫描，它有范围限制，因此要优于index。
  关于range比较容易理解，需要记住的是出现了range，则一定是基于索引的。同时除了显而易见的between，and以及'>','<'外，
  in和or也是索引范围扫描。
4.ref：出现该连接类型的条件是： 查找条件列使用了索引而且不为主键和unique。
   其实，意思就是虽然使用了索引，但该索引列的值并不唯一，有重复。这样即使使用索引快速查找到了第一条数据，仍然不能停止，
   要进行目标值附近的小范围扫描。但它的好处是它并不需要扫全表，因为索引是有序的，即便有重复值，也是在一个非常小的范围内扫描。
5.ref_eq：ref_eq与ref相比牛的地方是，它知道这种类型的查找结果集只有一个？什么情况下结果集只有一个呢！
   那便是使用了主键或者唯一性索引进行查找的情况，比如根据学号查找某一学校的一名同学，在没有查找前我们就知道结果一定只有一个，
   所以当我们首次查找到这个学号，便立即停止了查询。这种连接类型每次都进行着精确查询，无需过多的扫描，因此查找效率更高，
   当然列的唯一性是需要根据实际情况决定的。
6.const：通常情况下，如果将一个主键放置到where后面作为条件查询，mysql优化器就能把这次查询优化转化为一个常量。
   至于如何转化以及何时转化，这个取决于优化器

## 表索引
--新增索引
alter table condition_setting add index index_expire(expire_date);
--删除索引
drop index index_expire on condition_setting;
--查看进程
show processlist;