---
layout: lay_post
title: "mysql执行语句问题跟踪"
date: 2020-04-16
categories: 工具
tags: mysql
author: lvyafei
---

## 1.事务的隔离级别

MySQL支持的四种事务隔离级别：

**READ-UNCOMMITTED**、**READ-COMMITTED**、**REPEATABLE-READ**、**SERIALIZABLE**

查看全局事务隔离级别和会话事务隔离级别

mysql8.0 变量名为'transaction_isolation'

```
mysql> show global variables like 'tx_isolation';
+---------------+-----------------+
| Variable_name | Value           |
+---------------+-----------------+
| tx_isolation  | REPEATABLE-READ |
+---------------+-----------------+
1 row in set (0.00 sec)

mysql> show session variables like 'tx_isolation';
+---------------+-----------------+
| Variable_name | Value           |
+---------------+-----------------+
| tx_isolation  | REPEATABLE-READ |
+---------------+-----------------+
1 row in set (0.00 sec)

mysql> SELECT @@GLOBAL.tx_isolation, @@SESSION.tx_isolation; 
```
<!--more-->

修改事务隔离级别参数
```
mysql> SET GLOBAL tx_isolation='REPEATABLE-READ'; 

mysql> SET SESSION tx_isolation='SERIALIZABLE';
//或使用
mysql> set session transaction isolation level repeatable read;
mysql> set session autocommit=0;
```

查看当前事务使用的隔离级别

information_schema.innodb_trx
information_schema.processlist
```
SELECT p.ID,P.USER,P.HOST,p.DB,P.TIME,T.trx_started,T.trx_isolation_level,
T.trx_tables_locked,T.trx_rows_locked,t.trx_state,p.COMMAND AS process_state
FROM `information_schema`.`INNODB_TRX` t INNER JOIN `information_schema`.`PROCESSLIST` p
ON t.trx_mysql_thread_id=p.id;
```

## 2.查询系统中的事务

查看未提交事务

information_schema.innodb_trx
information_schema.processlist
```
SELECT p.ID,P.USER,P.HOST,p.DB,P.TIME,T.trx_started,
T.trx_isolation_level,T.trx_tables_locked,T.trx_rows_locked,t.trx_state,p.COMMAND AS process_state
FROM `information_schema`.`INNODB_TRX` t INNER JOIN `information_schema`.`PROCESSLIST` p ON t.trx_mysql_thread_id=p.id
WHERE t.trx_state='RUNNING' AND p.COMMAND='Sleep' 
ORDER BY T.trx_started ASC;
```

查看阻塞事务

information_schema.innodb_lock_waits
information_schema.innodb_trx
information_schema.innodb_locks
information_schema.processlist

```
SELECT P2.`ID` BlockProcessID,
p2.`HOST` Blockedhost,p2.`USER` BlockedUser,  
r.trx_id BlockedTrxId,r.trx_mysql_thread_id BlockedThreadId,      
TIMESTAMPDIFF(SECOND,      
r.trx_wait_started,      
CURRENT_TIMESTAMP) WaitTime,      
r.trx_query BlockedQuery,      
l.lock_table BlockedTable,    
m.`lock_mode` BlockedLockMode,  
m.`lock_type` BlockedLockType,  
m.`lock_index` BlockedLockIndex,  
m.`lock_space` BlockedLockSpace,  
m.lock_page BlockedLockPage,  
m.lock_rec BlockedLockRec,  
m.lock_data BlockedLockData,
p.`ID` BlockingProcessID,  
p.`HOST` blocking_host,   
p.`USER` blocking_user,  
b.trx_id BlockingTrxid,      
b.trx_mysql_thread_id BlockingThreadId,  
b.trx_query BlockingQuery,  
l.`lock_mode` BlockingLockMode,  
l.`lock_type` BlockingLockType,  
l.`lock_index` BlockingLockIndex,  
l.`lock_space` BlockingLockSpace,  
l.lock_page BlockingLockPage,  
l.lock_rec BlockingLockRec,  
l.lock_data BlockingLockData,           
IF (p.COMMAND = 'Sleep', CONCAT(p.TIME,' seconds'), 0) idel_in_trx               
FROM information_schema.INNODB_LOCK_WAITS w      
INNER JOIN information_schema.INNODB_TRX b 
ON b.trx_id = w.blocking_trx_id      
INNER JOIN information_schema.INNODB_TRX r 
ON r.trx_id = w.requesting_trx_id      
INNER JOIN information_schema.INNODB_LOCKS l 
ON w.blocking_lock_id = l.lock_id  
AND l.`lock_trx_id`=b.`trx_id`  
INNER JOIN information_schema.INNODB_LOCKS m 
ON m.`lock_id`=w.`requested_lock_id` 
AND m.`lock_trx_id`=r.`trx_id`  
INNER JOIN information_schema.PROCESSLIST p 
ON p.ID = b.trx_mysql_thread_id     
INNER JOIN information_schema.PROCESSLIST p2 
ON p2.ID = r.trx_mysql_thread_id   
ORDER BY WaitTime DESC ;
```

## 3.使用事务

事务开启

```
mysql> start transaction;
```

事务提交

```
mysql> commit;
```

## 4.封锁

封锁是实现并发控制的一个非常重要的技术。基本的封锁类型有两种：排它锁(exclusive locks，简称X锁) 和共享锁(share locks，简称S锁)。

**封锁协议**

一级封锁协议：事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。

二级封锁协议：在一级封锁协议基础上，增加事务T在读取数据R之前必须先对其加S锁，读完后即可释放S锁。

三级封锁协议：在一级封锁协议基础上，增加事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放。

**活锁与死锁**

活锁： 如果事务T1封锁了数据R，事务T2又请求封锁R，于是T2等待。T3也请求封锁R，当T1释放了R上的封锁之后系统首先批准了T3的请求，T2仍然等待。然后T4又请求封锁R，当T3释放了R上的封锁之后系统又批准了T4的请求，...，T2有可能永远等待，这就是活锁的情形。

死锁： 如果事务T1封锁了数据R1，T2封锁了数据R2，然后T1又请求封锁R2，因T2已封锁了R2，于是T1等待T2释放R2上的锁。接着T2又申请封锁R1，因T1已封锁了R1，T2也只能等待T1释放R1上的锁。这样就出现了T1在等待T2，而T2又在等待T1的局面，T1和T2两个事务永远不能结束，形成死锁。

查看事务锁持有的锁

information_schema.innodb_lock_waits
information_schema.innodb_trx
```
SELECT r.trx_id waiting_trx_id,r.trx_query waiting_query,b.trx_id blocking_trx_id,
b.trx_query blocking_query,b.trx_mysql_thread_id blocking_thread,b.trx_started,b.trx_wait_started
FROM information_schema.innodb_lock_waits w INNER JOIN information_schema.innodb_trx b ON b.trx_id = w.blocking_trx_id
INNER JOIN information_schema.innodb_trx r ON r.trx_id = w.requesting_trx_id 
```

## 5.死锁处理

死锁的问题在操作系统和一般并行处理中已做了深入研究，目前在数据库中解决死锁问题主要有两类方法：一类是采取一定措施来预防死锁的发生，另一类是允许发生死锁，采用一定手段定期诊断系统中有无死锁，若有则解除之。

**死锁的预防：**

预防死锁通常有两种方法： 一次封锁法、顺序封锁法。

① 一次封锁法

一次封锁法要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行。 一次封锁法虽然可以有效地防止死锁的发生，但也存在问题，一次就将以后要用到的全部数据加锁，势必扩大了封锁的范围，从而降低了系统的并发度。

② 顺序封锁法

顺序封锁法是预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁。 顺序封锁法可以有效地防止死锁，但也同样存在问题。事务的封锁请求可以随着事务的执行而动态地决定，很难事先确定每一个事务要封锁哪些对象，因此也就很难按规定的顺序去施加封锁。 

可见，在操作系统中广为采用的预防死锁的策略并不很适合数据库的特点，因此DBMS在解决死锁的问题上普遍采用的是诊断并解除死锁的方法。

**死锁的诊断与解除：**

① 超时法

如果一个事务的等待时间超过了规定的时限，就认为发生了死锁。超时法实现简单，但其不足也很明显。一是有可能误判死锁，事务因为其他原因使等待时间超过时限，系统会误认为发生了死锁。二是时限若设置得太长，死锁发生后不能及时发现。

② 等待图法

事务等待图是一个有向图G=(T,U)。 T为结点的集合，每个结点表示正运行的事务；U为边的集合，每条边表示事务等待的情况。若T1等待T2,则T1、T2之间划一条有向边，从T1指向T2。事务等待图动态地反映了所有事务的等待情况。并发控制子系统周期性地（比如每隔1分钟）检测事务等待图，如果发现图中存在回路，则表示系统中出现了死锁。

DBMS的并发控制子系统一旦检测到系统中存在死锁，就要设法解除。通常采用的方法是选择一个处理死锁代价最小的事务，将其撤消，释放此事务持有的所有的锁，使其它事务得以继续运行下去。当然，对撤消的事务所执行的数据修改操作必须加以恢复。

查看死锁记录

```
mysql> show engine innodb status;
```