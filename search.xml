<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[编译/解释语言、静态/动态语言、静态类型/动态类型语言]]></title>
    <url>%2F2018%2F12%2F25%2F2018-12-25-%E7%BC%96%E8%AF%91%E8%A7%A3%E9%87%8A%E8%AF%AD%E8%A8%80-%E9%9D%99%E6%80%81%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80-%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[1. 前言编程语言根据不同角度有多种分类：根据运行时程序是否为机器码可以分：编译语言、解释语言。根据运行时代码可以根据某些条件改变自身结构可以分：静态语言、动态语言。根据运行期间才去做数据类型检查可以分：静态类型语言，动态类型语言。 2. 编译语言 &amp; 解释语言编译型语言 需通过编译器（compiler）将源代码编译成机器码，之后才能执行的语言。一般需经过编译（compile）、链接（linker）这两个步骤。编译是把源代码编译成机器码，链接是把各个模块的机器码和依赖库串连起来生成可执行文件。 优点：编译器一般会有预编译的过程对代码进行优化。因为编译只做一次，运行时不需要编译，所以编译型语言的程序执行效率高。可以脱离语言环境独立运行。缺点：编译之后如果需要修改就需要整个模块重新编译。编译的时候根据对应的运行环境生成机器码，不同的操作系统之间移植就会有问题，需要根据运行的操作系统环境编译不同的可执行文件。代表语言：C、C++、Pascal、Object-C以及最近很火的苹果新语言swift 解释型语言 解释性语言的程序不需要编译，相比编译型语言省了道工序，解释性语言在运行程序的时候才逐行翻译。 优点：有良好的平台兼容性，在任何环境中都可以运行，前提是安装了解释器（虚拟机）。灵活，修改代码的时候直接修改就可以，可以快速部署，不用停机维护。缺点：每次运行的时候都要解释一遍，性能上不如编译型语言。代表语言：JavaScript、Python、Erlang、PHP、Perl、Ruby 混合型语言 既然编译型和解释型各有缺点就会有人想到把两种类型整合起来，取其精华去其糟粕。就出现了半编译型语言。 比如C#，C#在编译的时候不是直接编译成机器码而是中间码，.NET平台提供了中间语言运行库运行中间码，中间语言运行库类似于Java虚拟机。.net在编译成IL代码后，保存在dll中，首次运行时由JIT在编译成机器码缓存在内存中，下次直接执行。Java先生成字节码再在Java虚拟机中解释执行。 严格来说混合型语言属于解释型语言。C#更接近编译型语言。 3. 静态语言 &amp; 动态语言动态语言 是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。动态语言说的是运行是改变结构，改变的是代码结构。主要动态语言：Object-C、C#、JavaScript、PHP、Python、Erlang。 静态语言 与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、C++。 4. 静态类型语言 &amp; 动态类型语言动态类型语言 是指在运行期间才去做数据类型检查的语言，说的是数据类型，动态类型语言的数据类型不是在编译阶段决定的，而是把类型绑定延后到了运行阶段。主要语言：Python、Ruby、Erlang、JavaScript、swift、PHP、Perl。 静态类型语言 静态类型语言的数据类型是在编译期间（或运行之前）确定的，编写代码的时候要明确确定变量的数据类型。主要语言：C、C++、C#、Java、Object-C。 5.参考资料动态语言和静态语言的区别：https://blog.csdn.net/lvxiangan/article/details/78391281 深度解析PYTHON动态语言：https://www.cnblogs.com/jiaoyu121/p/6959310.html]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式事务实现方案]]></title>
    <url>%2F2018%2F12%2F05%2F2018-12-05-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[1. 前言由集中式应用到分布式应用的转变，带来了诸多的变化，虽然分布式应用解决了单体应用复杂性高、可靠性差、扩展能力受限等诸多问题，但原来在单体应用中容易实现的特性，在分布式应用中不再那么轻松实现，比如事务，锁等场景。这带来了很大的挑战。通过不断的探索，每种问题都有不同程度的解决方案。 分布式系统文章集合： 分布式锁 分布式事务实现方案 分布式一致性 分布式Session 2. 分布式事务的挑战事务是提供一种机制将一个活动涉及的所有操作纳入到一个不可分割的执行单元，组成事务的所有操作只有在所有操作均能正常执行的情况下方能提交，只要其中任一操作执行失败，都将导致整个事务的回滚。 2.1 数据库事务的特性ACID 指数据库事务正确执行的四个基本特性的缩写，包含： 原子性(Atomicity)：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。 一致性(Consistency)：在事务开始之前和事务结束以后，数据库数据的一致性约束没有被破坏。 隔离性(Isolation)：数据库允许多个并发事务同时对数据进行读写和修改的能力，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。 持久性(Durability)：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 在使用数据库事务时需要注意，尽可能短的保持事务，修改多个不同表的数据的冗长事务会严重妨碍系统中的所有其他用户，这很有可能导致一些性能问题。 2.2 JTA &amp; JTS &amp; Spring事务2.3 分布式事务分布式系统一般由多个独立的子系统组成，多个子系统通过网络通信互相协作配合完成各个功能。有很多用例会跨多个子系统才能完成，而且这个过程中会涉及到事务的概念，即保证交易系统和支付系统的数据一致性，此处我们称这种跨系统的事务为分布式事务。 3. 参考资料还不理解“分布式事务”？这篇给你讲清楚：http://developer.51cto.com/art/201812/588511.htm JTA 深度历险 - 原理与实现：http://www.cnblogs.com/firstdream/p/8514222.html 分布式系统核心问题(一致性)：https://blog.csdn.net/zyhlwzy/article/details/78658002 CAP原则(CAP定理)、BASE理论:http://www.cnblogs.com/duanxz/p/5229352.html RocketMQ分布式消息队列设计:http://rocketmq.apache.org/docs/quick-start/ ===== Java常用类（一）之Object类详解https://www.cnblogs.com/zhangyinhua/p/7715486.html java-并发-ConcurrentHashMap高并发机制-jdk1.6https://blog.csdn.net/jianghuxiaojin/article/details/52006110 Java并发编程总结4——ConcurrentHashMap在jdk1.8中的改进http://www.cnblogs.com/everSeeker/p/5601861.html 重入锁：ReentrantLock 详解https://blog.csdn.net/Somhu/article/details/78874634 Java中Unsafe类详解https://www.cnblogs.com/thomas12112406/p/6510787.htmlhttps://www.cnblogs.com/throwable/p/9139947.html Java魔法类：sun.misc.Unsafehttps://www.cnblogs.com/suxuan/p/4948608.html 红黑树(一)之 原理和算法详细介绍https://www.cnblogs.com/skywang12345/p/3245399.html]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式事务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RocketMQ中间件指南]]></title>
    <url>%2F2018%2F12%2F05%2F2018-12-05-RocketMQ%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[1. RocketMQ概述“根据我们的研究，随着使用的队列和虚拟主题的增加，ActiveMQ IO模块成为瓶颈。我们尽力通过节流，断路器或降级解决这个问题，但效果不佳。因此，我们开始关注当时流行的消息传递解决方案Kafka。不幸的是，Kafka无法满足我们的要求，特别是在低延迟和高可靠性方面，详见 http://rocketmq.apache.org/rocketmq/how-to-support-more-queues-in-rocketmq/ ” RocketMQ有三种方式发送消息：可靠的同步(reliable synchronous),可靠的异步(reliable asynchronous)和单向传输(one-way transmission)。 1.1 同步发送producer.send可靠的同步传输用于广泛的场景，如重要的通知消息，短信通知，短信营销系统等。 发送消息: 123456789101112DefaultMQProducer producer = new DefaultMQProducer("please_rename_unique_group_name");producer.setNamesrvAddr("localhost:9876");producer.start();for (int i = 0; i &lt; 100; i++) &#123; //Create a message instance, specifying topic, tag and message body. Message msg = new Message("TopicTest","TagA",("Hello RocketMQ " +i).getBytes(RemotingHelper.DEFAULT_CHARSET)); //Call send message to deliver message to one of brokers. SendResult sendResult = producer.send(msg); System.out.printf("%s%n", sendResult);&#125;producer.shutdown(); 接收消息: 1234567891011121314DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("please_rename_unique_group_name");consumer.setNamesrvAddr("localhost:9876");consumer.subscribe("TopicTest", "*");consumer.registerMessageListener(new MessageListenerConcurrently() &#123; @Override public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs,ConsumeConcurrentlyContext context) &#123; System.out.printf("%s Receive New Messages: %s %n", Thread.currentThread().getName(), msgs); return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; &#125;&#125;);consumer.start(); 1.2 异步发送producer.send(msg, new SendCallback())异步传输通常用于响应时间敏感的业务场景。 1234567891011121314151617181920212223DefaultMQProducer producer = new DefaultMQProducer("please_rename_unique_group_name");producer.setNamesrvAddr("localhost:9876");producer.start();producer.setRetryTimesWhenSendAsyncFailed(0);for (int i = 0; i &lt; 100; i++) &#123; final int index = i; //Create a message instance, specifying topic, tag and message body. Message msg = new Message("TopicTest","TagA","OrderID188","Hello world".getBytes(RemotingHelper.DEFAULT_CHARSET)); producer.send(msg, new SendCallback() &#123; @Override public void onSuccess(SendResult sendResult) &#123; System.out.printf("%-10d OK %s %n", index, sendResult.getMsgId()); &#125; @Override public void onException(Throwable e) &#123; System.out.printf("%-10d Exception %s %n", index, e); e.printStackTrace(); &#125; &#125;);&#125;producer.shutdown(); 1.3 单向发送producer.sendOneway单向传输用于需要中等可靠性的情况，例如日志收集。 1234567891011DefaultMQProducer producer = new DefaultMQProducer("please_rename_unique_group_name");producer.setNamesrvAddr("localhost:9876");producer.start();for (int i = 0; i &lt; 100; i++) &#123; //Create a message instance, specifying topic, tag and message body. Message msg = new Message("TopicTest","TagA",("Hello RocketMQ " +i).getBytes(RemotingHelper.DEFAULT_CHARSET)); //Call send message to deliver message to one of brokers. producer.sendOneway(msg);&#125;producer.shutdown(); 1.4 分区发送producer.send(msg, new MessageQueueSelector())发送消息: 1234567891011121314151617181920MQProducer producer = new DefaultMQProducer("example_group_name");producer.start();String[] tags = new String[] &#123;"TagA", "TagB", "TagC", "TagD", "TagE"&#125;;for (int i = 0; i &lt; 100; i++) &#123; int orderId = i % 10; //Create a message instance, specifying topic, tag and message body. Message msg = new Message("TopicTestjjj", tags[i % tags.length], "KEY" + i,("Hello RocketMQ " + i).getBytes(RemotingHelper.DEFAULT_CHARSET)); SendResult sendResult = producer.send(msg, new MessageQueueSelector() &#123; @Override public MessageQueue select(List&lt;MessageQueue&gt; mqs, Message msg, Object arg) &#123; Integer id = (Integer) arg; int index = id % mqs.size(); return mqs.get(index); &#125; &#125;, orderId); System.out.printf("%s%n", sendResult);&#125;producer.shutdown(); 接收消息: 1234567891011121314151617181920212223242526272829DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("example_group_name");consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);consumer.subscribe("TopicTest", "TagA || TagC || TagD");consumer.registerMessageListener(new MessageListenerOrderly() &#123; AtomicLong consumeTimes = new AtomicLong(0); @Override public ConsumeOrderlyStatus consumeMessage(List&lt;MessageExt&gt; msgs,ConsumeOrderlyContext context) &#123; context.setAutoCommit(false); System.out.printf(Thread.currentThread().getName() + " Receive New Messages: " + msgs + "%n"); this.consumeTimes.incrementAndGet(); if ((this.consumeTimes.get() % 2) == 0) &#123; return ConsumeOrderlyStatus.SUCCESS; &#125; else if ((this.consumeTimes.get() % 3) == 0) &#123; return ConsumeOrderlyStatus.ROLLBACK; &#125; else if ((this.consumeTimes.get() % 4) == 0) &#123; return ConsumeOrderlyStatus.COMMIT; &#125; else if ((this.consumeTimes.get() % 5) == 0) &#123; context.setSuspendCurrentQueueTimeMillis(3000); return ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT; &#125; return ConsumeOrderlyStatus.SUCCESS; &#125;&#125;);consumer.start();System.out.printf("Consumer Started.%n"); 1.5 广播消费consumer.setMessageModel发送消息: 123456789DefaultMQProducer producer = new DefaultMQProducer("ProducerGroupName");producer.start();for (int i = 0; i &lt; 100; i++)&#123; Message msg = new Message("TopicTest","TagA","OrderID188","Hello world".getBytes(RemotingHelper.DEFAULT_CHARSET)); SendResult sendResult = producer.send(msg); System.out.printf("%s%n", sendResult);&#125;producer.shutdown(); 接收消息: 12345678910111213141516171819DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("example_group_name");consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);//set to broadcast modeconsumer.setMessageModel(MessageModel.BROADCASTING);consumer.subscribe("TopicTest", "TagA || TagC || TagD");consumer.registerMessageListener(new MessageListenerConcurrently() &#123; @Override public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context) &#123; System.out.printf(Thread.currentThread().getName() + " Receive New Messages: " + msgs + "%n"); return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; &#125;&#125;);consumer.start();System.out.printf("Broadcast Consumer Started.%n"); 1.6 延迟发送message.setDelayTimeLevel发送消息: 12345678910111213DefaultMQProducer producer = new DefaultMQProducer("ExampleProducerGroup");producer.start();int totalMessagesToSend = 100;for (int i = 0; i &lt; totalMessagesToSend; i++) &#123; Message message = new Message("TestTopic", ("Hello scheduled message " + i).getBytes()); // This message will be delivered to consumer 10 seconds later. message.setDelayTimeLevel(3); producer.send(message);&#125;producer.shutdown(); 接收消息: 123456789101112131415161718DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("ExampleConsumer");// Subscribe topicsconsumer.subscribe("TestTopic", "*");// Register message listenerconsumer.registerMessageListener(new MessageListenerConcurrently() &#123; @Override public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; messages, ConsumeConcurrentlyContext context) &#123; for (MessageExt message : messages) &#123; // Print approximate delay time period System.out.println("Receive message[msgId=" + message.getMsgId() + "] " + (System.currentTimeMillis() - message.getStoreTimestamp()) + "ms later"); &#125; return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; &#125;&#125;);consumer.start(); 1.7 批量发送producer.send(new ArrayList&lt;&gt;())1234567891011String topic = "BatchTest";List&lt;Message&gt; messages = new ArrayList&lt;&gt;();messages.add(new Message(topic, "TagA", "OrderID001", "Hello world 0".getBytes()));messages.add(new Message(topic, "TagA", "OrderID002", "Hello world 1".getBytes()));messages.add(new Message(topic, "TagA", "OrderID003", "Hello world 2".getBytes()));try &#123; producer.send(messages);&#125; catch (Exception e) &#123; e.printStackTrace(); //handle the error&#125; 只有在发送大批量时，复杂性才会增加，您可能不确定它是否超出了大小限制（1MiB）。 1.8 消费过滤MessageSelector.bySql发送消息: 12345678910DefaultMQProducer producer = new DefaultMQProducer("please_rename_unique_group_name");producer.start();Message msg = new Message("TopicTest",tag,("Hello RocketMQ " + i).getBytes(RemotingHelper.DEFAULT_CHARSET));// Set some properties.msg.putUserProperty("a", String.valueOf(i));SendResult sendResult = producer.send(msg); producer.shutdown(); 接收消息: 123456789101112DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("please_rename_unique_group_name_4");// only subsribe messages have property a, also a &gt;=0 and a &lt;= 3consumer.subscribe("TopicTest", MessageSelector.bySql("a between 0 and 3");consumer.registerMessageListener(new MessageListenerConcurrently() &#123; @Override public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context) &#123; return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; &#125;&#125;);consumer.start(); 2. 基于OpenMessaging收发消息2.1 同步发送producer.send123456789101112131415final MessagingAccessPoint messagingAccessPoint = MessagingAccessPointFactory.getMessagingAccessPoint("openmessaging:rocketmq://IP1:9876,IP2:9876/namespace");final Producer producer = messagingAccessPoint.createProducer();messagingAccessPoint.startup();System.out.printf("MessagingAccessPoint startup OK%n");producer.startup();System.out.printf("Producer startup OK%n");&#123; Message message = producer.createBytesMessageToTopic("OMS_HELLO_TOPIC", "OMS_HELLO_BODY".getBytes(Charset.forName("UTF-8"))); SendResult sendResult = producer.send(message); System.out.printf("Send sync message OK, msgId: %s%n", sendResult.messageId());&#125; 2.2 异步发送producer.sendAsync123456789101112131415161718192021222324final MessagingAccessPoint messagingAccessPoint = MessagingAccessPointFactory.getMessagingAccessPoint("openmessaging:rocketmq://IP1:9876,IP2:9876/namespace");final Producer producer = messagingAccessPoint.createProducer();messagingAccessPoint.startup();System.out.printf("MessagingAccessPoint startup OK%n");producer.startup();System.out.printf("Producer startup OK%n");&#123; final Promise&lt;SendResult&gt; result = producer.sendAsync(producer.createBytesMessageToTopic("OMS_HELLO_TOPIC", "OMS_HELLO_BODY".getBytes(Charset.forName("UTF-8")))); result.addListener(new PromiseListener&lt;SendResult&gt;() &#123; @Override public void operationCompleted(Promise&lt;SendResult&gt; promise) &#123; System.out.printf("Send async message OK, msgId: %s%n", promise.get().messageId()); &#125; @Override public void operationFailed(Promise&lt;SendResult&gt; promise) &#123; System.out.printf("Send async message Failed, error: %s%n", promise.getThrowable().getMessage()); &#125; &#125;);&#125; 2.3 单向发送producer.sendOneway1234567891011121314151617final MessagingAccessPoint messagingAccessPoint = MessagingAccessPointFactory.getMessagingAccessPoint("openmessaging:rocketmq://IP1:9876,IP2:9876/namespace");final Producer producer = messagingAccessPoint.createProducer();messagingAccessPoint.startup();System.out.printf("MessagingAccessPoint startup OK%n");producer.startup();System.out.printf("Producer startup OK%n");&#123; producer.sendOneway(producer.createBytesMessageToTopic("OMS_HELLO_TOPIC", "OMS_HELLO_BODY".getBytes(Charset.forName("UTF-8")))); System.out.printf("Send oneway message OK%n");&#125;producer.shutdown();messagingAccessPoint.shutdown(); 2.4 消费消息consumer.pollOMSPullConsumer: 1234567891011121314151617181920final MessagingAccessPoint messagingAccessPoint = MessagingAccessPointFactory.getMessagingAccessPoint("openmessaging:rocketmq://IP1:9876,IP2:9876/namespace");final PullConsumer consumer = messagingAccessPoint.createPullConsumer("OMS_HELLO_TOPIC", OMS.newKeyValue().put(NonStandardKeys.CONSUMER_GROUP, "OMS_CONSUMER"));messagingAccessPoint.startup();System.out.printf("MessagingAccessPoint startup OK%n");consumer.startup();System.out.printf("Consumer startup OK%n");Message message = consumer.poll();if (message != null) &#123; String msgId = message.headers().getString(MessageHeader.MESSAGE_ID); System.out.printf("Received one message: %s%n", msgId); consumer.ack(msgId);&#125;consumer.shutdown();messagingAccessPoint.shutdown(); 2.5 消费消息consumer.attachQueueOMSPushConsumer: 1234567891011121314151617181920212223final MessagingAccessPoint messagingAccessPoint = MessagingAccessPointFactory.getMessagingAccessPoint("openmessaging:rocketmq://IP1:9876,IP2:9876/namespace");final PushConsumer consumer = messagingAccessPoint. createPushConsumer(OMS.newKeyValue().put(NonStandardKeys.CONSUMER_GROUP, "OMS_CONSUMER"));messagingAccessPoint.startup();System.out.printf("MessagingAccessPoint startup OK%n");Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() &#123; @Override public void run() &#123; consumer.shutdown(); messagingAccessPoint.shutdown(); &#125;&#125;));consumer.attachQueue("OMS_HELLO_TOPIC", new MessageListener() &#123; @Override public void onMessage(final Message message, final ReceivedMessageContext context) &#123; System.out.printf("Received one message: %s%n", message.headers().getString(MessageHeader.MESSAGE_ID)); context.ack(); &#125;&#125;); 2. RocketMQ事务消息RocketMQ 事务消息设计则主要是为了解决 Producer 端的消息发送与本地事务执行的原子性问题，RocketMQ 的设计中 broker 与 producer 端的双向通信能力，使得 broker 天生可以作为一个事务协调者存在；而 RocketMQ 本身提供的存储机制，则为事务消息提供了持久化能力；RocketMQ 的高可用机制以及可靠消息设计，则为事务消息在系统在发生异常时，依然能够保证事务的最终一致性达成。 2.1 发送事务性消息事务性消息有三种状态： （1）TransactionStatus.CommitTransaction：提交事务，这意味着允许消费者使用此消息。 （2）TransactionStatus.RollbackTransaction：回滚事务，表示该消息将被删除而不允许使用。 （3）TransactionStatus.Unknown：中间状态，表示需要MQ检查以确定状态。 使用TransactionMQProducer类创建生成器客户端，并指定唯一的producerGroup，并且可以设置自定义线程池来处理检查请求。执行本地事务后，需要根据执行结果回复MQ，最终结果状态。 1234567891011121314151617181920212223242526272829303132TransactionListener transactionListener = new TransactionListenerImpl();TransactionMQProducer producer = new TransactionMQProducer("please_rename_unique_group_name");ExecutorService executorService = new ThreadPoolExecutor(2, 5, 100, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(2000), new ThreadFactory() &#123; @Override public Thread newThread(Runnable r) &#123; Thread thread = new Thread(r); thread.setName("client-transaction-msg-check-thread"); return thread; &#125;&#125;);producer.setExecutorService(executorService);producer.setTransactionListener(transactionListener);producer.start();String[] tags = new String[] &#123;"TagA", "TagB", "TagC", "TagD", "TagE"&#125;;for (int i = 0; i &lt; 10; i++) &#123; try &#123; Message msg =new Message("TopicTest1234", tags[i % tags.length], "KEY" + i,("Hello RocketMQ " + i).getBytes(RemotingHelper.DEFAULT_CHARSET)); SendResult sendResult = producer.sendMessageInTransaction(msg, null); System.out.printf("%s%n", sendResult); Thread.sleep(10); &#125; catch (MQClientException | UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125;&#125;for (int i = 0; i &lt; 100000; i++) &#123; Thread.sleep(1000);&#125;producer.shutdown(); 实现TransactionListener接口 executeLocalTransaction：方法用于在发送Half消息成功时执行的本地事务。它返回三种事务状态之一。 checkLocalTransaction：方法用于检查本地事务状态并响应MQ检查请求。它返回三种事务状态之一。 1234567891011121314151617181920212223242526272829public class TransactionListenerImpl implements TransactionListener &#123; private AtomicInteger transactionIndex = new AtomicInteger(0); private ConcurrentHashMap&lt;String, Integer&gt; localTrans = new ConcurrentHashMap&lt;&gt;(); @Override public LocalTransactionState executeLocalTransaction(Message msg, Object arg) &#123; int value = transactionIndex.getAndIncrement(); int status = value % 3; localTrans.put(msg.getTransactionId(), status); return LocalTransactionState.UNKNOW; &#125; @Override public LocalTransactionState checkLocalTransaction(MessageExt msg) &#123; Integer status = localTrans.get(msg.getTransactionId()); if (null != status) &#123; switch (status) &#123; case 0: return LocalTransactionState.UNKNOW; case 1: return LocalTransactionState.COMMIT_MESSAGE; case 2: return LocalTransactionState.ROLLBACK_MESSAGE; &#125; &#125; return LocalTransactionState.COMMIT_MESSAGE; &#125;&#125; 2.2 RocketMQ事务消息设计事务消息作为一种异步确保型事务， 将两个事务分支通过 MQ 进行异步解耦，RocketMQ 事务消息的设计流程同样借鉴了两阶段提交理论，整体交互流程如下图所示： 1.事务发起方首先发送 prepare 消息到 MQ。 2.再发送 prepare 消息成功后执行本地事务。 3.根据本地事务执行结果返回 commit 或者是 rollback。 4.如果消息是 rollback，MQ 将删除该 prepare 消息不进行下发，如果是 commit 消息，MQ 将会把这个消息发送给 consumer 端。 5.如果执行本地事务过程中，执行端挂掉，或者超时，MQ 将会不停的询问其同组的其他 producer 来获取状态。 6.consumer 端的消费成功机制有 MQ 保证。 2.3 RocketMQ事务消息实现RocketMQ 事务消息在实现上充分利用了 RocketMQ 本身机制，在实现零依赖的基础上，同样实现了高性能、可扩展、全异步等一系列特性。 在具体实现上，RocketMQ 通过使用 Half Topic 以及 Operation Topic 两个内部队列来存储事务消息推进状态，如下图所示： 其中，Half Topic 对应队列中存放着 prepare 消息，Operation Topic 对应的队列则存放了 prepare message 对应的 commit/rollback 消息，消息体中则是 prepare message 对应的 offset，服务端通过比对两个队列的差值来找到尚未提交的超时事务，进行回查。 在具体实现上，事务消息作为普通消息的一个应用场景，在实现过程中进行了分层抽象，从而避免了对 RocketMQ 原有存储机制的修改，如下图所示： 从用户侧来说，用户需要分别实现本地事务执行以及本地事务回查方法，因此只需关注本地事务的执行状态即可；而在 service 层，则对事务消息的两阶段提交进行了抽象，同时针对超时事务实现了回查逻辑，通过不断扫描当前事务推进状态，来不断反向请求 Producer 端获取超时事务的执行状态，在避免事务挂起的同时，也避免了 Producer 端的单点故障。而在存储层，RocketMQ 通过 Bridge 封装了与底层队列存储的相关操作，用以操作两个对应的内部队列，用户也可以依赖其他存储介质实现自己的 service，RocketMQ 会通过 ServiceProvider 加载进来。 从上述事务消息设计中可以看到，RocketMQ 事务消息较好的解决了事务的最终一致性问题，事务发起方仅需要关注本地事务执行以及实现回查接口给出事务状态判定等实现，而且在上游事务峰值高时，可以通过消息队列，避免对下游服务产生过大压力。 3.参考资料RocketMQ官方文档： http://rocketmq.apache.org/docs/quick-start/ RocketMQ 4.3正式发布，支持分布式事务：https://mp.weixin.qq.com/s?__biz=MzI4MTY5NTk4Ng==&amp;mid=2247488985&amp;idx=1&amp;sn=cafd8ce4b47bf098c7e87846318eff4d&amp;source=41#wechat_redirect]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mycat中间件指南]]></title>
    <url>%2F2018%2F12%2F04%2F2018-12-04-Mycat%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[1. Mycat概述Mycat 是什么？从定义和分类来看，它是一个开源的分布式数据库系统，是一个实现了 MySQL 协议的的Server，前端用户可以把它看作是一个数据库代理，用 MySQL 客户端工具和命令行访问，而其后端可以用MySQL 原生（Native）协议与多个 MySQL 服务器通信，也可以用 JDBC 协议与大多数主流数据库服务器通信，其核心功能是分表分库，即将一个大表水平分割为 N 个小表，存储在后端 MySQL 服务器里或者其他数据库里。 1.1 Mycat原理Mycat 的原理中最重要的一个动词是“拦截”，它拦截了用户发送过来的 SQL 语句，首先对 SQL 语句做了一些特定的分析：如分片分析、路由分析、读写分离分析、缓存分析等，然后将此 SQL 发往后端的真实数据库，并将返回的结果做适当的处理，最终再返回给用户。 1.2 Mycat应用场景Mycat 发展到现在，适用的场景已经很丰富，而且不断有新用户给出新的创新性的方案，以下是几个典型的应用场景： 单纯的读写分离，此时配置最为简单，支持读写分离，主从切换； 分表分库，对于超过 1000 万的表进行分片，最大支持 1000 亿的单表分片； 多租户应用，每个应用一个库，但应用程序只连接 Mycat，从而不改造程序本身，实现多租户化； 报表系统，借助于 Mycat 的分表能力，处理大规模报表的统计； 替代 Hbase，分析大数据； 作为海量数据实时查询的一种简单有效方案，比如 100 亿条频繁查询的记录需要在 3 秒内查询出来结果，除了基于主键的查询，还可能存在范围查询或其他属性查询，此时 Mycat 可能是最简单有效的选择。 1.3 Mycat中的概念1.3.1 逻辑库(schema)通常对实际应用来说，并不需要知道中间件的存在，业务开发人员只需要知道数据库的概念，所以数据库中间件可以被看做是一个或多个数据库集群构成的逻辑库。 1.3.2 逻辑表(table)既然有逻辑库，那么就会有逻辑表，分布式数据库中，对应用来说，读写数据的表就是逻辑表。逻辑表，可以是数据切分后，分布在一个或多个分片库中，也可以不做数据切分，不分片，只有一个表构成。 1.分片表 分片表，是指那些原有的很大数据的表，需要切分到多个数据库的表，这样，每个分片都有一部分数据，所有分片构成了完整的数据。 2.非分片表 一个数据库中并不是所有的表都很大，某些表是可以不用进行切分的，非分片是相对分片表来说的，就是那些不需要进行数据切分的表。 3.ER表 关系型数据库是基于实体关系模型（Entity-Relationship Model)之上，通过其描述了真实世界中事物与关系，Mycat 中的 ER 表即是来源于此。根据这一思路，提出了基于 E-R 关系的数据分片策略，子表的记录与所关联的父表记录存放在同一个数据分片上，即子表依赖于父表，通过表分组（Table Group）保证数据 Join 不会跨库操作。 表分组（Table Group）是解决跨分片数据 join 的一种很好的思路，也是数据切分规划的重要一条规则。 4.全局表 一个真实的业务系统中，往往存在大量的类似字典表的表，这些表基本上很少变动，字典表具有以下几个特性：变动不频繁、数据量总体变化不大、数据规模不大，很少有超过数十万条记录。对于这类的表，在分片的情况下，当业务表因为规模而进行分片以后，业务表与这些附属的字典表之间的关联，就成了比较棘手的问题，所以 Mycat 中通过数据冗余来解决这类表的 join，即所有的分片都有一份数据的拷贝，所有将字典表或者符合字典表特性的一些表定义为全局表。 数据冗余是解决跨分片数据 join 的一种很好的思路，也是数据切分规划的另外一条重要规则。 1.3.3 分片节点(dataNode)数据切分后，一个大表被分到不同的分片数据库上面，每个表分片所在的数据库就是分片节点（dataNode）。 1.3.4 节点主机(dataHost)数据切分后，每个分片节点（dataNode）不一定都会独占一台机器，同一机器上面可以有多个分片数据库，这样一个或多个分片节点（dataNode）所在的机器就是节点主机（dataHost）,为了规避单节点主机并发数限制，尽量将读写压力高的分片节点（dataNode）均衡的放在不同的节点主机（dataHost）。 1.3.5 分片规则(rule)前面讲了数据切分，一个大表被分成若干个分片表，就需要一定的规则，这样按照某种业务规则把数据分到某个分片的规则就是分片规则，数据切分选择合适的分片规则非常重要，将极大的避免后续数据处理的难度。 1.3.6 全局序列号(sequence)数据切分后，原有的关系数据库中的主键约束在分布式条件下将无法使用，因此需要引入外部机制保证数据唯一性标识，这种保证全局性的数据唯一标识的机制就是全局序列号（sequence）。 2. Mycat配置2.1 schema.xmlSchema.xml 作为 MyCat 中重要的配置文件之一，管理着 MyCat 的逻辑库、表、分片规则、DataNode 以及 DataSource。弄懂这些配置，是正确使用 MyCat 的前提。这里就一层层对该文件进行解析。 123456&lt;schema name="TESTDB" checkSQLschema="false" sqlMaxLimit="100" dataNode="dn2"&gt; &lt;table name="travelrecord" dataNode="dn1,dn2,dn3" rule="auto-sharding-long" &gt;&lt;/table&gt;&lt;/schema&gt;&lt;schema name="USERDB" checkSQLschema="false" sqlMaxLimit="100"&gt; &lt;table name="company" dataNode="dn10,dn11,dn12" rule="auto-sharding-long" &gt;&lt;/table&gt;&lt;/schema&gt; schema：该标签用于定义 MyCat 实例中的逻辑库，MyCat 可以有多个逻辑库，每个逻辑库都有自己的相关配置。可以使用 schema 标签来划分这些不同的逻辑库。如果不配置 schema 标签，所有的表配置，会属于同一个默认的逻辑库。 table：该标签定义了 MyCat 中的逻辑表，所有需要拆分的表都需要在这个标签中定义。 childTable：该标签用于定义 E-R 分片的子表。通过标签上的属性与父表进行关联。 dataNode：该标签定义了 MyCat 中的数据节点，也就是我们通常说所的数据分片。一个 dataNode 标签就是一个独立的数据分片。 dataHost：该标签在 mycat 逻辑库中也是作为最底层的标签存在，直接定义了具体的数据库实例、读写分离配置和心跳语句。 heartbeat：该标签内指明用于和后端数据库进行心跳检查的语句。例如,MYSQL 可以使用 select user()，Oracle 可以使用 select 1 from dual 等。 2.2 server.xmlserver.xml 几乎保存了所有 mycat 需要的系统配置信息。其在代码内直接的映射类为 SystemConfig 类。 12345678910111213&lt;user name="test"&gt; &lt;property name="password"&gt;test&lt;/property&gt; &lt;property name="schemas"&gt;TESTDB&lt;/property&gt; &lt;property name="readOnly"&gt;true&lt;/property&gt; &lt;property name="benchmark"&gt;11111&lt;/property&gt; &lt;property name="usingDecrypt"&gt;1&lt;/property&gt; &lt;privileges check="false"&gt; &lt;schema name="TESTDB" dml="0010" showTables="custome/mysql"&gt; &lt;table name="tbl_user" dml="0110"&gt;&lt;/table&gt; &lt;table name="tbl_dynamic" dml="1111"&gt;&lt;/table&gt; &lt;/schema&gt; &lt;/privileges&gt;&lt;/user&gt; user：这个标签主要用于定义登录 mycat 的用户和权限。 system：该标签内嵌套的所有 property 标签都与系统配置有关，请注意，下面我会省去标签 property 直接使用这个标签的 name 属性内的值来介绍这个属性的作用。 2.3 rule.xmlrule.xml 里面就定义了我们对表进行拆分所涉及到的规则定义。我们可以灵活的对表使用不同的分片算法，或者对表使用相同的算法但具体的参数不同。这个文件里面主要有 tableRule 和 function 这两个标签。在具体使用过程中可以按照需求添加 tableRule 和 function。 123456789&lt;tableRule name="rule1"&gt; &lt;rule&gt; &lt;columns&gt;id&lt;/columns&gt; &lt;algorithm&gt;func1&lt;/algorithm&gt; &lt;/rule&gt;&lt;/tableRule&gt;&lt;function name="hash-int" class="io.mycat.route.function.PartitionByFileMap"&gt; &lt;property name="mapFile"&gt;partition-hash-int.txt&lt;/property&gt;&lt;/function&gt; tableRule：该标签定义表规则。 function：该标签用于路由算法的配置 3. Mycat分库分表当你找到某个合适的业务字段作为分片字段以后，不必纠结于“牺牲了按主键查询记录的性能”，因为在这种情况下，MyCAT 提供了“主键到分片”的内存缓存机制，热点数据按照主键查询，丝毫不损失性能。 3.1 Mycat全局表如果你的业务中有些数据类似于数据字典，比如配置文件的配置，常用业务的配置或者数据量不大很少变动的表，这些表往往不是特别大，而且大部分的业务场景都会用到，那么这种表适合于 Mycat 全局表，无须对数据进行切分，只要在所有的分片上保存一份数据即可。 1&lt;table name="t_area" primaryKey="id" type="global" dataNode="dn1,dn2" /&gt; 3.2 ER分片表有一类业务，例如订单（order）跟订单明细（order_detail）,明细表会依赖于订单，也就是说会存在表的主从关系，这类似业务的切分可以抽象出合适的切分规则，比如根据用户 ID 切分,其他相关的表都依赖于用户 ID，再或者根据订单 ID 切分，总之部分业务总会可以抽象出父子关系的表。这类表适用于 ER 分片表。 子表的记录与所关联的父表记录存放在同一个数据分片上，避免数据 Join 跨库操作 123&lt;table name="order" dataNode="dn$1-32" rule="mod-long"&gt; &lt;childTable name="order_detail" primaryKey="id" joinKey="order_id" parentKey="order_id" /&gt;&lt;/table&gt; 3.3 多对多关联有一类业务场景是 “主表 A+关系表+主表 B”，举例来说就是商户会员+订单+商户，对应这类业务，如何切分？目前总的原则是需要从业务角度来看，关系表更偏向哪个表，即“A 的关系”还是“B 的关系”，来决定关系表跟从那个方向存储，未来 Mycat版本中将考虑将中间表进行双向复制，以实现从 A-关系表 以及 B-关系表的双向关联查。 3.4 常用分片规则 分类 说明 io.mycat.route.function.PartitionByFileMap 分片枚举 io.mycat.route.function.PartitionByLong 固定分片hash算法 io.mycat.route.function.AutoPartitionByLong 范围约定 io.mycat.route.function.PartitionByMod 取模 io.mycat.route.function.PartitionByDate 按日期（天）分片 io.mycat.route.function.PartitionByPattern 取模范围约束 io.mycat.route.function.PartitionByPrefixPattern 截取数字做hash求模范围约束 io.mycat.route.function.PartitionDirectBySubString 应用指定 io.mycat.route.function.PartitionByString 截取数字hash解析 io.mycat.route.function.PartitionByMurmurHash 一致性 hash io.mycat.route.function.LatestMonthPartion 按单月小时拆分 io.mycat.route.function.PartitionByRangeMod 范围求模分片 io.mycat.route.function.PartitionByRangeDateHash 日期范围hash分片 io.mycat.route.function.PartitionByHotDate 冷热数据分片 io.mycat.route.function.PartitionByMonth 自然月分片 io.mycat.route.function.PartitionByCRC32PreSlot 有状态分片算法 3.5 数据扩容方案3.5.1 离线扩容缩容1、 复制 schema.xml、 rule.xml 并重命名为 newSchema.xml、 newRule.xml 放于 conf 目录下。 2、 修改 newSchema.xml 和 newRule.xml 配置文件为扩容缩容后的 mycat 配置参数（表的节点数、数据源、路由规则）。 3、 修改 conf 目录下的 migrateTables.properties 配置文件， 告诉工具哪些表需要进行扩容或缩容,没有出现在此配置文件的 schema 表不会进行数据迁移。 4、 修改 bin 目录下的 dataMigrate.sh 脚本文件。 5、 停止 mycat 服务（如果可以确保扩容缩容过程中不会有写操作， 也可以不停止 mycat 服务）。 6、 通过 crt 等工具进入 mycat 根目录， 执行 bin/ dataMigrate.sh 脚本， 开始扩容/缩容过程。 7、 扩容缩容成功后， 将 newSchema.xml 和 newRule.xml 重命名为 schema.xml 和 rule.xml 并替换掉原文件， 重启 mycat 服务， 整个扩容缩容过程完成。 4. Mycat读写分离对于MySQL来说，标准的读写分离是主从模式，一个写节点Master后面跟着多个读节点，读节点的数量取决于系统的压力。 4.1 MySQL主从模式种类 MySQL 主从复制的原理如下： 第一步是在主库上记录二进制日志（稍后介绍如何设置）。在每次准备提交事务完成数据更新前，主库将数据更新的事件记录到二进制日志中。MySQL 会按事务提交的顺序 而非每条语句的执行顺序来记录二进制日志。在记录二进制日志后，主库会告诉存储引擎可以提交事务了。下一步，备库将主库的二进制日志复制到其本地的中继日志中。首先,备库会启动一个工作线程，称为I/O线程,I/O线程跟主库建立一个普通的客户端连接，然后在主库上启 动一个特殊的二进制转储(binhg dump、线程（该线程没有对应的 SQL 命令），这个二进制转储线程会读取主库上二进制日志中的事件。它不会对事件进行轮询。如果该线程追赶上了主库，它将进入睡眠状态，直到主库发送信号量通知其有新的事件产生时才会 被唤醒，备库 I/O 线程会将接收到的事件记录到中继日志中。 备库的SQL线程执行最后一步，该线程从中继日志中读取事件并在备库执行，从而实现备库数据的更新。当SQL线程追赶上I/O 线程时，中继日志通常已经在系统缓存中，所以中继日志的开销很低。SQL线程执行的事件也可以通过配置选项来决定是否写入其自己的二进制日志中。这种复制架构实现了获取事件和重放事件的解耦，允许这两个过程异步进行。也就是说 I/o 线程能够独立于 SQL 线程之外工作。但这种架构也限制了复制的过程，其中最重要 的一点是在主库上并发运行的査询在备库只能串行化执行，因为只有一个 SQL 线程来重 放中继日志中的事件。 进行同步复制，这将大大改善MySQL主从同步的数据延迟问题，配合Mycat分片，可以更好的将一个超级大表的数据同步的时延降低到最低。即使是并发复制机制、仍然无法避免主从数据库的数据瞬间不同步的问题，因此又有了一种增强的方案，即galera for mysql、percona-cluster或者mariadb cluster等集群机制，他们是一种多主同步复制的模式，可以在任意节点上进行读写、自动控制成员，自动删除故障节点、自动加入节点、真正给予行级别的并发复制等强大能力。 MySQL主从同步的监控 MySQL有主从同步的状态信息，可以通过命令以下获取： show slave status：获知当前是否主从同步正常工作。其中Seconds_Behind_Master字段从字面理解，它表示当前MySQL主从数据的同步延迟，单位是秒，但这个指标从DBA的角度并不能简单的理解为延迟多少秒，但对于应用来说，简单的认为是主从同步的时间差就可以了，另外，当主从同步停止以后，重新启动同步，这个数值可能会是几万秒，取决于主从同步停止的时间长短，我们可以认为数据此时有很多天没有同步了，而这个数值越接近零，则说明主从同步延迟最小。 我们可以采集这个指标并汇聚曲线图，来分析我们的数据库的同步延迟曲线，然后根据此曲线，给出一个合理的阀值，主从同步的时延小于阀值时，我们认为从库是同步的，此时可以安全的从从库读取数据。Mycat 未来将支持这种优化，让应用更加可靠的读取到预期的从库数据。 4.2 MySQL高可用方案1.主从复制+读写分离 对于数据实时性要求不是特别严格的应用，只需要通过廉价的 pc server 来扩展 Slave 的数量，将读压力分散到多台 Slave 的机器上面，即可通过分散单台数据库服务器的读压力来解决数据库端的读性能瓶颈，毕竟在大多数数据库应用系统中的读压力还是要比写压力大很多。这在很大程度上解决了目前很多中小型网站的数据库压力瓶颈问题，甚至有些大型网站也在使用类似方案解决数据库瓶颈。 2.MySQL Cluster MySQL Cluster 由一组计算机构成，每台计算机上均运行着多种进程，包括 MySQL 服务器，NDB Cluster的数据节点，管理服务器，以及（可能）专门的数据访问程序。NDB”是一种“内存中”的存储引擎，它具有可用性高和数据一致性好的特点。MySQL Cluster 要实现完全冗余和容错，至少需要 4 台物理主机，其中两个为管理节点。MySQL Cluster使用不那么广泛，除了自身构架因素、适用的业务有限之外，另一个重要的原因是其安装配置管理相对复杂繁琐，总共有几十个操作步骤，需要 DBA 花费几个小时才能搭建或完成。重启 MySQLCluster 数据库的管理操作之前需要执行 46 个手动命令，需要耗费 DBA 2.5 小时的时间，而依靠 MySQLCluster Manager 只需一个命令即可完成，但 MySQL Cluster Manager 仅作为商用 MySQL Cluster 运营商级版本 (CGE) 数据库的一部分提供，需要购买。其官方的说明，若应用中的 SQL 操作为主键数据库访问，包含一些JOIN 操作而非对整个表执行常规扫描和 JOIN 而返回数万行数据，则适合 Cluster，否则不合适，从这一条限制来看，表明大多数业务场景并不合适 MySQL Cluster，业内有资深人士也凭评价：NDB 不适合大多数业务场景，而且有安全问题。 3.HeartBeat+双主复制 heartbeat 是 Linux-HA 工程的一个组件,heartbeat 最核心的包括两个部分：心跳监测和资源接管。在指定的时间内未收到对方发送的报文，那么就认为对方失效，这时需启动资源接管模块来接管运 行在对方主机上的资源或者服务。 4.HeartBeat+DRBD+MySQL DRBD 是通过网络来实现块设备的数据镜像同步的一款开源 Cluster 软件，它自动完成网络中两个不同服务器上的磁盘同步，相对于 binlog 日志同步，它是更底层的磁盘同步，理论上 DRDB 适合很多文件型系统的高可用。 5.Lvs+Keepalived+双主复制 Lvs 是一个虚拟的服务器集群系统，可以实现 LINUX 平台下的简单负载均衡。keepalived 是一个类似于layer3, 4 &amp; 5 交换机制的软件，主要用于主机与备机的故障转移，这是一种适用面很广的负载均衡和高可用方案，最常用于 Web 系统。 6.Galera Cluster 这种 gluster 模式可以说是全新的一种高可用方案，前面也提到其优点，它的缺点不多，不支持 XA，不支持Lock Table，只能用 InnoDB 引擎。 4.3 Mycat读写分离支持12345678&lt;dataHost name="localhost1" maxCon="1000" minCon="10" balance="1" writeType="0" dbType="mysql" dbDriver="native"&gt; &lt;heartbeat&gt;select user()&lt;/heartbeat&gt; &lt;!-- can have multi write hosts --&gt; &lt;writeHost host="hostM1" url="localhost:3306" user="root" password="123456"&gt; &lt;!-- can have multi read hosts --&gt; &lt;readHost host="hostS1" url="localhost2:3306" user="root" password="123456"weight="1" /&gt; &lt;/writeHost&gt;&lt;/dataHost&gt; 或者 12345678&lt;dataHost name="localhost1" maxCon="1000" minCon="10" balance="1" writeType="0" dbType="mysql" dbDriver="native"&gt; &lt;heartbeat&gt;select user()&lt;/heartbeat&gt; &lt;!-- can have multi write hosts --&gt; &lt;writeHost host="hostM1" url="localhost:3306" user="root" password="123456"&gt; &lt;/writeHost&gt; &lt;writeHost host="hostS1" url="localhost:3307" user="root" password="123456"&gt; &lt;/writeHost&gt;&lt;/dataHost&gt; 以上两种取模第一种当写挂了读不可用，第二种可以继续使用，事务内部的一切操作都会走写节点，所以读操作不要加事务，如果读延时较大，使用根据主从延时的读写分离，或者强制走写节点。 当你是1主3从的模式的时候，可以把第一个从节点配置为writeHost 2，第2个和第三个从节点则配置为writeHost 1的readHost: 12345678&lt;dataHost name="localhost1" maxCon="1000" minCon="10" balance="1" writeType="0" dbType="mysql" dbDriver="native"&gt; &lt;heartbeat&gt;select user()&lt;/heartbeat&gt; &lt;writeHost host="hostM1" url="localhost:3306" user="root" password="123456" &gt; &lt;readHost host="hostS2" url="localhost3:3306" user="root" password="123456" /&gt; &lt;readHost host="hostS3" url="localhos4t:3306" user="root" password="123456" /&gt; &lt;/writeHost&gt; &lt;writeHost host="hostS1" url="localhost2:3306" user="root" password="123456" /&gt;&lt;/dataHost&gt; 根据主从延时切换： 1.4开始支持MySQL主从复制状态绑定的读写分离机制，让读更加安全可靠，配置如下： 1234567&lt;dataHost name="localhost1" maxCon="1000" minCon="10" balance="0" writeType="0" dbType="mysql" dbDriver="native" switchType="2" slaveThreshold="100"&gt; &lt;heartbeat&gt;show slave status&lt;/heartbeat&gt; &lt;!-- can have multi write hosts --&gt; &lt;writeHost host="hostM1" url="localhost:3306" user="root" password="123456"&gt; &lt;/writeHost&gt; &lt;writeHost host="hostS1" url="localhost:3316" user="root" password="123456" /&gt;&lt;/dataHost&gt; MyCAT心跳检查语句配置为 show slave status,dataHost 上定义两个新属性： switchType=”2” 与slaveThreshold=”100”，此时意味着开启 MySQL 主从复制状态绑定的读写分离与切换机制，Mycat心跳机制通过检测 show slave status中的”Seconds_Behind_Master”, “Slave_IO_Running”,”Slave_SQL_Running” 三个字段来确定当前主从同步的状态以及Seconds_Behind_Master主从复制时延,当Seconds_Behind_Master &gt; slaveThreshold时，读写分离筛选器会过滤掉此Slave机器，防止读到很久之前的旧数据，而当主节点宕机后，切换逻辑会检查Slave上的 Seconds_Behind_Master 是否为0，为0时则表示主从同步，可以安全切换，否则不会切换。 1.4.1开始支持MySQL 集群模式，让读更加安全可靠,配置如下： 123456&lt;dataHost name="localhost1" maxCon="1000" minCon="10" balance="0" writeType="0" dbType="mysql" dbDriver="native" switchType="3"&gt; &lt;heartbeat&gt; show status like ‘wsrep%’ &lt;/heartbeat&gt; &lt;writeHost host="hostM1" url="localhost:3306" user="root"password="123456"&gt; &lt;/writeHost&gt; &lt;writeHost host="hostS1"url="localhost:3316"user="root"password="123456" &gt;&lt;/writeHost&gt;&lt;/dataHost&gt; MyCAT 心跳检查语句配置为 show status like ‘wsrep%’,dataHost 上定义两个新属性： switchType=”3”此时意味着开启MySQL集群复制状态状态绑定的读写分离与切换机制，Mycat心跳机制通过检测集群复制时延时，如果延时过大或者集群出现节点问题不会负载改节点。 switchType字典值： -1：表示不自动切换 1：默认值，自动切换 2：基于MySQL主从同步的状态决定是否切换，心跳语句为show slave status 3：基于MySQL galary cluster的切换机制(适合集群)（1.4.1）,心跳语句为 show status like ‘wsrep%’ 4.4 Mycat高可用方案Mycat 作为一个代理层中间件，Mycat 系统的高可用涉及到 Mycat 本身的高可用以及后端 MySQL 的高可用，前面章节所讲的 MySQL 高可用方案都可以在此用来确保 Mycat 所连接的后端 MySQL 服务的高可用性。在大多数情况下，建议采用标准的 MySQL 主从复制高可用性配置并交付给 Mycat 来完成后端 MySQL 节点的主从自动切换。 5. Mycat系统架构系统架构 最佳实践 6. 参考资料Mycat权威指南：http://www.mycat.io/document/mycat-definitive-guide.pdf Mycal社区：http://www.mycat.io/]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>Mycat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TiDB数据库指南]]></title>
    <url>%2F2018%2F12%2F03%2F2018-12-03-TiDB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[1.TiDB 系统架构TiDB 是 PingCAP 公司设计的开源分布式 HTAP (Hybrid Transactional and Analytical Processing) 数据库，结合了传统的 RDBMS 和 NoSQL 的最佳特性。TiDB 兼容 MySQL，支持无限的水平扩展，具备强一致性和高可用性。TiDB 的目标是为 OLTP (Online Transactional Processing) 和 OLAP (Online Analytical Processing) 场景提供一站式的解决方案。 TiDB 具备如下特性： 高度兼容 MySQL 大多数情况下，无需修改代码即可从 MySQL 轻松迁移至 TiDB，分库分表后的 MySQL 集群亦可通过 TiDB 工具进行实时迁移。 水平弹性扩展 通过简单地增加新节点即可实现 TiDB 的水平扩展，按需扩展吞吐或存储，轻松应对高并发、海量数据场景。 无限水平扩展是 TiDB 的一大特点，这里说的水平扩展包括两方面：计算能力和存储能力。TiDB Server 负责处理 SQL 请求，随着业务的增长，可以简单的添加 TiDB Server 节点，提高整体的处理能力，提供更高的吞吐。TiKV 负责存储数据，随着数据量的增长，可以部署更多的 TiKV Server 节点解决数据 Scale 的问题。PD 会在 TiKV 节点之间以 Region 为单位做调度，将部分数据迁移到新加的节点上。所以在业务的早期，可以只部署少量的服务实例（推荐至少部署 3 个 TiKV， 3 个 PD，2 个 TiDB），随着业务量的增长，按照需求添加 TiKV 或者 TiDB 实例。 高可用 高可用是 TiDB 的另一大特点，TiDB/TiKV/PD 这三个组件都能容忍部分实例失效，不影响整个集群的可用性。下面分别说明这三个组件的可用性、单个实例失效后的后果以及如何恢复。 TiDB 高可用:TiDB 是无状态的，推荐至少部署两个实例，前端通过负载均衡组件对外提供服务。当单个实例失效时，会影响正在这个实例上进行的 Session，从应用的角度看，会出现单次请求失败的情况，重新连接后即可继续获得服务。单个实例失效后，可以重启这个实例或者部署一个新的实例。 PD高可用:PD 是一个集群，通过 Raft 协议保持数据的一致性，单个实例失效时，如果这个实例不是 Raft 的 leader，那么服务完全不受影响；如果这个实例是 Raft 的 leader，会重新选出新的 Raft leader，自动恢复服务。PD 在选举的过程中无法对外提供服务，这个时间大约是3秒钟。推荐至少部署三个 PD 实例，单个实例失效后，重启这个实例或者添加新的实例。 TiKV高可用:TiKV 是一个集群，通过 Raft 协议保持数据的一致性（副本数量可配置，默认保存三副本），并通过 PD 做负载均衡调度。单个节点失效时，会影响这个节点上存储的所有 Region。对于 Region 中的 Leader 结点，会中断服务，等待重新选举；对于 Region 中的 Follower 节点，不会影响服务。当某个 TiKV 节点失效，并且在一段时间内（默认 30 分钟）无法恢复，PD 会将其上的数据迁移到其他的 TiKV 节点上。 分布式事务 TiDB 100% 支持标准的 ACID 事务。 真正金融级高可用 相比于传统主从 (M-S) 复制方案，基于 Raft 的多数派选举协议可以提供金融级的 100% 数据强一致性保证，且在不丢失大多数副本的前提下，可以实现故障的自动恢复 (auto-failover)，无需人工介入。 一站式 HTAP 解决方案 TiDB 作为典型的 OLTP 行存数据库，同时兼具强大的 OLAP 性能，配合 TiSpark，可提供一站式 HTAP 解决方案，一份存储同时处理 OLTP &amp; OLAP，无需传统繁琐的 ETL 过程。 云原生 SQL 数据库 TiDB 是为云而设计的数据库，支持公有云、私有云和混合云，使部署、配置和维护变得十分简单。 2.TiKV Server 存储层 TiKV Server 负责存储数据，从外部看 TiKV 是一个分布式的提供事务的 Key-Value 存储引擎。存储数据的基本单位是 Region，每个 Region 负责存储一个 Key Range（从 StartKey 到 EndKey 的左闭右开区间）的数据，每个 TiKV 节点会负责多个 Region。TiKV 使用 Raft 协议做复制，保持数据的一致性和容灾。副本以 Region 为单位进行管理，不同节点上的多个 Region 构成一个 Raft Group，互为副本。数据在多个 TiKV 之间的负载均衡由 PD 调度，这里也是以 Region 为单位进行调度。 1.水平扩展 对于一个 KV 系统，将数据分散在多台机器上有两种比较典型的方案：一种是按照 Key 做 Hash，根据 Hash 值选择对应的存储节点；另一种是分 Range，某一段连续的 Key 都保存在一个存储节点上。TiKV 选择了第二种方式，将整个 Key-Value 空间分成很多段，每一段是一系列连续的 Key，我们将每一段叫做一个 Region，并且我们会尽量保持每个 Region 中保存的数据不超过一定的大小(这个大小可以配置，目前默认是 64mb)。每一个 Region 都可以用 StartKey 到 EndKey 这样一个左闭右开区间来描述。 2.事务 TiKV 的事务采用的是 Percolator 模型，并且做了大量的优化。TiKV 的事务采用乐观锁(TiKV通过实现MVCC来处理并发问题)，事务的执行过程中，不会检测写写冲突，只有在提交过程中，才会做冲突检测，冲突的双方中比较早完成提交的会写入成功，另一方会尝试重新执行整个事务。当业务的写入冲突不严重的情况下，这种模型性能会很好，比如随机更新表中某一行的数据，并且表很大。但是如果业务的写入冲突严重，性能就会很差，举一个极端的例子，就是计数器，多个客户端同时修改少量行，导致冲突严重的，造成大量的无效重试。 3.TiDB Server 运算层 TiDB Server 负责接收 SQL 请求，处理 SQL 相关的逻辑，并通过 PD 找到存储计算所需数据的 TiKV 地址，与 TiKV 交互获取数据，最终返回结果。TiDB Server 是无状态的，其本身并不存储数据，只负责计算，可以无限水平扩展，可以通过负载均衡组件（如LVS、HAProxy 或 F5）对外提供统一的接入地址。 用户的 SQL 请求会直接或者通过 Load Balancer 发送到 tidb-server，tidb-server 会解析 MySQL Protocol Packet，获取请求内容，然后做语法解析、查询计划制定和优化、执行查询计划获取和处理数据。数据全部存储在 TiKV 集群中，所以在这个过程中 tidb-server 需要和 tikv-server 交互，获取数据。最后 tidb-server 需要将查询结果返回给用户。 4.PD Server 调度层Placement Driver (简称 PD) 是整个集群的管理模块，其主要工作有三个：一是存储集群的元信息（某个 Key 存储在哪个 TiKV 节点）；二是对 TiKV 集群进行调度和负载均衡（如数据的迁移、Raft group leader 的迁移等）；三是分配全局唯一且递增的事务 ID。PD 是一个集群，需要部署奇数个节点，一般线上推荐至少部署 3 个节点。 PD 不断的通过 Store 或者 Leader 的心跳包收集信息，获得整个集群的详细数据，并且根据这些信息以及调度策略生成调度操作序列，每次收到 Region Leader 发来的心跳包时，PD 都会检查是否有对这个 Region 待进行的操作，通过心跳包的回复消息，将需要进行的操作返回给 Region Leader，并在后面的心跳包中监测执行结果。注意这里的操作只是给 Region Leader 的建议，并不保证一定能得到执行，具体是否会执行以及什么时候执行，由 Region Leader 自己根据当前自身状态来定。 5.TiSpark 数据分析层TiSpark 作为 TiDB 中解决用户复杂 OLAP 需求的主要组件，将 Spark SQL 直接运行在 TiDB 存储层上，同时融合 TiKV 分布式集群的优势，并融入大数据社区生态。至此，TiDB 可以通过一套系统，同时支持 OLTP 与 OLAP，免除用户数据同步的烦恼。 6.扩容缩容(存储层)TiDB 集群扩容缩容方案： https://www.pingcap.com/docs-cn/op-guide/horizontal-scale/ TiDB 集群扩容缩容方案(使用TiDB Ansible)： https://www.pingcap.com/docs-cn/op-guide/ansible-deployment-scale/ 7.数据同步(Binlog同步)TiDB-Binlog 是一个用于收集 TiDB 的 Binlog，并提供实时备份和同步功能的商业工具。TiDB-Binlog 支持以下功能场景： 数据同步：同步 TiDB 集群数据到其他数据库。 实时备份和恢复：备份 TiDB 集群数据，同时可以用于 TiDB 集群故障时恢复。 TiDB-Binlog 的整体架构： TiDB-Binlog 集群主要分为 Pump 和 Drainer 两个组件： Pump：用于实时记录 TiDB 产生的 Binlog，并将 Binlog 按照事务的提交时间进行排序，再提供给 Drainer 进行消费。 Drainer：从各个 Pump 中收集 Binlog 进行归并，再将 Binlog 转化成 SQL 或者指定格式的数据，最终同步到下游。 主要特性: 1.多个 Pump 形成一个集群，可以水平扩容；2.TiDB 通过内置的 Pump Client 将 Binlog 分发到各个 Pump；3.Pump 负责存储 Binlog，并将 Binlog 按顺序提供给 Drainer；4.Drainer 负责读取各个 Pump 的 Binlog，归并排序后发送到下游。 Drainer支持的db-type： “mysql”, “pb”, “kafka”, “flash”, “tidb”。 8.参考资料TiDB官网: https://www.pingcap.com/docs-cn/]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>TiDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL读写分离方案选型]]></title>
    <url>%2F2018%2F12%2F02%2F2018-12-02-MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%96%B9%E6%A1%88%E9%80%89%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[1.读写分离方案目前要实现mysql的主从读写分离，主要有以下几种方案： 1.1 修改源码通过程序实现，网上很多现成的代码，比较复杂，如果添加从服务器要更改多台服务器的代码。 1.2 自研自己开发接口实现，这种方案门槛高，开发成本高，不是一般的小公司能承担得起。 1.3 中间件由于mysql-proxy的主从读写分离是通过lua脚本来实现，目前lua的脚本的开发跟不上节奏，而写没有完美的现成的脚本，因此导致用于生产环境的话风险比较大，据网上很多人说mysql-proxy的性能不高。阿里开源项目Amoeba具有负载均衡、高可用性、sql过滤、读写分离、可路由相关的query到目标数据库，并且安装配置非常简单。 2.读写分离中间件2.1 活跃中的项目2.1.1 [活跃]-MySQL-Router(官方)官网地址: https://dev.mysql.com/doc/mysql-router/8.0/en/ 由MySQL官方提供，MySQL Router用于取代MySQL Proxy，建议MySQL Router与应用程序部署在一台机器。应用程序像访问MySQL一样访问MySQL Proxy，由MySQL Proxy将数据转发给后端的MySQL。支持各种操作系统。 使用MySQL-Router实现应用程序的高可用: https://segmentfault.com/a/1190000011970688 2.1.2 [活跃]-MySQL-Cluster(官方)MySQL Cluster 是MySQL 官方集群部署方案，它的历史较久。支持通过自动分片支持读写扩展，通过实时备份冗余数据，是可用性最高的方案，声称可做到99.999%的可用性。MySQL-Cluster 的稳定性也不是太好。 实战体验几种MySQLCluster方案: https://www.2cto.com/database/201504/387166.html 2.1.3 [活跃]-MaxScale(MariaDB)MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可 MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品。在存储引擎方面，使用XtraDB（英语：XtraDB）来代替MySQL的InnoDB。 MariaDB由MySQL的创始人Michael Widenius（英语：Michael Widenius）主导开发，他早前曾以10亿美元的价格，将自己创建的公司MySQL AB卖给了SUN，此后，随着SUN被甲骨文收购，MySQL的所有权也落入Oracle的手中。MariaDB名称来自Michael Widenius的女儿Maria的名字。 MariaDB基于事务的Maria存储引擎，替换了MySQL的MyISAM存储引擎，它使用了Percona的 XtraDB，InnoDB的变体，分支的开发者希望提供访问即将到来的MySQL 5.4 InnoDB性能。这个版本还包括了 PrimeBase XT (PBXT) 和 FederatedX存储引擎。 MaxScale是mariadb开发的一个MySQL数据中间件，配置好MySQL的主从复制架构后，可以实现读写分离，把读操作分散到从服务器中，并且对多个服务器实现负载均衡。MaxScale是插件式结构，允许用户开发适合自己的插件。MaxScale 使用 C 语言开发，利用 Linux 下的异步 I/O 功能。使用 epoll 作为事件驱动框架。 MaxScale有两种方式实现读/写分离。一种是基于connect的，类似于Haproxy，不解析SQL语句，可以通过PHP Yii框架或Java Mybatis框架实现。在此方式中，用Maxscale做多台slave的负载均衡，并且支持主从同步延迟检测功能。 官网地址: https://mariadb.com/kb/en/mariadb-enterprise/mariadb-maxscale-20/ 利用Maxscale实现MySQL读写分离：https://www.cnblogs.com/darren-lee/p/7591416.html 2.1.4 [活跃]-Galera-Cluster(MariaDB)Mariadb Galera Cluster是一款优秀的中间件软件，同样可以实现读写分离，负载均衡等功能，并且稳定性要大大超过MySQL-Proxy，建议大家用来替代MySQL-Proxy，甚至MySQL-Cluster。 浅谈MariaDB Galera Cluster架构: https://www.cnblogs.com/vadim/p/6930566.html 2.2 停滞或未开源的项目2.2.1 [停滞]-MySQL-Proxy(官方)mysql官方提供的mysql中间件服务，上游可接入若干个mysql-client，后端可连接若干个mysql-server。它使用mysql协议，任何使用mysql-client的上游无需修改任何代码，即可迁移至mysql-proxy上。MySQL Proxy强大的一项功能是实现“读写分离（Read/Write Splitting）”。基本的原理是让主数据库处理事务性查询，而从数据库处理SELECT查询。数据库复制被用来把事务性查询导致的变更同步到集群中的从数据库。 MySQL-Proxy实现读写分离提高并发负载案例：http://blog.jobbole.com/94606/ MySQL-Proxy实际上非常不稳定，在高并发或有错误连接的情况下，进程很容易自动关闭，因此打开–keepalive参数让进程自动恢复是个比较好的办法，但还是不能从根本上解决问题，因此通常最稳妥的做法是在每个从服务器上安装一个MySQL-Proxy供自身使用，虽然比较低效但却能保证稳定性； 2.2.2 [停滞]-Atlas(MySQL-Proxy增强版)Atlas是由 Qihoo 360公司Web平台部基础架构团队开发维护的一个基于MySQL协议的数据中间层项目。它在MySQL官方推出的MySQL-Proxy 0.8.2版本的基础上，修改了大量bug，添加了很多功能特性。由于团队精力有限, 不再主要维护，很多Issue很难再继续满足。 项目地址: https://github.com/Qihoo360/Atlas 2.2.3 [停滞]-DBProxy(Atlas美团版)项目地址: https://github.com/Meituan-Dianping/DBProxy DBProxy是由美团点评公司技术工程部DBA团队（北京）开发维护的一个基于MySQL协议的数据中间层。它在奇虎360公司开源的Atlas基础上，修改了部分bug，并且添加了很多特性。最后提交时间2016年。 2.2.4 [未开源]-MTAtlas(Atlas美团版)原美团DBA团队在开源Atlas基础上做的一系列升级改造。在读写分离、单库分表的基础上，完成了分库分表的功能开发。 2.2.5 [未开源]-ArkProxy(极数云舟)极数云舟(http://www.cloud-ark.com) 公司开发的数据库中间件，核心特性包括:透明读写分离,兼容性,友好性,权重分发,消息压缩,从库接入,用户连接数限制及统计,丰富的参数配置,连接池,失败重试。 2.2.6 [停滞]-Amoeba(阿里)Amoeba是淘宝的得力作品。支持读写分离，表和库级别的读写分离，数据库水平分割，垂直分割，还有集群。mysql-proxy 只是轻量级的读写分离程序，虽然C写的，但是驱动是需要lua的脚本跑，而且在高并发下经常挂掉。程序还忽略了一些字符设定，如果数据库不是同一编码还会出现乱码,amoeba就不存在。 Amoeba致力于MySQL的分布式数据库前端代理层，它主要在应用层访问MySQL的 时候充当SQL路由功能，专注于分布式数据库代理层（Database Proxy）开发。座落与 Client、DB Server(s)之间,对客户端透明。具有负载均衡、高可用性、SQL 过滤、读写分离、可路由相关的到目标数据库、可并发请求多台数据库合并结果。 Amoeba作者陈思儒离职去盛大之后，阿里巴巴内部考虑到Amoeba的稳定性、性能和功能支持，以及其他因素，重新设立了一个项目组并且更换名称为Cobar，现在Cobar已经开源了，详情见： http://www.mysqlops.com/2012/06/19/cobar-alibaba.html 项目地址：https://sourceforge.net/projects/amoeba/ 3.数据同步工具3.1 [离线]-DataX阿里的Datax是比较优秀的产品，基于python，提供各种数据库的读写插件，多线程执行，使用起来也很简单，定义好配置json文件执行脚本就可以了，非常适合离线数据，增量数据可以使用一些编码的方式实现，但是也仅仅针对insert数据比较有效，update数据就不适合。 github地址：https://github.com/alibaba/DataX 3.2 [离线]-SqoopSqoop(发音：skup)是一款开源的工具，主要用于在Hadoop(Hive)与传统的数据库(mysql、postgresql…)间进行数据的传递，可以将一个关系型数据库（例如 ： MySQL ,Oracle ,Postgres等）中的数据导进到Hadoop的HDFS中，也可以将HDFS的数据导进到关系型数据库中。Sqoop在数据库的支持的丰富性上不如DataX，但是如果你用hadoop，用sqoop是更好的选择，因为做Apache的顶级项目，他背后的支持远远比阿里一家公司靠谱的多。 官网：http://sqoop.apache.org/ 3.3 [离线]-KettleKettle是一款国外开源的ETL工具，纯java编写，可以在Window、Linux、Unix上运行，数据抽取高效稳定。Kettle作为传统ETL工具，目前也都已经有了nosql数据库的支持，而且kettle还有图形界面可以用，使用起来简单多了。而且本来就是专门做ETL的，是Pentaho指定的ETL组件，对于数据清洗等处理数据的环节支持更好。但是数据效率一般，而且在生产环境也很少弄台windows机器，适合小项目，数据量比较小的同步。 Kettle 中文名称叫水壶，该项目的主程序员MATT 希望把各种数据放到一个壶里，然后以一种指定的格式流出。 官网：https://community.hitachivantara.com/docs/DOC-1009855 3.4 [实时]-CanalCanal是基于mysql的binlog进行数据同步的中间件。简单来说，Canal 会将自己伪装成 MySQL 从节点（Slave），并从主节点（Master）获取 Binlog，解析和贮存后供下游消费端使用。Canal 包含两个组成部分：服务端和客户端。服务端负责连接至不同的 MySQL 实例，并为每个实例维护一个事件消息队列；客户端则可以订阅这些队列中的数据变更事件，处理并存储到数据仓库中。 使用的话，安装好canal，配置好数据库参数，再编写一个客户端消费canal传过来的数据就可以了。 github地址：https://github.com/alibaba/canal 3.5 [实时]-Otterotter是在canal基础上又重新实现了可配置的消费者，使用otter的话，刚才说过的消费者就不需要写了，而otter提供了一个web界面，可以自定义同步任务及map表。非常适合mysql库之间的同步。而且通过retl_buff表的监控，也可以实现一些全量数据的同步。 但是otter也有一些不好的地方，比如界面上的参数并不是所有的都有用，文档写的一般，不是很清晰。但是想想省了好多事，还是非常好的一款中间件。 github地址：https://github.com/alibaba/otter 3.6 [实时]-DatabusDatabus是LinkedIn开源的一款低延迟的分布式数据库同步系统（a source-agnostic distributed change data capture system），它提供可靠的数据捕获、流转和数据处理功能。Databus将数据库作为唯一真实数据来源，并将变更从事务或提交日志中提取出来，然后通知相关的衍生数据库或缓存。 Databus传输层端到端的延迟是微秒级别的，这意味着每台服务器每秒可以处理数千次数据吞吐变更事件,同时还支持无限回溯能力和丰富的变更订阅功能， 项目地址: https://github.com/linkedin/databus 3.7 [实时]-MySQL主从同步1.asynchronous 异步复制 原理：在异步复制中，master写数据到binlog且sync，无需等待slave。slave request binlog后写入relay-log并flush disk。 优点：复制的性能最好 缺点：master挂掉后，slave可能会丢失事务 代表：MySQL原生的复制 2.fully synchronous 全同步复制 原理：在全同步复制中，master写数据到binlog且sync，所有slave request binlog后写入relay-log并flush disk，并且回放完日志再commit。 优点：数据不会丢失 缺点：会阻塞master session，性能太差，非常依赖网络 代表：MySQL-Cluster 3.semi synchronous 半同步复制 原理: 在半同步复制中，master写数据到binlog且sync，且commit，然后一直等待ACK。当至少一个slave request bilog后写入到relay-log并flush disk，就返回ack（不需要回放完日志） 优点：会有数据丢失风险（低） 缺点：会阻塞master session，性能差，非常依赖网络 代表：after commit, 原生的半同步 重点：由于master是在三段提交的最后commit阶段完成后才等待，所以master的其他session是可以看到这个提交事务的，所以这时候master上的数据和slave不一致，master crash后，slave数据丢失。 4.lossless replication 无损复制 原理: 在半同步复制中，master写数据到binlog且sync，然后一直等待ACK. 当至少一个slave request bilog后写入到relay-log并flush disk，就返回ack（不需要回放完日志） 优点：数据零丢失（前提是让其一直是lossless replication），性能好 缺点：会阻塞master session，非常依赖网络 代表：after sync, 原生的半同步 重点：由于master是在三段提交的第二阶段sync binlog完成后才等待, 所以master的其他session是看不见这个提交事务的，所以这时候master上的数据和slave一致，master crash后，slave没有丢失数据。 4.延迟同步如何解决？4.1 主从同步的原理主库针对写操作，顺序写binlog，从库单线程去主库顺序读”写操作的binlog”，从库取到binlog在本地原样执行（随机写），来保证主从数据逻辑上一致。mysql的主从复制都是单线程的操作，主库对所有DDL和DML产生binlog，binlog是顺序写，所以效率很高，slave的Slave_IO_Running线程到主库取日志，效率比较高，下一步，问题来了，slave的Slave_SQL_Running线程将主库的DDL和DML操作在slave实施。DML和DDL的IO操作是随即的，不是顺序的，成本高很多，还可能可slave上的其他查询产生lock争用，由于Slave_SQL_Running也是单线程的，所以一个DDL卡主了，需要执行10分钟，那么所有之后的DDL会等待这个DDL执行完才会继续执行，这就导致了延时。master可以并发，Slave_SQL_Running线程不可以并发。 4.2 延迟怎么产生的当主库的TPS并发较高时，产生的DDL数量超过slave一个sql线程所能承受的范围，那么延时就产生了，当然还有就是可能与slave的大型query语句产生了锁等待。 首要原因：数据库在业务上读写压力太大，CPU计算负荷大，网卡负荷大，硬盘随机IO太高。 次要原因：读写binlog带来的性能影响，网络传输延迟。 4.3 同步延迟解决方案一、架构方面 1.业务的持久化层的实现采用分库架构，mysql服务可平行扩展，分散压力。 2.单个库读写分离，一主多从，主写从读，分散压力。这样从库压力比主库高，保护主库。 3.服务的基础架构在业务和mysql之间加入memcache或者redis的cache层。降低mysql的读压力。 4.不同业务的mysql物理上放在不同机器，分散压力。 5.使用比主库更好的硬件设备作为slave 总结，mysql压力小，延迟自然会变小。 二、硬件方面 1.采用好服务器，比如4u比2u性能明显好，2u比1u性能明显好。 2.存储用ssd或者盘阵或者san，提升随机写的性能。 3.主从间保证处在同一个交换机下面，并且是万兆环境。 总结，硬件强劲，延迟自然会变小。一句话，缩小延迟的解决方案就是花钱和花时间。 三、主从同步加速 1、sync_binlog在slave端设置为0 2、–logs-slave-updates 从服务器从主服务器接收到的更新不记入它的二进制日志。 3、直接禁用slave端的binlog 4、slave端，如果使用的存储引擎是innodb，innodb_flush_log_at_trx_commit =2 四、文件系统属性优化 master端修改linux、Unix文件系统中文件的etime属性， 由于每当读文件时OS都会将读取操作发生的时间回写到磁盘上，对于读操作频繁的数据库文件来说这是没必要的，只会增加磁盘系统的负担影响I/O性能。可以通过设置文件系统的mount属性，组织操作系统写atime信息，在linux上的操作为：打开/etc/fstab，加上noatime参数 /dev/sdb1 /data reiserfs noatime 1 2 然后重新mount文件系统 #mount -oremount /data 5.参考资料MySQL的读写分离的几种选择；https://www.cnblogs.com/fyc119/p/7529902.html mysql的读写分离Amoeba：http://blog.51cto.com/freeze/860111 Amoeba搞定mysql主从读写分离: http://blog.chinaunix.net/uid-20639775-id-154600.html MySQL主从延时这么长，要怎么优化？: https://mp.weixin.qq.com/s/pP2f7CYbT7ftM0tvk9c4mQ mysql数据库从库同步延迟的问题：https://blog.csdn.net/caomiao2006/article/details/51011373 MySQL 主从同步延迟的原因及解决办法：https://blog.csdn.net/Soar_Away/article/details/72615012 数据同步工具: https://blog.csdn.net/frog4/article/details/79624664 Databus简介: https://blog.csdn.net/acm_lkl/article/details/78645406 DataBus&amp;Canal对比: http://www.cnblogs.com/xunshao/p/9762377.html MySQL无损复制： https://yq.aliyun.com/articles/59258]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL分库分表方案选型]]></title>
    <url>%2F2018%2F12%2F01%2F2018-12-01-MySQL%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%96%B9%E6%A1%88%E9%80%89%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[1.分库分表方案针对MySQL的分库分表，可以从不同层次切入。常见的切入层有： 编码层 -》 框架层 -》 驱动层 -》代理层 -》实现层 1.1 编码层(不推荐)在代码层面动态切换数据源，例如Spring中的AbstractRoutingDataSource，缺点也是显而易见的，需要编写大量的代码，照顾到每个分支。当涉及跨库查询、聚合，需要循环计算结果并合并的场景，工作量巨大。不建议使用该种方案。 1.2 框架层(不推荐)这种情况适合公司ORM框架统一的情况，修改或增强现有ORM框架的功能，在SQL中增加一些自定义原语或者hint来实现。主要做法是通过实现一些拦截器（比如Mybatis的Interceptor接口），增加一些自定义解析来控制数据的流向，效果虽然较好，但会改变一些现有的编程经验。很多情况要修改框架源码，不推荐。 1.3 驱动层(ShardingJDBC)基于在编码层和框架层切入的各种缺点，真正的数据库中间件起码要从驱动层开始。重新编写了一个JDBC的驱动，在内存中维护一个路由列表，然后将请求转发到真正的数据库连接中。 常用的方案为：TDDL、ShardingJDBC等。 Mysql Connector/J的Failover协议 (具体指“load balancing”、“replication”、“farbic”等）， 也是直接在驱动上进行修改。 1.4 代理层(MyCat)代理层的数据库中间件，将自己伪装成一个数据库，接受业务端的链接。然后负载业务端的请求，解析或者转发到真正的数据库中。 常用的方案为：MySQL Router、MyCat等 1.5 实现层(Mysql-Cluster,Galera-Cluster)SQL特殊版本支持，如Mysql-Cluster本身就支持各种特性，Mariadb-Galera-Cluster支持对等双主，Greenplum支持分片等。 1.6 驱动层与代理层比较1.6.1 驱动层的特点1.仅支持JAVA，支持丰富的DB 2.占用较多的数据库连接 驱动层中间件要维护很多数据库连接。比如一个分了10个 库 的表，每个java中的Connection要维护10个数据库连接。如果项目过多，则会出现连接爆炸。像Postgres这种每个连接对应一个进程的数据库，压力会很大。 3.数据聚合在业务实例执行 数据聚合，比如count sum等，是通过多次查询，然后在业务实例的内存中进行聚合。路由表存在于业务方实例内存中，通过轮询或者被动通知的途径更新路由表即可。 4.集中式管理 所有集群的配置管理都集中在一个地方，运维负担小，DBA即可完成相关操作。 驱动层的典型实现 1.6.2 代理层的特点1.异构支持，DB支持有限 与驱动层相反，代理层中间件仅支持一种后端关系型数据库，但支持多种开发语言。如果你的系统是异构的，并且都有同样的SLA要求，则推荐使用此方案。 2.运维负担大 代理层需要维护数据库连接数量有限（MySQL Router那种粘性连接除外）。但作为一个独立的服务，既要考虑单独部署，又要考虑高可用，会增加很多额外节点，更别提用了影子节点的公司了。另外，代理层是请求唯一的入口，稳定性要求极高，一旦有高耗内存的聚合查询把节点搞崩溃了，都是灾难性的事故。 代理层典型实现 1.7 使用限制1.确保数据均衡 拆分数据库的数据尽量均匀，比如按省份分user库不均匀，按userid取模会比较均匀。 2.不能深分页 不带切分键的深分页，会取出所有库所取页数之前的所有数据在内存排序计算。容易造成内存溢出。 3.减少子查询 子查询会造成SQL解析紊乱，解析错误的情况，尽量减少SQL的子查询。 4.事务最小原则 尽量缩小单机事务涉及的库范围，即尽可能减少夸库操作，将同类操作的库/表分在一起。 5.数据均衡原则 拆分数据库的数据尽量均匀，比如按省份分user库不均匀，按userid取模会比较均匀。 6.特殊函数 distinct、having、union、in、or等，一般不被支持。或者被支持，使用之后会增加风险，需要改造。 2.分库分表中间件2.1 活跃中的项目2.1.1 [活跃]-ProxySQL(轻量级)ProxySQL是一个可以实现MySQL读写分离的轻量级工具。ProxySQL的特点：将所有配置保存写入到SQLit表中。支持动态加载配置，即一般可以在线修改配置，但有少部分参数还是需要重启来生效。支持query cache。支持对query的路由，可以针对某个语句进行分配去哪个实例执行。故障切换。过滤危险的SQL。不支持分表，可以分库，但是利用规则配置实现分表。 MHA+ProxySQL实现读写分离高可用：https://www.cnblogs.com/gomysql/p/7018797.html 项目地址: https://github.com/sysown/proxysql 官网：https://proxysql.com/ 2.1.2 [活跃]-Ctrip DAL(携程)Ctrip DAL是携程框架部开发的数据库访问框架，支持代码生成和水平扩展。其由携程技术中心框架部DAL团队开发，历经3年不断打磨，并在长期的实际使用中基于大量的用户反馈不断优化。 Ctrip DAL支持流行的分库分表操作，支持Java和C#，支持Mysql和MS SqlServer。使用该框架可以在有效地保护企业已有数据库投资的同时，迅速，可靠的为企业提供数据库访问层的横向扩展能力。整个框架包括代码生成器和客户端。工作模式是使用代码生成器在线生成代码和配置，通过DAL客户端完成数据库操作。生成器具有丰富的向导指引，操作简单清晰，即可以批量生成标准DAO，也可以在方法级别定制数据库访问。 项目地址: https://github.com/ctripcorp/dal 2.1.3 [活跃]-Vitess(Youtube)这个中间件是Youtube生产在使用的，但是架构很复杂。 与以往中间件不同，使用Vitess应用改动比较大要 使用他提供语言的API接口，我们可以借鉴他其中的一些设计思想。Vitess 是一个用于 MySql 扩展的数据库解决方案。它以能够像运行在专用硬件上那样有效地运行于云体系。它集 MySql 数据库的很多重要特性和 NoSQL 数据库的可扩展性于一体。Vitess 已经成功侍服了 2011 年以来所有的 YouTube 数据库流量。 理解VITESS: https://www.cnblogs.com/zhangwushang/p/8523015.html 官网：https://vitess.io/ 项目地址：https://github.com/vitessio/vitess 2.1.4 [活跃]-Heisenberg(Cobar增强版)heisenberg 是百度的熊照同学(id:brucexx)编写的一款基于MySQL协议之上的分库分表中间件服务器，支持各种灵活（velocity脚本自定义）的分库分表规则，做到应用和分库分表相隔离，并且为mysql进行dbproxy,减少了db的连接IO压力，并且可做到读写分离以及replication的手工切换。 改编自cobar, 结合了cobar和TDDL的优势，让其分片策略变为分库表策略，节约了大量连接，其优点： 分库分表与应用脱离，分库表如同使用单库表一样 减少db 连接数压力 热重启配置 可水平扩容 遵守Mysql原生协议 读写分离 无语言限制，mysqlclient,c,java等都可以使用 Heisenberg服务器通过管理命令可以查看，如连接数，线程池，结点等，并可以调整 采用velocity的分库分表脚本进行自定义分库表，相当的灵活。 项目地址: https://github.com/brucexx/heisenberg 2.1.5 [活跃]-Mycat(Cobar增强版)2013 年阿里的 Cobar 在社区使用过程中发现存在一些比较严重的问题，及其使用限制，经过 Mycat 发起人第一次改良，第一代改良版——Mycat 诞生。 Mycat 开源以后，一些 Cobar 的用户参与了 Mycat 的开发，最终 Mycat 发展成为一个由众多软件公司的实力派架构师和资深开发人员维护的社区型开源软件。 项目地址: https://github.com/MyCATApache/Mycat-Server 利用MyCAT实现MySQL的读写分离和主从切换：https://blog.csdn.net/leonpenn/article/details/77278360 官网：http://mycat.io/ 项目地址：https://github.com/MyCATApache/Mycat-Server 2.1.6 [活跃]-Sharding-JDBC(当当)Sharding-JDBC是当当应用框架ddframe中,从关系型数据库模块dd-rdb中分离出来的数据库水平分片框架,是继dubbox、elastic-job之后ddframe开源的第三个项目。Sharding-JDBC直接分装jdbc协议,可理解为增强版的JDBC驱动,旧代码迁移成本几乎为零,定位为轻量级java框架,使用客户端直连数据库,以jar包形式提供服务,无proxy层。 项目地址: https://github.com/sharding-sphere/sharding-sphere 2.2 停滞或未开源的项目2.2.1 [停滞]-kingshard(Go语言)一个由Go开发高性能MySQL Proxy项目，kingshard在满足基本的读写分离的功能上，致力于简化MySQL分库分表操作,能够让DBA通过kingshard轻松平滑地实现MySQL数据库扩容。 sharding方式:range方式、hash方式 分表方案采用两级映射的方式： 1.kingshard将该表分成512张子表，例如：test_0000,test_0001,…test_511。 2.将shardKey通过hash或range方式定位到其要操作的记录在哪张子表上。 3.子表落在哪个node上通过配置文件设置。 基于kingshard的子表迁移方案: 1.通过自动数据迁移工具开始数据迁移。 2.数据差异小于某一临界值，阻塞老子表写操作（read-only） 3.等待新子表数据同步完毕 4.更改kingshard配置文件中的对应子表的路由规则。 5.删除老节点上的子表。 参考网址: https://segmentfault.com/a/1190000003001545 项目地址: https://github.com/flike/kingshard 2.2.2 [停滞]-MySQL Fabric(官方)为了实现和方便管理MySQL 分片以及实现高可用部署，Oracle在2014年5月推出了一套为各方寄予厚望的MySQL产品 – MySQL Fabric, 用来管理MySQL 服务，提供扩展性和容易使用的系统，Fabric当前实现了两个特性：高可用和使用数据分片实现可扩展性和负载均衡，这两个特性能单独使用或结合使用。 MySQLFabric概述: https://www.cnblogs.com/huaxingtianxia/p/7095193.html MySQL原生HA方案 – Fabric体验之旅: https://www.csdn.net/article/2014-08-20/2821300 官网: https://downloads.mysql.com/archives/utilities/ 2.2.3 [停滞]-Oceanus(58同城)58同城数据库中间件。Oceanus致力于打造一个功能简单、可依赖、易于上手、易于扩展、易于集成的解决方案，甚至是平台化系统。拥抱开源，提供各类插件机制集成其他开源项目，新手可以在几分钟内上手编程，分库分表逻辑不再与业务紧密耦合，扩容有标准模式，减少意外错误的发生。最后更新时间2015年。 项目地址：https://github.com/58code/Oceanus 2.2.4 [停滞]-TSharding(蘑菇街)TSharding 是应用于蘑菇街交易平台的一个简易 sharding 组件，也是一个 Mybatis 分库分表组件。 项目地址: https://github.com/baihui212/tsharding 2.2.5 [未开源]-DDB(网易)DDB（Distributed database）是网易杭研院立项最早，应用最为广泛的后台产品之一，也是国内最早出现的基于现有database之上开发的分布式数据库中间件，目前依然在为网易易信，云音乐，云阅读等大型互联网产品提供稳定的数据库服务。 网易分库分表数据库DDB：https://mp.weixin.qq.com/s/D03pO_wwPyjKpSK6BQIoJg 2.2.6 [停滞]-TDDL(阿里)淘宝根据自身业务需求研发了TDDL（Taobao Distributed Data Layer）框架，主要用于解决分库分表场景下的访问路由（持久层与数据访问层的配合）以及异构数据库之间的数据同步，它是一个基于集中式配置的JDBC DataSource实现，具有分库分表、Master/Salve、动态数据源配置等功能。就目前而言，许多大厂也在出一些更加优秀和社区支持更广泛的DAL层产品，比如Hibernate Shards、Ibatis-Sharding等。项目最后一次更新为2012年。 TDDL：来自淘宝的分布式数据层：https://blog.csdn.net/diu_brother/article/details/51554555 官网: https://github.com/alibaba/tb_tddl 2.2.7 [未开源]-MTDDL(美团点评)MTDDL（Meituan Distributed Data Layer），美团点评分布式数据访问层中间件，旨在为全公司提供一个通用数据访问层服务，支持MySQL动态数据源、读写分离、分布式唯一主键生成器、分库分表、动态化配置等功能，并且支持从客户端角度对数据源的各方面（比如连接池、SQL等）进行监控，后续考虑支持NoSQL、Cache等多种数据源。 MTDDL——美团点评分布式数据访问层中间件：https://tech.meituan.com/mtddl.html 2.2.8 [停滞]-Zebra(美团点评)Zebra是美团点评内部使用的数据库访问层中间件，它具有以下的功能点：配置集中管理，动态刷新。支持读写分离、分库分表。丰富的监控信息在CAT上展现 项目地址: https://github.com/Meituan-Dianping/Zebra 2.2.9 [停滞]-Cobar(阿里)Cobar是提供分布式数据库服务的中间件，由阿里中间件团队开发，是阿里巴巴B2B前台应用访问数据库的统一入口，Cobar的分布式方案是分库和分表，可以按照业务需求将数据库中耦合度较低的表分到不同的分库中，也可以按照具体表的增长速度和数据量水平切分到不同的分库中，Cobar可以实现应用层与物理分库的双向透明，从而实现应用程序访问分布式数据库与访问单库无差别。 Cobar还可以配合MySQL的心跳和binlog实现备机的自动切换，保证数据节点的可靠性，从而实现高可用性。 项目地址: https://github.com/alibaba/cobar 2.2.10 [未开源]-OneProxy(代理层)OneProxy是由原支付宝首席架构师楼方鑫开发，目前由楼方鑫创立的杭州平民软件公司（@平民架构）提供技术支持。目前已有多家公司在生成环境中使用，其中包括了支付、电商等行业。 OneProxy的主要功能有：1. 垂直分库 2. 水平分表 3. Proxy集群 4. 读高可用 5. 读写分离（master不参与读）6. 读写分离（master参与读）7. 写高可用 8. 读写随机 OneProxy使用手册-致力于打造透明的数据层: https://www.cnblogs.com/youge-OneSQL/articles/4208583.html 官网：http://www.onexsoft.com/ 2.3 其他数据库项目2.3.1 [活跃]-Greenplum(PostgreSQL)GreenPlum建立在PostgreSQL的基础上，把许许多多的PostgreSQL节点组织在一起，实现了一个强大的分布式数据库。集群包括两类角色：master和segment。 GreenPlum数据库默认会采用Hash Distribution：如果创建表时没有指定Distribution Key，则会选择Primary Key作为Distribution Key。如果Primary Key也不存在，就会选择表的第一列作为Distribution Key。和大多数的分布式系统一样，GreenPlum也支持垂直和水平两种扩容方式，垂直扩容又被称为presharding模式。 【GreenPlum】GreenPlum服务来了!: https://sq.163yun.com/blog/article/172464991000825856 官网: https://greenplum.org/ 2.3.2 [活跃]-MariaDB Spider(Mariadb)MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可 MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品。在存储引擎方面，使用XtraDB（英语：XtraDB）来代替MySQL的InnoDB。 MariaDB由MySQL的创始人Michael Widenius（英语：Michael Widenius）主导开发，他早前曾以10亿美元的价格，将自己创建的公司MySQL AB卖给了SUN，此后，随着SUN被甲骨文收购，MySQL的所有权也落入Oracle的手中。MariaDB名称来自Michael Widenius的女儿Maria的名字。 MariaDB基于事务的Maria存储引擎，替换了MySQL的MyISAM存储引擎，它使用了Percona的 XtraDB，InnoDB的变体，分支的开发者希望提供访问即将到来的MySQL 5.4 InnoDB性能。这个版本还包括了 PrimeBase XT (PBXT) 和 FederatedX存储引擎。 Spider是MariaDB内置的一个可插拔用于MariaDB/MySQL数据库分片的存储引擎，充当应用服务器和远程后端DB之间的代理（中间件），它可以轻松实现MySQL的横向和纵向扩展，突破单台MySQL的限制，支持范围分区、列表分区、哈希分区，支持XA分布式事务，支持跨库join。通过Spider，您可以跨多个数据库后端有效访问数据，让您的应用程序一行代码不改，即可轻松实现分库分表！ MariaDB Spider：实现MySQL横纵向扩展的小能手: https://www.sohu.com/a/135228509_487514 官网: https://mariadb.com/kb/en/library/spider/ 3.扩容方案如何做？3.1 水平分库扩展的问题水平分库常用的分库策略是采用取模的方式，对userId或业务ID,当业务快速的发展，用户量数据大量上升，当前容量不足以支撑，就需要对数据库进行水平扩容，再增加新库来分解。新库加入之后，原先sharding到3个库的数据，就可以sharding到4个库里面了。 不过此时由于分片规则进行了变化(uid%3 变为uid%4)，大部分的数据，无法命中在原有的数据库上了，需要重新分配，大量数据需要迁移。比如之前uid1通过uid1%3 分配在A库上，新加入库D之后，算法改为uid1%4 了，此时有可能就分配在B库上面了。如果你了解过一致性哈希的原理，就会发现新增一个节点，大概会有90%的数据需要迁移，这个对DB同学的压力还是蛮大的，那么如何应对？ 3.2 方案一：停服迁移停服迁移是最常见的一种方案了，一般如下流程:1.预估停服时间，发布停服公告。2.停服，通过事先做好的数据迁移工具，按照新的分片规则，进行迁移。3.修改分片规则。4.启动服务。 缺点： 1.停服，伤害用户体验，同时也降低了服务器的可用性 2.必须在制定时间内完成迁移，如果失败，需要择日再次进行。同时增加了开发人员的压力，容易发生大的事故 3.数据量的巨大的时候，迁移需要大量时间 3.3 方案二：升级从库线上数据库，我们为了保持其高可用，一般都会每台主库配一台从库，读写在主库，然后主从同步到从库。 升级从库方案步骤： 1.修改分片配置，做好新库和老库的映射。 2.同步配置，从库升级为主库 3.解除主从关系 4.冗余数据清理 5.为新的数据节点搭建新的从库 示意图如下: 3.4 方案三：双写迁移原理和上述相同，做分裂扩容，只是数据的同步方式不同了 双写迁移方案步骤： 1.增加新库写链接 双写的核心原理，就是对需要扩容的数据库上，增加新库，并对现有的分片上增加写链接，同时写两份数据。因为新库的数据为空，所以数据的CRUD对其没有影响，在上层的逻辑层，还是以老库的数据为主。 2.新老库数据迁移 通过工具，把老库的数据迁移到新库里面，此时可以选择同步分裂后的数据（1/2）来同步，也可以全同步，一般建议全同步，最终做数据校检的时候好处理。 3.数据校检 按照理想环境情况下，数据迁移之后，因为是双写操作，所以两边的数据是一致的，特别是insert和update，一致性情况很高。但真实环境中会有网络延迟等情况，对于delete情况并不是很理想，此时就需要做好数据校检了，数据校检可以多做几遍，直到数据几乎一致，尽量以旧库的数据为准。 4.分片配置修改 数据同步完毕，就可以把新库的分片映射重新处理了，还是按照老库分裂的方式来进行，u之前uid%2=0,变为uid%4=0和uid%4=2的。uid%2=1，变为uid%4=1和uid%4=3的。 示意图如下： 4.参考资料分库分表？选型和流程要慎重，否则会失控：https://juejin.im/post/5bf778ef5188251b8a26ed8b MySQL分库分表方案: https://www.cnblogs.com/sunny3096/p/8595058.html 分布式数据中间件TDDL、Amoeba、Cobar、MyCAT架构比较: https://blog.csdn.net/kobejayandy/article/details/60869530 假如让你来设计数据库中间件: https://mp.weixin.qq.com/s/6kuVgdO7RBs9gs229wG3wA 数据库中间件Atlas调研笔记: https://mp.weixin.qq.com/s/31WOensXaLdaAp9WRMW7PA 数据库中间件TDDL调研笔记: https://mp.weixin.qq.com/s/dVGSvUR9UCA-dIYVtr_G_w 数据库中间件cobar调研笔记: https://mp.weixin.qq.com/s/nfTKSTpCvNcvNFAdl2J7mQ mysql-proxy数据库中间件架构: https://mp.weixin.qq.com/s/Ozqu2A7Sy_TGKkF6yF1rDQ 水平分库如何做到平滑扩展： https://mp.weixin.qq.com/s/mOh_PCVW68JCVSd19CGZ0A mysql中间件研究(Atlas,Cobar,TDDL): https://www.guokr.com/blog/475765/ mycat分布式mysql中间件（mysql中间件研究): http://songwie.com/articlelist/44]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongoDB架构与集群]]></title>
    <url>%2F2018%2F11%2F30%2F2018-11-30-mongoDB%E6%9E%B6%E6%9E%84%E4%B8%8E%E9%9B%86%E7%BE%A4%2F</url>
    <content type="text"><![CDATA[1.mongoDB-集群架构1.单机部署、2.复本集（主备）部署、3.分片部署、4.复本集与分片混合部署。 1.Replica set：复制集，mongodb的架构方式之一 ，通常是三个对等的节点构成一个“复制集”集群，有“primary”和secondary等多中角色（稍后详细介绍），其中primary负责读写请求，secondary可以负责读请求，这有配置决定，其中secondary紧跟primary并应用write操作；如果primay失效，则集群进行“多数派”选举，选举出新的primary，即failover机制，即HA架构。复制集解决了单点故障问题，也是mongodb垂直扩展的最小部署单位，当然sharding cluster中每个shard节点也可以使用Replica set提高数据可用性。 2.Sharding cluster：分片集群，数据水平扩展的手段之一；replica set这种架构的缺点就是“集群数据容量”受限于单个节点的磁盘大小，如果数据量不断增加，对它进行扩容将时非常苦难的事情，所以我们需要采用Sharding模式来解决这个问题。将整个collection的数据将根据sharding key被sharding到多个mongod节点上，即每个节点持有collection的一部分数据，这个集群持有全部数据，原则上sharding可以支撑数TB的数据。 2.深入剖析MongoDB架构2.1 MongoDB数据文件内部结构MongoDB在数据存储上按命名空间来划分，一个Collection是一个命名空间，一个索引也是一个命名空间。同一个命名空间的数据被分成很多个Extent，Extent之间使用双向链表连接。在每一个Extent中，保存了具体每一行的数据，这些数据也是通过双向链接来连接的。每一行数据存储空间不仅包括数据占用空间，还可能包含一部分附加空间，这使得在数据Update变大后可以不移动位置。索引以BTree结构实现。 2.2 在MongoDB中实现事务众所周知， MongoDB只支持对单行记录的原子性修改，并不支持对多行数据的原子操作。但是通过上图中的不可思议的操作步骤，实际上你也可以自己实现该事务。 其步骤如下： 第1步：先记录一条事务记录，将要修改的多行记录的修改值写到里面，并设置其状态为init（如果这时候操作中断，那么在重新启动时，会判断到它处于init状态，从而将其保存的多行修改操作应用到具体的行上）。第2步：然后更新具体要修改的行，将刚才写的事务记录的标识写到它的tran字段中。第3步：将事务记录的状态从 init变成pending（如果在这时候操作中断，那么在重新启动时，会判断到它的状态是pending，这时查看其所有对应的多条要修改的记录，如果 其tran值不为空，那么就进行第4步；如果值为空，说明第4步已经执行过了，直接将其状态从pending变成 commited就行）。第4步：将需要修改的多条记录的相应值加以修改，并且unset掉之前的tran字段。第5步：将事务记录那一条的状态从pending变成commited，事务至此完成。其实上面的步骤并不罕见，在支持事务的DBMS中，其事务原子性提交的保证大多都与上面类似。而事务记录的tran那条记录，就类似于这些DBMS中的redolog。 2.3 MongoDB数据同步本流程可简要描述如下： 红色箭头表示写操作可以写到Primary上，然后异步同步到多个Secondary上。蓝色箭头表示读操作可以从Primary或Secondary任意一个中读取。各个Primary与Secondary之间一直保持心跳同步检测，用于判断Replica Sets的状态。 2.4 分片机制MongoDB的分片是指定一个分片key来进行，数据按范围分成不同的chunk，每个chunk的大小有限制。有多个分片节点保存这些chunk，每个节点保存一部分的chunk。每一个分片节点都是一个Replica Sets，这样保证数据的安全性。当一个chunk超过其限制的最大体积时，会分裂成两个小的chunk。当chunk在分片节点中分布不均衡时，会引发chunk迁移操作。 2.5 服务器角色前面讲了分片的机制，下面是具体在分片时几种节点的角色： 客户端访问路由节点mongos来进行数据读写。config服务器保存了两个映射关系，一个是key值的区间对应哪一个chunk的映射关系，另一个是chunk存在哪一个分片节点的映射关系。路由节点通过config服务器获取数据信息，通过这些信息，找到真正存放数据的分片节点进行对应操作。路由节点还会在写操作时判断当前chunk是否超出限定大小。如果超出，就分列成两个chunk。对于按分片key进行的查询和update操作来说，路由节点会查到具体的chunk然后再进行相关的工作。对于不按分片key进行的查询和update操作来说，mongos会对所有下属节点发送请求然后再对返回结果进行合并。 3.参考资料参考：https://blog.csdn.net/zhaowen25/article/details/41871383 参考：http://www.open-open.com/lib/view/open1348919251822.html]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>mongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NoSQL方案选型]]></title>
    <url>%2F2018%2F11%2F30%2F2018-11-30-NoSQL%E6%96%B9%E6%A1%88%E9%80%89%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[1.关系型数据库缺点1.1.大数据场景下 I/O 较高因为数据是按 行存储，即使只针对其中 某一列 进行运算，关系型数据库也会对 整行数据 进行扫描，从存储设备中 读入内存，导致 I/O 较高 1.2.结构化存储 不够灵活存储的是 行记录，无法存储 灵活的数据结构 1.3.表结构 schema 扩展不方便如要需要修改 表结构，需要执行执行 DDL（data definition language）语句修改，修改期间会导致 锁表，部分服务不可用 1.4.全文搜索 功能较弱关系型数据库只能够进行 子字符串 的 匹配查询，当表的数据逐渐变大的时候，即使在有 索引 的情况下，like 扫表查询的匹配会 非常慢 1.5.难以 存储 和 处理 复杂 关系型数据传统的关系数据库，并不擅长处理 数据点之间 的关系 NoSQL 在许多方面性能大大优于 非关系型 数据库的同时，往往也伴随一些特性的缺失。比较常见的是 事务功能 的缺失。 针对传统 关系型数据库 的不足，下面介绍常见的 5 大类 NoSQL 解决方案： 2.NoSQL方案类型2.1 列式数据库列式数据库 是以 列相关存储架构 进行数据存储的数据库，主要适合于 批量数据处理 和 即时查询。相对应的是 行式数据库，数据以 行相关的存储架构 进行空间分配，主要适合于 小批量 的 数据处理，常用于 联机事务型数据处理。 基于列式数据库的 列存储特性，可以解决某些特定场景下 关系型数据库 高 I/O 的问题。 HBase 运行于 HDFS 文件系统之上，为 Hadoop 提供类似于 BigTable 规模的服务。因此，它可以 容错地 存储 海量稀疏 的数据 BigTable 基于 Google 文件系统（Google File System，GFS）的数据存储系统，用于存储 大规模结构化数据，适用于云计算 优点： 1.高效的储存空间利用率 2.查询效率高 3.适合做聚合操作 4.适合大量的数据而不是小数据 缺点： 1.不适合扫描 小量数据 2.不适合 随机的更新 3.不适合做含有删除和更新的 实时操作 4.单行数据 支持 ACID 的 事务操作，多行数据 的 事务操作，不支持事务的 正常回滚，支持 （Isolation）隔离性、(Durability）持久性，不能保证 (Atomicity）原子性、（Consistency）一致性 2.2 K-V数据库使用 键值（key-value）存储的数据库，其数据按照 键值对 的形式进行 组织、索引 和 存储。 KV 存储非常适合不涉及过多 数据关系 业务的数据。它能够有效减少 读写磁盘 的次数，比 SQL 数据库存储 拥有更好的 读写性能，能够解决 关系型数据库 无法存储 数据结构 的问题。 Redis Redis 是一个使用 ANSI C 编写的 开源、支持网络、基于内存、可选持久性 的 键值对存储 数据库。Redis 是目前最流行的 键值对存储 数据库之一 Cassandra Apache Cassandra（社区内一般简称为 C*）是一套 开源的分布式 NoSQL 数据库系统。它最初由 Facebook 开发，用于储存 收件箱 等简单格式数据，集 Google BigTable 的 数据模型 与 Amazon Dynamo 的 完全分布式 架构于一身。Cassandra 是一种流行的 分布式结构化 数据存储方案 Memcached Memcached 是一个 开放源代码、高性能、分配的 内存对象缓存系统。用于加速动态 web 应用程序，减轻关系型数据库负载。它可以应对 任意多个连接，使用 非阻塞的网络 IO。由于它的工作机制是在内存中开辟一块空间，然后建立一个 Hash 表，Memcached 自管理这些 Hash 表。 LevelDB LevelDB 是一个由 Google 所研发的 键／值对（Key/Value Pair）嵌入式 数据库管理系统 编程库，以开源的 BSD 许可证发布。 **优点： 1.性能极高 2.丰富的数据类型 3.丰富的特性 **缺点： 事务 不能支持 原子性 和 持久性（A 和 D），只支持 隔离性 和 一致性（I 和 C）。 2.3 文档型数据库文档数据库 用于将 半结构化数据 存储为 文档 的一种数据库。文档数据库通常以 JSON 或 XML 格式存储数据。 由于文档数据库的 no-schema 特性，可以 存储 和 读取 任意数据。 MongoDB MongoDB 是一个基于 分布式文件存储 的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的 高性能 数据存储解决方案。MongoDB 是一个介于 关系数据库 和 非关系数据库 之间的产品，是非关系数据库当中功能 最丰富，最像关系数据库的 NoSQL。 CouchDB CouchDB 是用 Erlang 开发的 面向文档 的 分布式 数据库，用于存储 半结构化 的数据，比较类似 lucene 的 index 结构。CouchDB 支持 RESTful API，它使用 JSON 作为 存储格式，JavaScript 作为 查询语言，MapReduce 和 HTTP 作为 API 的 NoSQL 数据库。其中一个显著的功能就是 多主复制 功能。除此之外，CouchDB 构建在强大的 B- 树储存引擎 之上。 **优点： 1.新增字段简单不需要像关系型数据库一样，先执行 DDL 语句 修改表结构，程序代码 直接读写 即可。 2.容易兼容 历史数据。对于历史数据，即使没有新增的字段，也不会导致错误，只会返回 空值，此时 代码兼容处理 即可。 3.容易存储复杂数据。JSON 是一种强大的 描述语言，能够描述复杂的 数据结构 **缺点： 1.Atomicity（原子性）：仅支持 单行/文档级原子性，不支持 多行、多文档、多语句原子性。 2.Isolation（隔离性）：隔离级别仅支持 已提交读（Read committed）级别，可能导致 不可重复读，幻读 的问题。 3.不支持 复杂查询。例如 join 查询，如果需要 join 查询，需要 多次操作数据库。 2.4 全文搜索引擎全文搜索引擎 的技术原理称为 倒排索引（inverted index），是一种 索引方法，其基本原理是建立 单词 到 文档 的索引。与之相对是，是 正排索引，其基本原理是建立 文档 到 单词 的索引。 全文搜索引擎的出现，正是解决关系型数据库 全文搜索较弱 的问题。 ElasticSearch ElasticSearch 是一个基于 Apache Lucene 的 搜索引擎。它提供了一个 分布式，多租户 对全文搜索引擎。ElasticSearch 是用 Java 开发的，对外提供 RESTful Web 接口。根据 DB-Engines 排名，ElasticSearch 是最受欢迎的 企业搜索引擎。 Solr Solr 是 Apache Lucene 项目的 开源企业搜索平台。其主要功能包括 全文检索、命中标示、分面搜索、动态聚类、数据库集成，以及 富文本（比如 Word、PDF）处理等等。Solr 是高度 可扩展 的，并提供了 分布式搜索 和 索引复制 **优点： 1.查询效率高，适用于对 海量数据 进行 近实时 的处理。 2.可扩展性 3.基于 集群 环境可以方便 横向扩展，可以承载 PB 级的数据。 4.支持 高可用，ElasticSearch 集群弹性灵活，可以发现新的或失败的节点，重组 和 重新平衡 数据，确保数据是 安全 和 可访问的 **缺点： 1.事务的 ACID 支持不足，单一文档 的数据是支持 ACID 的。对于 多个文档 的 事务操作，不支持事务的 正常回滚。支持（Isolation）隔离性（基于 乐观锁机制）和（Durability）持久性，不支持（Atomicity）原子性，（Consistency）一致性。 2.对类似数据库中，通过 外键 进行 多表关联的复杂操作支持较弱。 3.读写 有一定 延时，写入的数据，最快 1s 中能被检索到。 4.更新 性能较低，底层实现是 先删数据，再 插入新数据。 5.内存占用大，因为 Lucene 将 索引部分 加载到 内存 中。 2.5 图形数据库图形数据库 应用 图形理论 存储 实体 之间的 关系信息。最常见例子就是 社会网络中人与人之间的关系。关系型数据库 用于存储这种 关系型数据 的效果并不好，其查询 复杂、缓慢、超出预期。 图形数据库 的独特设计弥补了这个缺陷，解决 关系型 数据库 存储 和 处理复杂关系型数据 功能较弱的问题。 Neo4j Neo4j 是一个 高性能的，NOSQL 图形数据库，它将 结构化数据 存储在 “图形网络上” 而不是 “表中”。它是一个 嵌入式的、基于磁盘的、具备完全的 事务特性 的 Java 持久化引擎。Neo4j 也可以被看作是一个 高性能的图引擎。程序员工作在一个 面向对象的、灵活的网络结构 下而不是 严格、静态 的 表中。 ArangoDB ArangoDB 是一个 原生多模型 数据库系统。数据库系统支持 三个 重要的 数据模型（键/值，文档，图形）。ArangoDB 包含一个 数据库核心 和 统一查询语言 AQL（ArangoDB 查询语言）。查询语言是 声明性的，允许在 单个查询 中 组合 不同的 数据访问模式。ArangoDB 是一个 NoSQL 数据库系统，但 AQL 在很多方面与 SQL 都类似。 **优点： 1.高性能表现 2.设计的灵活性 3.开发的敏捷性 4.完全支持ACID **缺点： 1.节点，关系 和它们的 属性 的数量被 限制。 不支持 拆分。 3.关系数据库 or NoSQL关于 关系型数据库 和 NoSQL 数据库 的选型，往往需要考虑几个指标：数据量、并发量、实时性、一致性要求、读写分布、数据类型、安全性、运维成本。 系统类型 数据库选型 企业内部管理系统 例如运营系统，数据量少，并发量小，首选考虑 关系型数据库 互联网大流量系统 例如电商单品页，后台考虑选 关系型数据库，前台考虑选 内存型数据库 日志型系统 原始数据 考虑选 列式数据库，日志搜索 考虑选 倒排索引 搜索型系统 例如站内搜索，非通用搜索，商品搜索，后台考虑选 关系型数据库，前台考虑选 倒排索引 事务型系统 例如库存管理，交易，记账，考虑选 关系型数据库 + 缓存数据库 + 一致性型协议 离线计算 例如大量数据分析，考虑选 列式数据库 或者 关系型数据库 都可以 实时计算 例如实时监控，可以考虑选 内存型数据库 或者 列式数据库 4.参考资料参考：https://blog.csdn.net/baidu_22254181/article/details/82594116]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongoDB文档模式设计]]></title>
    <url>%2F2018%2F11%2F29%2F2018-11-29-mongoDB%E6%96%87%E6%A1%A3%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[1. mongoDB安装官方手册：https://docs.mongodb.com/manual/tutorial/ 安装指南:https://docs.mongodb.com/manual/tutorial/install-mongodb-enterprise-on-red-hat/ mongoDB可视化工具:https://studio3t.com/ 远程链接需要注意： mongodb的配置文件中的bind_ip 默认为127.0.0.1，默认只有本机可以连接。 此时，需要将bind_ip配置为0.0.0.0，表示接受任何IP的连接。修改mongod配置文件: /etc/mongod.conf 参考文档： MongoDB 进阶模式设计:https://mp.weixin.qq.com/s/IL3L1OI9SUYN1gNaaVDVHA 2.关系模型和文档模型的区别在哪里？关系模型的功能：单值，多文档事物性，关联。 文档模型的功能：富文档、数组、内嵌，单文档事务性，基本不支持关联 两者的相同功能：动态查询，二级索引，聚合。 2.1 文档模型的优点读写效率高 -由于文档模型把相关数据集中在一块，在普通机械盘上读数据的时候不用花太多时间去定位磁头，因此在IO性能上有先天独厚的优势； 可扩展能力强 -关系型数据库很难做分布式的原因就是多节点海量数据关联有巨大的性能问题。如果不考虑关联，数据分区分库，水平扩展就比较简单； 动态模式 -文档模型支持可变的数据模式，不要求每个文档都具有完全相同的结构。对很多异构数据场景支持非常好； 模型自然 -文档模型最接近于我们熟悉的对象模型。从内存到存储，无需经过ORM的双向转换，性能上和理解上都很自然易懂。 3.MongoDB文档模式设计的基本策略文档模式设计有2中基本策略：1.内嵌。2.引用 3.1 内嵌策略如果你的对象模型数量不多，关系不是很复杂，可以使用内嵌策略。内嵌是文档模型的特色，可以充分利用MongoDB的富文档功能来享受我们刚才谈到的一些文档模型的性能和扩展性等特性。一般的一对一、一对多关系，比如说一个人多个地址多个电话等等都可以放在一个文档里用内嵌来完成。 单个文档(BSON格式)大小限制为16M。这是一个坑。 这个’坑’ 可能会让你花时间都难以发现, 因为这又要牵扯到mongodb的另一个存储机制 —- 无返回码. 在 &lt; mongodb 权威指南&gt; 一书中, 作者称之为离弦之箭. 什么意思呢？就是mongodb的插入,删除等操作, 客户端向数据库发出请求之后, 是不需要等待数据库返回操作是否成功的返回结果. 这也是mongodb插入,更新等操作速度快的原因. 这就导致, 当单个文件超过16M之后, 程序并不会报错。 GridFS是用于存储和检索超过 BSON文档大小限制为16 MB的文件的规范。GridFS不是将文件存储在单个文档中，而是将文件分成多个部分或块，并将每个块存储为单独的文档。 如果需要以原子方式更新整个文件的内容，请不要使用GridFS。作为替代方案，您可以存储每个文件的多个版本，并在元数据中指定文件的当前版本。您可以在上载新版本的文件后更新在原子更新中指示“最新”状态的元数据字段，并在以后删除以前版本。 3.2 引用策略在主表里存储一个id值，指向另一个表中的 id 值。使用引用要注意的就是：从性能上讲，一般我们可能需要两次以上才能把需要的数据取回来。更加重要的是：需要把数据存放到两个集合里，但是目前为止MongoDB并不支持跨表的事务性，所以对于强事务的应用场景要谨慎使用。 3.3 何时选择不同的策略先考虑内嵌，内嵌适合一对一，一对多。局限性在于文档最大16M限制，大数组性能欠佳。 后考虑引用，引用适合多对多，两个对象都为主要对象。局限性在于多次查询、写入，无跨表事务性。 4.MongoDB模式设计的终极原则MongoDB的模式设计和关系型大不相同，我们说MongoDB是为应用程序设计的，而不是为了存储优化的。如果可以达到最高性能的话，我们甚至可以做一些反范式的东西。 4.1 数据冗余&amp;扇出写社交app最关键的一些场景就是维护朋友关系以及朋友圈或微博墙等。使用文档模型的内嵌数组特性，我们可以很容易地把我关注的用户（following）和关注我的用户表示出来。 但是有一个潜在问题就是如果我是一个明星，他们关注我的人可能有千万。一个千万级的数组会有两个问题： 1） 有可能超出一个文档最大16M的硬性限制； 2） MongoDB数组太大会严重影响性能。 扇出读是一种比较常规的做法，就是当你需要去获得所有你关注用户的最新更新的时候，你就去到每一个你关注用户的数据区，把最新的一些数据取回来。因为需要去到不同的分片服务器去取，所以叫做扇出读。大家可以想象，这种扇出读的效率不会太高，基本上是最慢的那个服务器的响应时间决定了总体的响应时间。 当然，这种方式是比较简单的，不需要特殊处理。 扇出写的具体做法，当发布的时候，一条数据会写多次，直接写到每一个关注你的粉丝的墙上。这样做的好处是当你的粉丝读他自己的微博墙的时候，他只需要去一个地方就可以把所有最新的更新连续取回来。由于一个用户的数据可一般可以存储在同一台服务器上的同一个区域，通过这种方式可以实现快速的读取微博墙数据。 代价当然也是很明显： 你的写入需求会被放大几十几百倍，存储也是相应的扩大几十几百倍。这个绝对不是关系型数据库的玩法，但是在MongoD 模式设计，这个很正常。只要保证性能，什么事情都做得出来。 4.2 分桶在IOT这个场景里，我们可以使用一个叫做分桶的设计方式来进行几十倍的性能增长。具体来说就是把采集的数据按小时为一个桶，把每小时的数据聚合到一个文档里。这样做的好处就是大量减少文档的数量，相应的索引数量也会减少，总体写入IO将会大幅度降低并得到性能提升。 存储引擎： mongodb 3.0默认存储引擎为MMAPV1，mongodb 3.2+之后，默认的存储引擎为“wiredTiger”，大量优化了存储性能，建议升级到3.2+版本。]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>mongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RocketMQ-docker搭建]]></title>
    <url>%2F2018%2F11%2F26%2F2018-11-26-RocketMQ-docker%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[0.基础准备在Docker中搭建RocketMQ集群环境。 jdk1.8下载地址： https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html maven 下载地址: http://archive.apache.org/dist/maven/maven-3/3.5.2/binaries/apache-maven-3.5.2-bin.tar.gz rocketmq-4.3.2下载地址： https://github.com/apache/rocketmq/archive/rocketmq-all-4.3.2.tar.gz rocketmq-console下载: https://github.com/apache/rocketmq-externals/archive/rocketmq-console-1.0.0.zip 配置maven镜像仓库地址: 12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt;&lt;/mirrors&gt; 参考资料(rocketmq集群介绍)： https://blog.csdn.net/leexide/article/details/80035470 https://roc-wong.github.io/blog/2018/11/RocketMQ-at-a-glance.html 关闭防火墙: 1# systemctl stop firewalld 1.RocketMQ 集群环境搭建1.1 RocketMQ编译java,maven环境变量首先配置正确。 然后更改本地maven的镜像仓库地址,最后进入到RocketMQ的源代码文件夹中,执行编译 1# mvn -Prelease-all -DskipTests clean install -U 执行完后，将 rocketmq-rocketmq-all-4.3.2/distribution/target 目录下的 apache-rocketmq 文件夹 copy 到 /opt 或应用存放的目录中。 1.2 更改默认的JVM配置修改namesrv的配置： 1234# vim bin/runserver.sh...JAVA_OPT="$&#123;JAVA_OPT&#125; -server -Xms4g -Xmx4g -Xmn2g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m"... 修改broker的配置： 1234# vim /bin/runbroker.sh...JAVA_OPT="$&#123;JAVA_OPT&#125; -server -Xms8g -Xmx8g -Xmn4g"... 1.3 broker配置修改broker的配置文件在 config/broker.conf中，其中 config/2m-2s-async 为多Master多Slave模式(异步复制)集群配置，config/2m-2s-sync为多Master多Slave模式(同步双写)集群配置，config/2m-noslave 为多Master集群。每种集群模式的优缺点见参考资料。 每种配置的关键配置项，如下： 12345678910111213141516#集群名称(相同名称的brokerName,根据brokerId来区别主从)brokerName=broker-a|broker-b#0表示Master,&gt;0表示SlavebrokerId=0#Broker在集群的角色(和borkerId对应)#- ASYNC_MASTER 异步复制Master#- SYNC_MASTER 同步双写Master#- SLAVEbrokerRole=ASYNC_MASTER#刷盘方式(2m-2s-async与2m-2s-sync的区别点就是这个配置)#- ASYNC_FLUSH 异步刷盘#- SYNC_FLUSH 同步刷盘flushDiskType=ASYNC_FLUSH 以上内容修改完毕后，还需要添加以下配置: 12345678# Broker的IP地址brokerIP1 = xxxxxx# NameServer地址列表，多个nameServer地址用分号隔开namesrvAddr = 10.29.183.66:9876;10.29.183.81:9876;10.29.183.82:9876;10.29.183.83:9876# 是否自动创建Topic,若关闭，客户端在使用一个未事先创建好的Topic会报错，打开改配置则会自动创建autoCreateTopicEnable = true 1.4 启动namesrv,broker启动namesrv： 1# nohup sh bin/mqnamesrv &gt; /dev/null 2&gt;&amp;1 &amp; 查看日志: 1# tail -f ~/logs/rocketmqlogs/namesrv.log 启动broker: 方式一：手动指定namesrv地址:1# nohup sh bin/mqbroker -n localhost:9876 &gt; /dev/null 2&gt;&amp;1 &amp; 方式二:指定配置文件(推荐):1# nohup sh bin/mqbroker -c conf/broker.conf &gt; /dev/null 2&gt;&amp;1 &amp; 查看日志： 1# tail -f ~/logs/rocketmqlogs/broker.log 1.5 停止namesrv,broker123# sh bin/mqshutdown namesrv# sh bin/mqshutdown broker 1.6 测试Producer,Consumer首先设置namesrv的地址 1# export NAMESRV_ADDR=localhost:9876 测试发送消息: 1sh bin/tools.sh org.apache.rocketmq.example.quickstart.Producer 测试接受消息:1sh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer 1.7 mqadmin功能一览123456789101112131415161718192021222324252627282930313233343536373839404142434445# sh bin/mqadminupdateTopic Update or create topicdeleteTopic Delete topic from broker and NameServer.updateSubGroup Update or create subscription groupdeleteSubGroup Delete subscription group from broker.updateBrokerConfig Update broker&apos;s configupdateTopicPerm Update topic permtopicRoute Examine topic route infotopicStatus Examine topic Status infotopicClusterList get cluster info for topicbrokerStatus Fetch broker runtime status dataqueryMsgById Query Message by IdqueryMsgByKey Query Message by KeyqueryMsgByUniqueKey Query Message by Unique keyqueryMsgByOffset Query Message by offsetprintMsg Print Message DetailprintMsgByQueue Print Message DetailsendMsgStatus send msg to broker.brokerConsumeStats Fetch broker consume stats dataproducerConnection Query producer&apos;s socket connection and client versionconsumerConnection Query consumer&apos;s socket connection, client version and subscriptionconsumerProgress Query consumers&apos;s progress, speedconsumerStatus Query consumer&apos;s internal data structurecloneGroupOffset clone offset from other group.clusterList List all of clusterstopicList Fetch all topic list from name serverupdateKvConfig Create or update KV config.deleteKvConfig Delete KV config.wipeWritePerm Wipe write perm of broker in all name serverresetOffsetByTime Reset consumer offset by timestamp(without client restart).updateOrderConf Create or update or delete order confcleanExpiredCQ Clean expired ConsumeQueue on broker.cleanUnusedTopic Clean unused topic on broker.startMonitoring Start MonitoringstatsAll Topic and Consumer tps statsallocateMQ Allocate MQcheckMsgSendRT check message send response timeclusterRT List All clusters Message Send RTgetNamesrvConfig Get configs of name server.updateNamesrvConfig Update configs of name server.getBrokerConfig Get broker config by cluster or special broker!queryCq Query cq command.sendMessage Send a messageconsumeMessage Consume message 1.8 broker.conf主要配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#===================主要配置===============#所属集群名字brokerClusterName=rocketmq-cluster#broker名字，注意此处不同的配置文件填写的不一样brokerName=broker-a|broker-b#0表示Master，&gt;0表示SlavebrokerId=0#nameServer地址，分号分割namesrvAddr=192.168.1.101:9876;192.168.1.102:9876#限制的消息大小maxMessageSize=65536#flushCommitLogLeastPages=4#flushConsumeQueueLeastPages=2#flushCommitLogThoroughInterval=10000#flushConsumeQueueThoroughInterval=60000#Broker 的角色#- ASYNC_MASTER 异步复制Master#- SYNC_MASTER 同步双写Master#- SLAVEbrokerRole=ASYNC_MASTER#刷盘方式#- ASYNC_FLUSH 异步刷盘#- SYNC_FLUSH 同步刷盘flushDiskType=ASYNC_FLUSH#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数defaultTopicQueueNums=4#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭autoCreateTopicEnable=true#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭autoCreateSubscriptionGroup=true#Broker 对外服务的监听端口listenPort=10911#============持久化配置=================#删除文件时间点，默认凌晨 4点deleteWhen=04#文件保留时间，默认 48 小时fileReservedTime=120#commitLog每个文件的大小默认1GmapedFileSizeCommitLog=1073741824#ConsumeQueue每个文件默认存30W条，根据业务情况调整mapedFileSizeConsumeQueue=300000#destroyMapedFileIntervalForcibly=120000#redeleteHangedFileInterval=120000#检测物理文件磁盘空间diskMaxUsedSpaceRatio=88#存储路径storePathRootDir=/data/rocketmq/store#commitLog 存储路径storePathCommitLog=/data/rocketmq/store/commitlog#消费队列存储路径存储路径storePathConsumeQueue=/data/rocketmq/store/consumequeue#消息索引存储路径storePathIndex=/data/rocketmq/store/index#checkpoint 文件存储路径storeCheckpoint=/data/rocketmq/store/checkpoint#abort 文件存储路径abortFile=/data/rocketmq/store/abort#===================线程池配置====================checkTransactionMessageEnable=false#发消息线程池数量sendMessageThreadPoolNums=128#拉消息线程池数量pullMessageThreadPoolNums=128 2.Docker使用指南2.1 docker常用命令123456789# yum install -y docker //安装docker# service docker start //启动docker# service docker status //查看docker服务状态# service docker stop //停止docker服务# systemctl reload docker //刷新docker配置 123456789# docker ps -a //检查docker运行状态# docker start rocketmq //启动容器# docker stop rocketmq //停止容器# docker rm 容器ID/Name //删除容器# docker rm `docker ps -a -q` //删除所有容器 12345# docker images //查看本地镜像列表# docker rmi 镜像名称 //删除镜像# docker rmi $(docker images -q) //删除所有镜像 2.2 编辑docker仓库地址编辑仓库地址: vim /etc/docker/daemon.json 1234&#123;"registry-mirrors": ["https://registry.docker-cn.com"],"insecure-registries":["10.25.24.161:5000","10.29.139.47:5000","10.29.139.47:5001"]&#125; 参数详细说明：https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-user-namespace-options 2.3 获取基础镜像1# docker pull 10.29.139.47:5001/base/java 从docker hub上获取centos基础镜像 1# docker pull centos:latest 2.4 docker run 启动容器启动容器 1# docker run ... –name:容器实例名称 –privileged:使用该参数，container内的root拥有真正的root权限。 -td：后台运行容器（–tty，–detach） -it 创建一个交互式的容器 -p 映射端口(本机的端口：映射的容器的端口) -v 挂载目录/root/software:/software(本地目录：容器目录)，在创建前容器是没有software目录的，docker 容器会自己创建 –privileged=true 关闭安全权限，否则你容器操作文件夹没有权限 资源限制： –ulimit memlock=-1：容器使用内存不受限制 1234567docker容器资源限制默认：–default-ulimit nofile=131072 –default-ulimit memlock=128849018880 –default-ulimit core=-1 –default-ulimit nproc=-1 –default-ulimit stack=-1 网络设置： –net：网络指定 12345678910111213docker容器网络选择：1. host模式： docker run 使用 --net=host指定docker使用的网络实际上和宿主机一样2. container模式：使用 --net=container:container_id/container_name多个容器使用共同的网络，看到的ip是一样的。3. none 模式: 使用 --net=none指定这种模式下，不会配置任何网络。4. bridge模式: 使用 --net=bridge指定默认模式，不会指定。此模式会为每个容器分配一个独立的network namespace 使用示例: 启动镜像，指定端口映射: 1# docker run --name rocketmq-tmp -p 98761:98761 --privileged --ulimit memlock=-1 --net=host -td rockemq-base1 /usr/sbin/init 启动一个镜像，映射目录:1# docker run -it -p 8070:8080 -v /root/software:/software --privileged=true docker.io/centos /bin/bash 2.5 docker exec 进入容器方式一：exec 1# docker exec -it kungfu-devel bash 方式二：attach 注意：如果从这个stdin中exit，会导致容器的停止。 123# docker attach cd24b1147c40# docker attach mycentos 2.6 docker commit 保存镜像保存镜像：1docker commit afcaf46e8305 rocketmq-cluster 查看镜像的详细信息： 1docker inspect centos-vim:afcaf46e8305 2.6 docker push 推送镜像到远端标记与推送：123# docker tag docker.io/centos 10.29.139.47:5001/jiagou_registry/centos7# docker push 10.29.139.47:5001/jiagou_registry/centos7 需要先登录: 123# docker login -u你的docker账号 -p你的docker密Login Succeeded 2.7 docker build 从dockerfile构建镜像1# docker build -t image_name -f ./Dockerfile . 3.使用Docker搭建RocketMQ集群3.1 构建基础镜像 rocketmq:base1.拉取基础镜像 docker pull centos:latest docker tag docker.io/centos 10.29.139.47:5001/jiagou_registry/centos7 docker tag 10.29.139.47:5001/jiagou_registry/centos7 centos7 2.启动容器 docker run –name rocketmq –privileged –ulimit memlock=-1 -v /root/soft:/data/soft –net=host -td centos7 /usr/sbin/init 3.在容器中配置java,maven环境 123JAVA_HOME=/opt/jdk1.8.0_191M2_HOME=/opt/apache-maven-3.5.2ROCKETMQ_HOME=/opt/apache-rocketmq 4.编译rocketmq代码,将编译过后的文件copy到/opt下，最终rocketmq的路径为：/opt/apache-rocketmq 5.在/opt/apache-rocketmq/config/目录下,创建namesrv.conf配置文件 123# vim namesrv.conflistenPort=9877 6.修改.bashrc文件 1234567vim ~/.bashrc.....if [ -f /etc/bashrc ]; then . /etc/bashrcsource /etc/profilefi.... 7.保存镜像 在centos7的容器中，执行exit方法，退出容器 查看刚才容器的id 1# docker ps -a 保存， 1# docker commit d4bd7510bdb2 rocketmq:base 3.2 构建namesrv镜像 rocketmq:namesrv创建目录：/root/dockerfiles/rocketmq-namesrv,进入目录执行， 123456789101112# vim DockerfileFROM rocketmq:baseENV JAVA_HOME=/opt/jdk1.8.0_191ENV M2_HOME=/opt/apache-maven-3.5.2ENV ROCKETMQ_HOME=/opt/apache-rocketmqENV PATH=$PATH:$JAVA_HOME/bin:$M2_HOME/binENV CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarCMD cd /opt/apache-rocketmq/ \ &amp;&amp; /opt/apache-rocketmq/bin/mqnamesrv -c /opt/apache-rocketmq/conf/namesrv.conf 在Dockerfile的目录下，执行 1# docker build -t rocketmq:namesrv -f ./Dockerfile . 3.3 构建broker镜像 rocketmq:broker创建目录：/root/dockerfiles/rocketmq-broker,进入目录执行， 123456789101112# vim DockerfileFROM rocketmq:baseENV JAVA_HOME=/opt/jdk1.8.0_191ENV M2_HOME=/opt/apache-maven-3.5.2ENV ROCKETMQ_HOME=/opt/apache-rocketmqENV PATH=$PATH:$JAVA_HOME/bin:$M2_HOME/binENV CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarCMD cd /opt/apache-rocketmq/ \ &amp;&amp; /opt/apache-rocketmq/bin/mqbroker -c /config/broker.conf 在Dockerfile的目录下，执行 1# docker build -t rocketmq:broker -f ./Dockerfile . 3.4 启动namesrv1# docker run -d -p 9877:9877 --name rmqnamesrv rocketmq:namesrv 3.5 启动broker创建以下配置目录： /opt/mqconfig/broker-a-config/broker.conf 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071vim broker.conf#所属集群名字brokerClusterName=rocketmq-cluster#broker名字，注意此处不同的配置文件填写的不一样brokerName=broker-a#0表示Master，&gt;0表示SlavebrokerId=0brokerIP1 = 10.29.183.66#nameServer地址，分号分割namesrvAddr = 10.29.183.66:9877#限制的消息大小maxMessageSize=65536#flushCommitLogLeastPages=4#flushConsumeQueueLeastPages=2#flushCommitLogThoroughInterval=10000#flushConsumeQueueThoroughInterval=60000#Broker 的角色#- ASYNC_MASTER 异步复制Master#- SYNC_MASTER 同步双写Master#- SLAVEbrokerRole=ASYNC_MASTER#刷盘方式#- ASYNC_FLUSH 异步刷盘#- SYNC_FLUSH 同步刷盘flushDiskType=ASYNC_FLUSH#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数defaultTopicQueueNums=4#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭autoCreateTopicEnable=true#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭autoCreateSubscriptionGroup=true#Broker 对外服务的监听端口listenPort=20911============持久化配置=================#删除文件时间点，默认凌晨 4点deleteWhen=04#文件保留时间，默认 48 小时fileReservedTime=120#commitLog每个文件的大小默认1GmapedFileSizeCommitLog=1073741824#ConsumeQueue每个文件默认存30W条，根据业务情况调整mapedFileSizeConsumeQueue=300000#destroyMapedFileIntervalForcibly=120000#redeleteHangedFileInterval=120000#检测物理文件磁盘空间diskMaxUsedSpaceRatio=88#存储路径storePathRootDir=/data/rocketmq/store#commitLog 存储路径storePathCommitLog=/data/rocketmq/store/commitlog#消费队列存储路径存储路径storePathConsumeQueue=/data/rocketmq/store/consumequeue#消息索引存储路径storePathIndex=/data/rocketmq/store/index#checkpoint 文件存储路径storeCheckpoint=/data/rocketmq/store/checkpoint#abort 文件存储路径abortFile=/data/rocketmq/store/abort /opt/mqconfig/broker-a-s-config/broker.conf 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071vim broker.conf#所属集群名字brokerClusterName=rocketmq-cluster#broker名字，注意此处不同的配置文件填写的不一样brokerName=broker-a#0表示Master，&gt;0表示SlavebrokerId=1brokerIP1 = 10.29.183.66#nameServer地址，分号分割namesrvAddr = 10.29.183.66:9877#限制的消息大小maxMessageSize=65536#flushCommitLogLeastPages=4#flushConsumeQueueLeastPages=2#flushCommitLogThoroughInterval=10000#flushConsumeQueueThoroughInterval=60000#Broker 的角色#- ASYNC_MASTER 异步复制Master#- SYNC_MASTER 同步双写Master#- SLAVEbrokerRole= SLAVE#刷盘方式#- ASYNC_FLUSH 异步刷盘#- SYNC_FLUSH 同步刷盘flushDiskType=ASYNC_FLUSH#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数defaultTopicQueueNums=4#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭autoCreateTopicEnable=true#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭autoCreateSubscriptionGroup=true#Broker 对外服务的监听端口listenPort=30911============持久化配置=================#删除文件时间点，默认凌晨 4点deleteWhen=04#文件保留时间，默认 48 小时fileReservedTime=120#commitLog每个文件的大小默认1GmapedFileSizeCommitLog=1073741824#ConsumeQueue每个文件默认存30W条，根据业务情况调整mapedFileSizeConsumeQueue=300000#destroyMapedFileIntervalForcibly=120000#redeleteHangedFileInterval=120000#检测物理文件磁盘空间diskMaxUsedSpaceRatio=88#存储路径storePathRootDir=/data/rocketmq/store#commitLog 存储路径storePathCommitLog=/data/rocketmq/store/commitlog#消费队列存储路径存储路径storePathConsumeQueue=/data/rocketmq/store/consumequeue#消息索引存储路径storePathIndex=/data/rocketmq/store/index#checkpoint 文件存储路径storeCheckpoint=/data/rocketmq/store/checkpoint#abort 文件存储路径abortFile=/data/rocketmq/store/abort /opt/mqconfig/broker-b-config/broker.conf 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071vim broker.conf#所属集群名字brokerClusterName=rocketmq-cluster#broker名字，注意此处不同的配置文件填写的不一样brokerName=broker-b#0表示Master，&gt;0表示SlavebrokerId=0brokerIP1 = 10.29.183.66#nameServer地址，分号分割namesrvAddr = 10.29.183.66:9877#限制的消息大小maxMessageSize=65536#flushCommitLogLeastPages=4#flushConsumeQueueLeastPages=2#flushCommitLogThoroughInterval=10000#flushConsumeQueueThoroughInterval=60000#Broker 的角色#- ASYNC_MASTER 异步复制Master#- SYNC_MASTER 同步双写Master#- SLAVEbrokerRole=ASYNC_MASTER#刷盘方式#- ASYNC_FLUSH 异步刷盘#- SYNC_FLUSH 同步刷盘flushDiskType=ASYNC_FLUSH#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数defaultTopicQueueNums=4#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭autoCreateTopicEnable=true#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭autoCreateSubscriptionGroup=true#Broker 对外服务的监听端口listenPort=40911============持久化配置=================#删除文件时间点，默认凌晨 4点deleteWhen=04#文件保留时间，默认 48 小时fileReservedTime=120#commitLog每个文件的大小默认1GmapedFileSizeCommitLog=1073741824#ConsumeQueue每个文件默认存30W条，根据业务情况调整mapedFileSizeConsumeQueue=300000#destroyMapedFileIntervalForcibly=120000#redeleteHangedFileInterval=120000#检测物理文件磁盘空间diskMaxUsedSpaceRatio=88#存储路径storePathRootDir=/data/rocketmq/store#commitLog 存储路径storePathCommitLog=/data/rocketmq/store/commitlog#消费队列存储路径存储路径storePathConsumeQueue=/data/rocketmq/store/consumequeue#消息索引存储路径storePathIndex=/data/rocketmq/store/index#checkpoint 文件存储路径storeCheckpoint=/data/rocketmq/store/checkpoint#abort 文件存储路径abortFile=/data/rocketmq/store/abort /opt/mqconfig/broker-b-s-config/broker.conf 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071vim broker.conf#所属集群名字brokerClusterName=rocketmq-cluster#broker名字，注意此处不同的配置文件填写的不一样brokerName=broker-b#0表示Master，&gt;0表示SlavebrokerId=1brokerIP1 = 10.29.183.66#nameServer地址，分号分割namesrvAddr = 10.29.183.66:9877#限制的消息大小maxMessageSize=65536#flushCommitLogLeastPages=4#flushConsumeQueueLeastPages=2#flushCommitLogThoroughInterval=10000#flushConsumeQueueThoroughInterval=60000#Broker 的角色#- ASYNC_MASTER 异步复制Master#- SYNC_MASTER 同步双写Master#- SLAVEbrokerRole= SLAVE#刷盘方式#- ASYNC_FLUSH 异步刷盘#- SYNC_FLUSH 同步刷盘flushDiskType=ASYNC_FLUSH#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数defaultTopicQueueNums=4#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭autoCreateTopicEnable=true#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭autoCreateSubscriptionGroup=true#Broker 对外服务的监听端口listenPort=50911============持久化配置=================#删除文件时间点，默认凌晨 4点deleteWhen=04#文件保留时间，默认 48 小时fileReservedTime=120#commitLog每个文件的大小默认1GmapedFileSizeCommitLog=1073741824#ConsumeQueue每个文件默认存30W条，根据业务情况调整mapedFileSizeConsumeQueue=300000#destroyMapedFileIntervalForcibly=120000#redeleteHangedFileInterval=120000#检测物理文件磁盘空间diskMaxUsedSpaceRatio=88#存储路径storePathRootDir=/data/rocketmq/store#commitLog 存储路径storePathCommitLog=/data/rocketmq/store/commitlog#消费队列存储路径存储路径storePathConsumeQueue=/data/rocketmq/store/consumequeue#消息索引存储路径storePathIndex=/data/rocketmq/store/index#checkpoint 文件存储路径storeCheckpoint=/data/rocketmq/store/checkpoint#abort 文件存储路径abortFile=/data/rocketmq/store/abort 启动master-a:1# docker run -d -p 20911:20911 -p 20909:20909 -v=/opt/mqconfig/broker-a-config:/config --name rmqbroker-a rocketmq:broker 启动slave-a:1# docker run -d -p 30911:30911 -p 30909:30909 -v=/opt/mqconfig/broker-a-s-config:/config --name rmqbroker-a-s rocketmq:broker 启动master-b:1# docker run -d -p 40911:40911 -p 40909:40909 -v=/opt/mqconfig/broker-b-config:/config --name rmqbroker-b rocketmq:broker 启动slave-b:1# docker run -d -p 50911:50911 -p 50909:50909 -v=/opt/mqconfig/broker-b-s-config:/config --name rmqbroker-b-s rocketmq:broker 3.6 启动console拉取镜像： 1# docker pull styletang/rocketmq-console-ng 启动容器，指定–link,-p 1# docker run -d -e "JAVA_OPTS=-Drocketmq.namesrv.addr=rmqnamesrv:9877 -Dcom.rocketmq.sendMessageWithVIPChannel=false" --link rmqnamesrv:rmqnamesrv -p 8080:8080 --name rmqconsole -t docker.io/styletang/rocketmq-console-ng 3.7 检查服务状态查看容器状态: 1# docker ps -a 浏览器访问： http://10.29.183.66:8080/ 4.docker瘦身参考网址： http://dockone.io/article/8174]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫框架一二三]]></title>
    <url>%2F2017%2F11%2F29%2F2017-11-29-%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E4%B8%80%E4%BA%8C%E4%B8%89%2F</url>
    <content type="text"><![CDATA[0.概述Heritrix,Nutch,Scrapy三个爬虫框架侧重不同的方面，各有优劣。 1.Heritrix Heritrix是一个专门为互联网上的网页进行存档而开发的网页检索器。它使用Java编写并且完全开源。它主要的用户界面可以通过一个web流量器来访问并通过它来控制检索器的行为，另外，它还有一个命令行工具来供用户选择调用。 Heritrix是由互联网档案馆和北欧国家图书馆联合规范化编写于2003年初。第一次正式发布是在2004年1月，并不断的被互联网档案馆和其他感兴趣的第三方改进着。到现在已经成为一个成熟的开源爬虫，并被广泛使用。 官网：https://sourceforge.net/projects/archive-crawler/ 参考资料: https://www.ibm.com/developerworks/cn/opensource/os-cn-heritrix/ 2.Nutch Nutch是一个开源的网络爬虫项目，更具体些是一个爬虫软件，可以直接用于抓取网页内容。 现在Nutch分为两个版本，1.x和2.x。1.x最新版本为1.7，2.x最新版本为2.2.1。两个版本的主要区别在于底层的存储不同。 1.x版本是基于Hadoop架构的，底层存储使用的是HDFS，而2.x通过使用Apache Gora，使得Nutch可以访问HBase、Accumulo、Cassandra、MySQL、DataFileAvroStore、AvroStore等NoSQL。 官网：http://nutch.apache.org/ 3.Scrapy Scrapy是Python开发的一个快速,高层次的屏幕抓取和web抓取框架，用于抓取web站点并从页面中提取结构化的数据。Scrapy用途广泛，可以用于数据挖掘、监测和自动化测试。GitHub项目主页：https://github.com/scrapy/scrapy Scrapy 使用了 Twisted 异步网络库来处理网络通讯。 官网：http://www.scrapy.org/]]></content>
      <categories>
        <category>开源框架</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C&C++开源框架大全]]></title>
    <url>%2F2017%2F07%2F27%2F2017-09-22-C%26C%2B%2B%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[0.概述C/C++优秀的开源框架列表，以后慢慢研究。 参考地址： http://blog.csdn.net/xiaoxiaoyeyaya/article/details/42541419 1.Tinyhttpdtinyhttpd是一个超轻量型Http Server，使用C语言开发，全部代码只有502行(包括注释)，附带一个简单的Client，可以通过阅读这段代码理解一个 Http Server 的本质。 下载链接：http://sourceforge.net/projects/tinyhttpd/ 2.Libevlibev是一个开源的事件驱动库，基于epoll，kqueue等OS提供的基础设施。其以高效出名，它可以将IO事件，定时器，和信号统一起来，统一放在事件处理这一套框架下处理。基于Reactor模式，效率较高，并且代码精简（4.15版本8000多行），是学习事件驱动编程的很好的资源。 下载链接：http://software.schmorp.de/pkg/libev.html 3.SQLiteSQLite是一个开源的嵌入式关系数据库，实现自包容、零配置、支持事务的SQL数据库引擎。 其特点是高度便携、使用方便、结构紧凑、高效、可靠。足够小，大致3万行C代码，250K。 下载地址：http://www.sqlite.org/ 。 4.异步事件循环Boost.Asio：用于网络和底层I/O编程的跨平台的C++库。 Libev ：功能齐全，高性能的时间循环，轻微地仿效libevent，但是不再像libevent一样有局限性，也修复了它的一些bug。 Libevent ：事件通知库 Libuv ：跨平台异步I/O。 5.网络Boost.Asio：用于网络和底层I/O编程的跨平台的C++库 Onion :C语言HTTP服务器库，其设计为轻量级，易使用。 Muduo ：用于Linux多线程服务器的C++非阻塞网络库 ZeroMQ ：高速，模块化的异步通信库 6.Web应用框架Kore :使用C语言开发的用于web应用程序的超快速和灵活的web服务器/框架。 libOnion：轻量级的库，帮助你使用C编程语言创建web服务器。 Crow ：一个C++微型web框架（灵感来自于Python Flask）]]></content>
      <categories>
        <category>开源框架</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven-配置-插件]]></title>
    <url>%2F2017%2F07%2F27%2F2017-07-27-Maven-%E9%85%8D%E7%BD%AE-%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[0.概述maven的配置以及插件管理 1.pom.xml中plugins插件配置12345&lt;build&gt; &lt;plugins&gt; ..... &lt;/plugins&gt;&lt;/build&gt; 2.plugin-项目编译配置12&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; 说明: 如果我们不告诉它我们的代码要使用什么样的jdk版本编译的话，它就会用maven-compiler-plugin默认的jdk版本来进行处理，这样就容易出现版本不匹配的问题，以至于可能导致编译不通过的问题。例如代码中要是使用上了jdk1.7的新特性，但是maven在编译的时候使用的是jdk1.6的版本，那这一段代码是完全不可能编译成.class文件的。为了处理这一种情况的出现，在构建maven项目的时候，我习惯性第一步就是配置maven-compiler-plugin插件。 实例: 1234567891011121314151617181920&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.6&lt;/source&gt; &lt;!-- 源代码使用的开发版本 --&gt; &lt;target&gt;1.6&lt;/target&gt; &lt;!-- 需要生成的目标class文件的编译版本 --&gt; &lt;!-- 一般而言，target与source是保持一致的，但是，有时候为了让程序能在其他版本的jdk中运行(对于低版本目标jdk，源代码中需要没有使用低版本jdk中不支持的语法)，会存在target不同于source的情况 --&gt; &lt;!-- 这下面的是可选项 --&gt; &lt;meminitial&gt;128m&lt;/meminitial&gt; &lt;maxmem&gt;512m&lt;/maxmem&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;!-- fork is enable,用于明确表示编译版本配置的可用 --&gt; &lt;compilerVersion&gt;1.3&lt;/compilerVersion&gt; &lt;!-- 这个选项用来传递编译器自身不包含但是却支持的参数选项 --&gt; &lt;compilerArgument&gt;-verbose -bootclasspath $&#123;java.home&#125;\lib\rt.jar&lt;/compilerArgument&gt; &lt;/configuration&gt;&lt;/plugin&gt; 3.plugin-项目打包12&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; 说明: maven-assembly-plugin的用途是制作项目分发包，该分发包可能包含了项目的可执行文件、源代码、readme、平台脚本等等。maven-assembly-plugin支持各种主流的格式如zip、tar.gz、jar和war等，具体打包哪些文件是高度可控的，例如用户可以按文件级别的粒度、文件集级别的粒度、模块级别的粒度、以及依赖级别的粒度控制打包，此外，包含和排除配置也是支持的。maven-assembly-plugin要求用户使用一个名为assembly.xml的元数据文件来表述打包，它的single目标可以直接在命令行调用，也可以被绑定至生命周期。 实例: 1234567891011121314151617181920&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!-- not append assembly id in release file name --&gt; &lt;appendAssemblyId&gt;false&lt;/appendAssemblyId&gt; &lt;descriptors&gt; &lt;descriptor&gt;package.xml&lt;/descriptor&gt; &lt;/descriptors&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-deploy-zip&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt;&lt;!-- 绑定到package生命周期阶段上 --&gt; &lt;goals&gt; &lt;goal&gt;single&lt;/goal&gt;&lt;!-- 只运行一次 --&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 4.plugin-打包文件配置12&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; 说明： 打包文件配置:可执行jar的入口方法,如果需要把依赖的jar包一起打包,需要使用 maven-assembly-plugin 实例: 123456789101112131415161718192021222324&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;addClasspath&gt;true&lt;/addClasspath&gt; &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt; &lt;useUniqueVersions&gt;false&lt;/useUniqueVersions&gt; &lt;mainClass&gt;hbec.forum.recsys.etl.BootStrap&lt;/mainClass&gt; &lt;/manifest&gt; &lt;manifestEntries&gt; &lt;Class-Path&gt;configs/&lt;/Class-Path&gt; &lt;/manifestEntries&gt; &lt;/archive&gt; &lt;excludes&gt; &lt;exclude&gt;*.xml&lt;/exclude&gt; &lt;exclude&gt;**/*.xml&lt;/exclude&gt; &lt;exclude&gt;*.json&lt;/exclude&gt; &lt;exclude&gt;*.properties&lt;/exclude&gt; &lt;exclude&gt;*.cfg&lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt;&lt;/plugin&gt; 5.plugin-项目依赖管理12&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; 说明: maven-dependency-plugin最大的用途是帮助分析项目依赖，dependency:list能够列出项目最终解析到的依赖列表，dependency:tree能进一步的描绘项目依赖树，dependency:analyze可以告诉你项目依赖潜在的问题，如果你有直接使用到的却未声明的依赖，该目标就会发出警告。maven-dependency-plugin还有很多目标帮助你操作依赖文件，例如dependency:copy-dependencies能将项目依赖从本地Maven仓库复制到某个特定的文件夹下面。 实例: 123456789101112131415161718&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;copy&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;copy-dependencies&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;outputDirectory&gt; $&#123;project.build.directory&#125;/lib &lt;/outputDirectory&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; 6.plugin-项目版本发布12&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&lt;artifactId&gt;maven-release-plugin&lt;/artifactId&gt; 说明: maven-release-plugin的用途是帮助自动化项目版本发布，它依赖于POM中的SCM信息。release:prepare用来准备版本发布，具体的工作包括检查是否有未提交代码、检查是否有SNAPSHOT依赖、升级项目的SNAPSHOT版本至RELEASE版本、为项目打标签等等。release:perform则是签出标签中的RELEASE源码，构建并发布。版本发布是非常琐碎的工作，它涉及了各种检查，而且由于该工作仅仅是偶尔需要，因此手动操作很容易遗漏一些细节，maven-release-plugin让该工作变得非常快速简便，不易出错。maven-release-plugin的各种目标通常直接在命令行调用，因为版本发布显然不是日常构建生命周期的一部分. 实例: 123456789&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-release-plugin&lt;/artifactId&gt; &lt;version&gt;2.4.2&lt;/version&gt; &lt;configuration&gt; &lt;tagBase&gt;$&#123;svn.url&#125;/$&#123;project.artifactId&#125;/tags/&lt;/tagBase&gt; &lt;branchBase&gt;$&#123;svn.url&#125;/$&#123;project.artifactId&#125;/branches/&lt;/branchBase&gt; &lt;/configuration&gt;&lt;/plugin&gt; 7.plugin-资源文件处理12&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; 说明: 为了使项目结构更为清晰，Maven区别对待Java代码文件和资源文件，maven-compiler-plugin用来编译Java代码，maven-resources-plugin则用来处理资源文件。默认的主资源文件目录是src/main/resources，很多用户会需要添加额外的资源文件目录，这个时候就可以通过配置maven-resources-plugin来实现。此外，资源文件过滤也是Maven的一大特性，你可以在资源文件中使用${propertyName}形式的Maven属性，然后配置maven-resources-plugin开启对资源文件的过滤，之后就可以针对不同环境通过命令行或者Profile传入属性的值，以实现更为灵活的构建。 实例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;configuration&gt; &lt;encoding&gt;GBK&lt;/encoding&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;copy-xmls&lt;/id&gt; &lt;phase&gt;process-sources&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;copy-resources&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;outputDirectory&gt;$&#123;basedir&#125;/target/classes&lt;/outputDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;$&#123;basedir&#125;/src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;execution&gt; &lt;id&gt;copy-properties&lt;/id&gt; &lt;phase&gt;process-sources&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;copy-resources&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;outputDirectory&gt;$&#123;basedir&#125;/target/classes&lt;/outputDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;$&#123;basedir&#125;/src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;execution&gt; &lt;id&gt;copy-dic&lt;/id&gt; &lt;phase&gt;process-sources&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;copy-resources&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;outputDirectory&gt;$&#123;basedir&#125;/target/classes&lt;/outputDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;$&#123;basedir&#125;/src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.dic&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;!-- 打包配置文件 start --&gt; &lt;execution&gt; &lt;id&gt;copy-dev&lt;/id&gt; &lt;phase&gt;process-sources&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;copy-resources&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;outputDirectory&gt;$&#123;basedir&#125;/target/classes&lt;/outputDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;$&#123;basedir&#125;/src/config/dev&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.*&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;!-- 打包配置文件 end --&gt; &lt;/executions&gt;&lt;/plugin&gt; 8.plugin-Maven中运行ant任务12&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt; 说明: maven-antrun-plugin能让用户在Maven项目中运行Ant任务。用户可以直接在该插件的配置以Ant的方式编写Target，然后交给该插件的run目标去执行。在一些由Ant往Maven迁移的项目中，该插件尤其有用。此外当你发现需要编写一些自定义程度很高的任务，同时又觉得Maven不够灵活时，也可以以Ant的方式实现之。maven-antrun-plugin的run目标通常与生命周期绑定运行。 使用实例: 1234567891011121314151617181920&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt; &lt;version&gt;1.7&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;configuration&gt; &lt;tasks&gt; &lt;copy todir="target"&gt; &lt;fileset dir="target/$&#123;project.artifactId&#125;-$&#123;project.version&#125;"&gt;&lt;/fileset&gt; &lt;/copy&gt; &lt;/tasks&gt; &lt;/configuration&gt; &lt;goals&gt; &lt;goal&gt;run&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 9.plugin-生成项目源码包12&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; 说明: 打包项目源文件到jar包中 实例: 1234567891011121314&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;attach-sources&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;jar-no-fork&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 10.plugin-生成项目javadoc文档12&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt; 说明: 生成项目javadoc文档 实例: 12345678&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt; &lt;version&gt;2.9&lt;/version&gt; &lt;configuration&gt; &lt;encoding&gt;GBK&lt;/encoding&gt; &lt;/configuration&gt;&lt;/plugin&gt; 11.plugin-生成项目HTML说明文件12&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&lt;artifactId&gt;maven-site-plugin&lt;/artifactId&gt; 说明: 使用maven 的site 插件 生成一个 可以在 浏览器中 查看项目的站点 实例: 12345678&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-site-plugin&lt;/artifactId&gt; &lt;version&gt;3.3&lt;/version&gt; &lt;configuration&gt; &lt;outputEncoding&gt;GBK&lt;/outputEncoding&gt; &lt;/configuration&gt;&lt;/plugin&gt; 12.plugin-执行单元测试12&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; 说明: 可能是由于历史的原因，Maven 2/3中用于执行测试的插件不是maven-test-plugin，而是maven-surefire-plugin。其实大部分时间内，只要你的测试类遵循通用的命令约定（以Test结尾、以TestCase结尾、或者以Test开头），就几乎不用知晓该插件的存在。然而在当你想要跳过测试、排除某些测试类、或者使用一些TestNG特性的时候，了解maven-surefire-plugin的一些配置选项就很有用了。例如 mvn test -Dtest=FooTest 这样一条命令的效果是仅运行FooTest测试类，这是通过控制maven-surefire-plugin的test参数实现的。 实例: 123456789&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.9&lt;/version&gt; &lt;configuration&gt; &lt;skip&gt;true&lt;/skip&gt; &lt;!-- 跳过测试阶段 --&gt; &lt;testFailureIgnore&gt;true&lt;/testFailureIgnore&gt; &lt;!-- 忽略测试失败 --&gt; &lt;/configuration&gt;&lt;/plugin&gt; 13.plugin-自动配合SVN进行版本发布12&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&lt;artifactId&gt;maven-scm-plugin&lt;/artifactId&gt; 说明: Maven中为我们集成了软件配置管理的（SCM：Software Configuration Management）功能，他可以支持我们常用SVN、CVS等，到现在我使用的1.8.1版本，共支持18个命令 实例: 12345&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-scm-plugin&lt;/artifactId&gt; &lt;version&gt;1.8.1&lt;/version&gt;&lt;/plugin&gt; 14.plugin-jetty运行插件12&lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;&lt;artifactId&gt;maven-jetty-plugin&lt;/artifactId&gt; 说明: 在进行Web开发的时候，打开浏览器对应用进行手动的测试几乎是无法避免的，这种测试方法通常就是将项目打包成war文件，然后部署到Web容器中，再启动容器进行验证，这显然十分耗时。为了帮助开发者节省时间，jetty-maven-plugin应运而生，它完全兼容 Maven项目的目录结构，能够周期性地检查源文件，一旦发现变更后自动更新到内置的Jetty Web容器中。做一些基本配置后（例如Web应用的contextPath和自动扫描变更的时间间隔），你只要执行 mvn jetty:run ，然后在IDE中修改代码，代码经IDE自动编译后产生变更，再由jetty-maven-plugin侦测到后更新至Jetty容器，这时你就可以直接测试Web页面了。需要注意的是，jetty-maven-plugin并不是宿主于Apache或Codehaus的官方插件，因此使用的时候需要额外的配置settings.xml的pluginGroups元素，将org.mortbay.jetty这个pluginGroup加入。 实例: 123456789101112131415161718192021222324252627282930&lt;plugin&gt; &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt; &lt;artifactId&gt;maven-jetty-plugin&lt;/artifactId&gt; &lt;version&gt;6.1.10&lt;/version&gt; &lt;configuration&gt; &lt;scanIntervalSeconds&gt;10&lt;/scanIntervalSeconds&gt; &lt;stopKey&gt;foo&lt;/stopKey&gt; &lt;stopPort&gt;9999&lt;/stopPort&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;start-jetty&lt;/id&gt; &lt;phase&gt;pre-integration-test&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;run&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;scanIntervalSeconds&gt;0&lt;/scanIntervalSeconds&gt; &lt;daemon&gt;true&lt;/daemon&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;execution&gt; &lt;id&gt;stop-jetty&lt;/id&gt; &lt;phase&gt;post-integration-test&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;stop&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 开始：mvn jetty:start 关闭：mvn jetty:stop 15.plugin-在tomcat中运行项目12&lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;&lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; 说明: 使用maven将web项目运行在tomcat中 实例: 12345678910&lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;port&gt;8889&lt;/port&gt; &lt;path&gt;/&lt;/path&gt; &lt;uriEncoding&gt;utf-8&lt;/uriEncoding&gt; &lt;/configuration&gt;&lt;/plugin&gt; 16.plugin-生成简单的项目骨架12&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&lt;artifactId&gt;maven-archetype-plugin&lt;/artifactId&gt; 说明: Archtype指项目的骨架，Maven初学者最开始执行的Maven命令可能就是mvn archetype:generate，这实际上就是让maven-archetype-plugin生成一个很简单的项目骨架，帮助开发者快速上手。可能也有人看到一些文档写了mvn archetype:create，但实际上create目标已经被弃用了，取而代之的是generate目标，该目标使用交互式的方式提示用户输入必要的信息以创建项目，体验更好。maven-archetype-plugin还有一些其他目标帮助用户自己定义项目原型，例如你由一个产品需要交付给很多客户进行二次开发，你就可以为他们提供一个Archtype，帮助他们快速上手。 17.plugin-创建强制规则12&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&lt;artifactId&gt;maven-enforcer-plugin&lt;/artifactId&gt; 说明: 在一个稍大一点的组织或团队中，你无法保证所有成员都熟悉Maven，那他们做一些比较愚蠢的事情就会变得很正常，例如给项目引入了外部的SNAPSHOT依赖而导致构建不稳定，使用了一个与大家不一致的Maven版本而经常抱怨构建出现诡异问题。maven-enforcer-plugin能够帮助你避免之类问题，它允许你创建一系列规则强制大家遵守，包括设定Java版本、设定Maven版本、禁止某些依赖、禁止SNAPSHOT依赖。只要在一个父POM配置规则，然后让大家继承，当规则遭到破坏的时候，Maven就会报错。除了标准的规则之外，你还可以扩展该插件，编写自己的规则。maven-enforcer-plugin的enforce目标负责检查规则，它默认绑定到生命周期的validate阶段。 18.plugin-帮助工具12&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&lt;artifactId&gt;maven-help-plugin&lt;/artifactId&gt; 说明: maven-help-plugin是一个小巧的辅助工具，最简单的help:system可以打印所有可用的环境变量和Java系统属性。help:effective-pom和help:effective-settings最为有用，它们分别打印项目的有效POM和有效settings，有效POM是指合并了所有父POM（包括Super POM）后的XML，当你不确定POM的某些信息从何而来时，就可以查看有效POM。有效settings同理，特别是当你发现自己配置的settings.xml没有生效时，就可以用help:effective-settings来验证。此外，maven-help-plugin的describe目标可以帮助你描述任何一个Maven插件的信息，还有all-profiles目标和active-profiles目标帮助查看项目的Profile。 19.plugin-其它12&lt;groupId&gt;com.thoughtworks.paranamer&lt;/groupId&gt;&lt;artifactId&gt;paranamer-maven-plugin&lt;/artifactId&gt; 说明: 暂无 实例: 1234567891011121314151617&lt;plugin&gt; &lt;groupId&gt;com.thoughtworks.paranamer&lt;/groupId&gt; &lt;artifactId&gt;paranamer-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;run&lt;/id&gt; &lt;configuration&gt; &lt;sourceDirectory&gt;$&#123;project.build.sourceDirectory&#125;&lt;/sourceDirectory&gt; &lt;outputDirectory&gt;$&#123;project.build.outputDirectory&#125;&lt;/outputDirectory&gt; &lt;/configuration&gt; &lt;goals&gt; &lt;goal&gt;generate&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 20.plugin插件本地位置在Maven中,仓库就是存放依赖和插件的地方。插件的远端、本地地址和仓库的远端、本地地址相同。 在pom.xml中通过plugin引入的插件本地默认在”C:\Users\Administrator.m2\repository\org\apache\maven\plugins”中。 21.打包类型设置1&lt;packaging&gt;war&lt;/packaging&gt; 21.仓库地址配置123456789101112&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;public&lt;/id&gt; &lt;url&gt;http://10.0.30.78:8080/nexus/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt;&lt;/repositories&gt; 22.Maven-settings.xml配置结构: 12345678910111213141516171819202122232425262728293031323334353637&lt;settings xmlns="http://maven.apache.org/POM/4.0.0"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd"&gt;&lt;!-- 1.【servers】:nexus仓库deploy账号设置,id分为:releases,snapshots--&gt;&lt;servers&gt; &lt;server&gt; &lt;id&gt;&lt;/id&gt; &lt;username&gt;&lt;/username&gt; &lt;password&gt;&lt;/password&gt; &lt;/server&gt;&lt;/servers&gt;&lt;!-- 2.【profiles】:环境配置,仓库配置--&gt;&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;&lt;/id&gt; &lt;properties&gt;&lt;/properties&gt; &lt;repositories&gt;&lt;/repositories&gt; &lt;pluginRepositories&gt;&lt;/pluginRepositories&gt; &lt;dependencies&gt;&lt;/dependencies&gt; &lt;plugins&gt;&lt;/plugins&gt; &lt;dependencyManagement&gt;&lt;/dependencyManagement&gt; &lt;distributionManagement&gt;&lt;/distributionManagement&gt; &lt;build&gt;&lt;/build&gt; &lt;activation&gt;&lt;/activation&gt; &lt;!-- 激活条件:默认激活,激活条件.或者单独用activeProfiles设置 --&gt; &lt;/profile&gt;&lt;/profiles&gt;&lt;!-- 3.【activeProfiles】:激活配置设置 --&gt;&lt;activeProfiles&gt; &lt;activeProfile&gt;&lt;/activeProfile&gt;&lt;/activeProfiles&gt;&lt;!-- 4.【mirrors】:镜像设置 --&gt;&lt;mirrors/&gt;&lt;!-- 5.【localRepository】:本地仓库设置--&gt;&lt;localRepository&gt;&lt;/localRepository&gt;&lt;/settings&gt; 实例1: 123456789101112131415161718192021222324252627282930313233343536&lt;settings xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd"&gt;&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;Repositories&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;public&lt;/id&gt; &lt;url&gt;http://10.0.30.78:8080/nexus/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;/profile&gt;&lt;/profiles&gt;&lt;activeProfiles&gt; &lt;activeProfile&gt;Repositories&lt;/activeProfile&gt;&lt;/activeProfiles&gt;&lt;servers&gt; &lt;server&gt; &lt;id&gt;releases&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;snapshots&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt; &lt;/server&gt;&lt;/servers&gt;&lt;/settings&gt; 实例2: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;settings xmlns="http://maven.apache.org/SETTINGS/1.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd"&gt; &lt;pluginGroups&gt;&lt;/pluginGroups&gt; &lt;proxies&gt;&lt;/proxies&gt; &lt;!--nexus account releases帐号为nexus发布正式版本帐号发布帐号,请找部门负责人获取--&gt; &lt;servers&gt; &lt;server&gt; &lt;id&gt;releases&lt;/id&gt; &lt;username&gt;***&lt;/username&gt; &lt;password&gt;***&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;snapshots&lt;/id&gt; &lt;username&gt;deploy&lt;/username&gt; &lt;password&gt;deploy&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt; &lt;profiles&gt; &lt;profile&gt; &lt;!--maven中心库的地址 &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;thinkive_public&lt;/id&gt; &lt;url&gt;http://192.168.1.99:8081/nexus/content/groups/public&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; --&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;thinkive_public&lt;/id&gt; &lt;url&gt;http://10.0.30.78:8080/nexus/content/groups/public/&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!--maven插件库的地址 &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;thinkive_plugin_public&lt;/id&gt; &lt;url&gt;http://192.168.1.99:8081/nexus/content/groups/public&lt;/url&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; --&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;thinkive_plugin_public&lt;/id&gt; &lt;url&gt;http://10.0.30.78:8080/nexus/content/groups/public/&lt;/url&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;properties&gt; &lt;configPath&gt;/src/config/dev&lt;/configPath&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;uat&lt;/id&gt; &lt;properties&gt; &lt;configPath&gt;/src/config/uat&lt;/configPath&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;pdt&lt;/id&gt; &lt;properties&gt; &lt;configPath&gt;/src/config/pdt&lt;/configPath&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;mirrors/&gt; &lt;localRepository&gt;E:\mysoft\thinkive-repository&lt;/localRepository&gt;&lt;/settings&gt; 23.pom.xml中dependency的scope配置依赖范围控制哪些依赖在哪些classpath 中可用，哪些依赖包含在一个应用中。让我们详细看一下每一种范围： compile （编译范围）compile是默认的范围；如果没有提供一个范围，那该依赖的范围就是编译范围。编译范围依赖在所有的classpath 中可用，同时它们也会被打包。 provided （已提供范围）provided 依赖只有在当JDK 或者一个容器已提供该依赖之后才使用。例如， 如果你开发了一个web 应用，你可能在编译 classpath 中需要可用的Servlet API 来编译一个servlet，但是你不会想要在打包好的WAR 中包含这个Servlet API；这个Servlet API JAR 由你的应用服务器或者servlet 容器提供。已提供范围的依赖在编译classpath （不是运行时）可用。它们不是传递性的，也不会被打包。 runtime （运行时范围）runtime 依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如，你可能在编译的时候只需要JDBC API JAR，而只有在运行的时候才需要JDBC驱动实现。test （测试范围）test范围依赖 在一般的编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用。 system （系统范围）system范围依赖与provided 类似，但是你必须显式的提供一个对于本地系统中JAR 文件的路径。这么做是为了允许基于本地对象编译，而这些对象是系统类库的一部分。这样的构件应该是一直可用的，Maven 也不会在仓库中去寻找它。如果你将一个依赖范围设置成系统范围，你必须同时提供一个 systemPath 元素。注意该范围是不推荐使用的（你应该一直尽量去从公共或定制的 Maven 仓库中引用依赖）。]]></content>
      <categories>
        <category>项目构建</category>
      </categories>
      <tags>
        <tag>WEB技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS布局(layout)三大器-display-position-float]]></title>
    <url>%2F2017%2F04%2F09%2F2017-04-09-CSS%E5%B8%83%E5%B1%80(layout)%E4%B8%89%E5%A4%A7%E5%99%A8-display-position-float%2F</url>
    <content type="text"><![CDATA[0.概述CSS布局常用方式有display(显示),position(定位),float(浮动)三种手段，每种手段对应的使用场景也不一样。 1.display属性display的常用值有:inline,block,flex,grid,table。还有不显示none,以及交叉组合:inline-block,inline-flex,inline-grid,inline-table。 inline:行内元素 block:块元素 flex:Flexible Box弹性布局 grid:网格布局 table:表格布局 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;1.块元素(block-element)&lt;/h2&gt;&lt;span&gt;a:块级元素会独占一行,其宽度自动填满其父元素宽度。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;b:块级元素可以设置 width,height属性,块级元素即使设置了宽度,仍然是独占一行的。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;c:块级元素可以设置margin和padding。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;d:block元素可以包含block元素和inline元素；但inline元素只能包含inline元素。要注意的是这个是个大概的说法，每个特定的元素能包含的元素也是特定的，所以具体到个别元素上，这条规律是不适用的。比如 P 元素，只能包含inline元素，而不能包含block元素。&lt;br/&gt;&lt;/span&gt;&lt;h4&gt;1.1 div&lt;/h4&gt;&lt;div style="height:80px;width:50px;border:1px solid red"&gt;&lt;/div&gt;&lt;div style="height:80px;width:120px;border:1px solid blue"&gt;&lt;/div&gt;&lt;h4&gt;1.2 p&lt;/h4&gt;&lt;p style="height: 20px;width:200px;background-color:red"&gt; &lt;span&gt;这是p标签中的span标签&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;1.3 form&lt;/h4&gt;&lt;form style="border:1px solid blue"&gt; &lt;span&gt;form中的span标签&lt;/span&gt;&lt;/form&gt;&lt;h4&gt;1.4 块元素汇总&lt;/h4&gt;&lt;span&gt;* address - 地址&lt;br/&gt;* blockquote - 块引用&lt;br/&gt;* center - 举中对齐块&lt;br/&gt;* dir - 目录列表&lt;br/&gt;* div - 常用块级容易，也是css layout的主要标签&lt;br/&gt;* dl - 定义列表&lt;br/&gt;* fieldset - form控制组&lt;br/&gt;* form - 交互表单&lt;br/&gt;* h1 - 大标题&lt;br/&gt;* h2 - 副标题&lt;br/&gt;* h3 - 3级标题&lt;br/&gt;* h4 - 4级标题&lt;br/&gt;* h5 - 5级标题&lt;br/&gt;* h6 - 6级标题&lt;br/&gt;* hr - 水平分隔线&lt;br/&gt;* isindex - input prompt&lt;br/&gt;* menu - 菜单列表&lt;br/&gt;* noframes - frames可选内容，（对于不支持frame的浏览器显示此区块内容&lt;br/&gt;* noscript - ）可选脚本内容（对于不支持script的浏览器显示此内容）&lt;br/&gt;* ol - 排序表单&lt;br/&gt;* p - 段落&lt;br/&gt;* pre - 格式化文本&lt;br/&gt;* table - 表格&lt;br/&gt;* ul - 非排序列表&lt;br/&gt;&lt;/span&gt;&lt;h2&gt;2.行内元素(inline-element)&lt;/h2&gt;&lt;span&gt;a:行内元素不会独占一行,相邻的行内元素会排列在同一行里,直到一行排不下,才会换行,其宽度随元素的内容而变化。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;b:行内元素设置width,height无效。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;c:行内元素的水平方向的padding-left,padding-right,margin-left,margin-right 都产生边距效果，但是竖直方向的padding-top,padding-bottom,margin-top,margin-bottom都不会产生边距效果。&lt;br/&gt;&lt;/span&gt;&lt;h4&gt;2.1 input&lt;/h4&gt;&lt;input type="button" value="button1" /&gt;&lt;input type="button" value="button2" /&gt;&lt;h4&gt;2.2 label&lt;/h4&gt;&lt;label&gt;label1&lt;/label&gt;&lt;label&gt;label2&lt;/label&gt;&lt;label&gt;label3&lt;/label&gt;&lt;h4&gt;2.3 select&lt;/h4&gt;&lt;select&gt; &lt;option&gt;sele1&lt;/option&gt; &lt;option&gt;sele2&lt;/option&gt; &lt;option selected="true"&gt;sele3&lt;/option&gt; &lt;option&gt;sele4&lt;/option&gt; &lt;option&gt;sele5&lt;/option&gt;&lt;/select&gt;&lt;select&gt; &lt;option&gt;水果1&lt;/option&gt; &lt;option selected="true"&gt;水果2&lt;/option&gt; &lt;option&gt;水果3&lt;/option&gt; &lt;option&gt;水果4&lt;/option&gt; &lt;option&gt;水果5&lt;/option&gt;&lt;/select&gt;&lt;h4&gt;2.4 行内元素汇总&lt;/h4&gt;&lt;span&gt;* a - 锚点&lt;br/&gt;* abbr - 缩写&lt;br/&gt;* acronym - 首字&lt;br/&gt;* b - 粗体(不推荐)&lt;br/&gt;* bdo - bidi override&lt;br/&gt;* big - 大字体&lt;br/&gt;* br - 换行&lt;br/&gt;* cite - 引用&lt;br/&gt;* code - 计算机代码(在引用源码的时候需要)&lt;br/&gt;* dfn - 定义字段&lt;br/&gt;* em - 强调&lt;br/&gt;* font - 字体设定(不推荐)&lt;br/&gt;* i - 斜体&lt;br/&gt;* img - 图片&lt;br/&gt;* input - 输入框&lt;br/&gt;* kbd - 定义键盘文本&lt;br/&gt;* label - 表格标签&lt;br/&gt;* q - 短引用&lt;br/&gt;* s - 中划线(不推荐)&lt;br/&gt;* samp - 定义范例计算机代码&lt;br/&gt;* select - 项目选择&lt;br/&gt;* small - 小字体文本&lt;br/&gt;* span - 常用内联容器，定义文本内区块&lt;br/&gt;* strike - 中划线&lt;br/&gt;* strong - 粗体强调&lt;br/&gt;* sub - 下标&lt;br/&gt;* sup - 上标&lt;br/&gt;* textarea - 多行文本输入框&lt;br/&gt;* tt - 电传文本&lt;br/&gt;* u - 下划线&lt;br/&gt;* var - 定义变量&lt;br/&gt;&lt;/span&gt;&lt;h2&gt;3.inlinke-block&lt;/h2&gt;&lt;span&gt;简单来说就是将对象呈现为inline对象，但是对象的内容作为block对象呈现。之后的内联对象会被排列在同一行内。比如我们可以给一个link（a元素）inline-block属性值，使其既具有block的宽度高度特性又具有inline的同行特性&lt;/span&gt;&lt;h2&gt;4.可变元素&lt;/h2&gt;&lt;span&gt;4.1可变元素为根据上下文语境决定该元素为块元素或者内联元素。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;* applet - java applet&lt;br/&gt;* button - 按钮&lt;br/&gt;* del - 删除文本&lt;br/&gt;* iframe - inline frame&lt;br/&gt;* ins - 插入的文本&lt;br/&gt;* map - 图片区块(map)&lt;br/&gt;* object - object对象&lt;br/&gt;* script - 客户端脚本&lt;br/&gt;&lt;/span&gt;&lt;h2&gt;5.布局设置display&lt;/h2&gt;&lt;span&gt;一般来说，可以通过display:inline和display:block的设置，改变元素的布局级别。display可以设置的参数不止以上三种，只是比较常用而已。&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 2.position属性position属性的值有:absolute(绝对布局),relative(相对布局),fixed(固定布局),static(默认布局),inherit(继承父标签position属性值) 和position搭配使用的属性有:left,right,top,bottom和层次属性z-index. 3.float属性float属性的值有:left,right,none(默认值,不浮动),inherit(继承父标签float属性值)]]></content>
      <categories>
        <category>CSS布局</category>
      </categories>
      <tags>
        <tag>WEB技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JWT-基于Token的身份验证]]></title>
    <url>%2F2017%2F02%2F20%2F2017-02-20-JWT-%E5%9F%BA%E4%BA%8EToken%E7%9A%84%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[0.概述对Token有过使用和了解，但都没有一个系统的学习，从网上看到一篇文章简单并全面的介绍了下Token，特此摘录了下。 1.背景很多大型网站也都在用，比如 Facebook，Twitter，Google+，Github 等等，比起传统的身份验证方法，Token 扩展性更强，也更安全点，非常适合用在 Web 应用或者移动应用上。Token 的中文有人翻译成 “令牌”，我觉得挺好，意思就是，你拿着这个令牌，才能过一些关卡。 2.传统身份验证的方法HTTP 是一种没有状态的协议，也就是它并不知道是谁是访问应用。这里我们把用户看成是客户端，客户端使用用户名还有密码通过了身份验证，不过下回这个客户端再发送请求时候，还得再验证一下。 解决的方法就是，当用户请求登录的时候，如果没有问题，我们在服务端生成一条记录，这个记录里可以说明一下登录的用户是谁，然后把这条记录的 ID 号发送给客户端，客户端收到以后把这个 ID 号存储在 Cookie 里，下次这个用户再向服务端发送请求的时候，可以带着这个 Cookie ，这样服务端会验证一个这个 Cookie 里的信息，看看能不能在服务端这里找到对应的记录，如果可以，说明用户已经通过了身份验证，就把用户请求的数据返回给客户端。 上面说的就是 Session，我们需要在服务端存储为登录的用户生成的 Session ，这些 Session 可能会存储在内存，磁盘，或者数据库里。我们可能需要在服务端定期的去清理过期的 Session 。 3.基于 Token 的身份验证方法使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的： 1.客户端使用用户名跟密码请求登录 2.服务端收到请求，去验证用户名与密码 3.验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端 4.客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里 5.客户端每次向服务端请求资源的时候需要带着服务端签发的 Token 6.服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据 4.JWT实施 Token 验证的方法挺多的，还有一些标准方法，比如 JWT，读作：jot ，表示：JSON Web Tokens 。JWT 标准的 Token 有三个部分： header payload signature 中间用点分隔开，并且都会使用 Base64 编码，所以真正的 Token 看起来像这样 eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJuaW5naGFvLm5ldCIsImV4cCI6IjE0Mzg5NTU0NDUiLCJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlfQ.SwyHTEx_RQppr97g4J5lKXtabJecpejuef8AqKYMAJc Header header 部分主要是两部分内容，一个是 Token 的类型，另一个是使用的算法，比如下面类型就是 JWT，使用的算法是 HS256。 { &quot;typ&quot;: &quot;JWT&quot;, &quot;alg&quot;: &quot;HS256&quot; } 上面的内容要用 Base64 的形式编码一下，所以就变成这样： eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 Payload Payload 里面是 Token 的具体内容，这些内容里面有一些是标准字段，你也可以添加其它需要的内容。下面是标准字段： iss：Issuer，发行者 sub：Subject，主题 aud：Audience，观众 exp：Expiration time，过期时间 nbf：Not before iat：Issued at，发行时间 jti：JWT ID 比如下面这个 Payload ，用到了 iss 发行人，还有 exp 过期时间。另外还有两个自定义的字段，一个是 name ，还有一个是 admin 。 { &quot;iss&quot;: &quot;ninghao.net&quot;, &quot;exp&quot;: &quot;1438955445&quot;, &quot;name&quot;: &quot;wanghao&quot;, &quot;admin&quot;: true } 使用 Base64 编码以后就变成了这个样子： eyJpc3MiOiJuaW5naGFvLm5ldCIsImV4cCI6IjE0Mzg5NTU0NDUiLCJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlfQ Signature JWT 的最后一部分是 Signature ，这部分内容有三个部分，先是用 Base64 编码的 header.payload ，再用加密算法加密一下，加密的时候要放进去一个 Secret ，这个相当于是一个密码，这个密码秘密地存储在服务端。 header payload secret var encodedString = base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload); HMACSHA256(encodedString, &#39;secret&#39;); 处理完成以后看起来像这样： SwyHTEx_RQppr97g4J5lKXtabJecpejuef8AqKYMAJc 最后这个在服务端生成并且要发送给客户端的 Token 看起来像这样： eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJuaW5naGFvLm5ldCIsImV4cCI6IjE0Mzg5NTU0NDUiLCJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlfQ.SwyHTEx_RQppr97g4J5lKXtabJecpejuef8AqKYMAJc 客户端收到这个 Token 以后把它存储下来，下回向服务端发送请求的时候就带着这个 Token 。服务端收到这个 Token ，然后进行验证，通过以后就会返回给客户端想要的资源。 5.相关链接http://jwt.io/ https://github.com/firebase/php-jwt https://scotch.io/tutorials/the-anatomy-of-a-json-web-token https://github.com/auth0/jwt-decode https://ninghao.net/blog/2834]]></content>
      <categories>
        <category>Token详解</category>
      </categories>
      <tags>
        <tag>WEB技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习算法-回归-最大似然函数]]></title>
    <url>%2F2017%2F01%2F03%2F2017-01-03-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E5%9B%9E%E5%BD%92-%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[0.概述似然函数与概率非常类似但又有根本的区别，概率为在某种条件（参数）下预测某事件发生的可能性；而似然函数与之相反为已知该事件的情况下推测出该事件发生时的条件（参数）；所以似然估计也称为参数估计，为参数估计中的一种算法。 1.抛硬币的似然函数假如有一枚硬币我们现在不知道它是否为正常硬币（正反面出现概率各位50%），所以想通过抛10次然后通过硬币正反面出现的概率分布判断该硬币是否正常；当抛完10次时出现5次正面向上、5次反面向上，正反面出现的概率符合正常硬币的预期，这时我们可以判断该硬币是正常的； 二项分布解析: 2.使用最大似然法求硬币问题似然函数为知道了结果求条件，概率问题为知道了条件求概率，在这个问题中就是知道了硬币是正常的，求正反面出现的比例w为何值时该结果最靠谱；所以似然函数等于： 函数左边的值并非条件概率中的条件而是该函数的依赖值，似然函数L为在给定结果y的情况下参数w的取值情况，概率函数L为知道了参数w求得y的取值；有了抛硬币情况的概率分布这里就可以给出似然函数： 下面对该似然对数进行求关于w的偏导数： 通过求L关于w的偏导数求得w=0.5，于我们上面概率中的w时一致的，也就是说当w=0.5时y正面出现的次数等于5的可能性是最高的。 3.线性回归通过前面几篇文章我们知道了线性回归的模型为： 按照惯例直接求解似然函数比较麻烦所以求解对数似然函数： 然后求L关于w的偏导数，令其等于0求拐点 到这一步我们已经求得到了W，这与前面我们通过最小二乘法求得的矩阵方程一样，所以w也一定是我们这里求得的w正确解。 使用最大似然法求解问题的步骤为： 一、确定问题的随机变量类型是离散随机变量还是连续随机变量 二、得出问题的概率分布 三、概率函数转为似然函数 四、似然函数取对数 五、求关于某变量的偏导数 六、解似然方程 4.总结最大似然和最小二乘法是求解回归问题的不同方法，结果都和正规方程一样，但求解的思路不一样。 参考资料:http://www.cnblogs.com/softlin/p/6219372.html]]></content>
      <categories>
        <category>回归算法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习算法-回归-最小二乘法(LeastSquare)]]></title>
    <url>%2F2016%2F12%2F31%2F2016-12-31-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E5%9B%9E%E5%BD%92-%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95%2F</url>
    <content type="text"><![CDATA[0.概述对于线性回归的参数求解问题，可以使用迭代法求解，如梯度下降(GD)。也可以使用非迭代法，如正规方程(NormalEquation)。正规方程的本质是最小二乘法的矩阵形式，最小二乘法求解本质是对代价函数求导。 1.背景最小二乘法（又称最小平方法）是一种数学优化技术。它通过最小化误差的平方和寻找数据的最佳函数匹配。利用最小二乘法可以简便地求得未知的数据，并使得这些求得的数据与实际数据之间误差的平方和为最小。最小二乘法还可用于曲线拟合。其他一些优化问题也可通过最小化能量或最大化熵用最小二乘法来表达。 《统计学习方法》中提到，回归学习最常用的损失函数是平方损失函数，在此情况下，回归问题可以用著名的最小二乘法来解决。看来最小二乘法果然是机器学习领域最有名和有效的算法之一。 2.最小二乘法(LeastSquare)我们以最简单的一元线性模型来解释最小二乘法。什么是一元线性模型呢？ 监督学习中，如果预测的变量是离散的，我们称其为分类（如决策树，支持向量机等），如果预测的变量是连续的，我们称其为回归。回归分析中，如果只包括一个自变量和一个因变量，且二者的关系可用一条直线近似表示，这种回归分析称为一元线性回归分析。如果回归分析中包括两个或两个以上的自变量，且因变量和自变量之间是线性关系，则称为多元线性回归分析。对于二维空间线性是一条直线；对于三维空间线性是一个平面，对于多维空间线性是一个超平面。 对于平面中的这n个点，可以使用无数条曲线来拟合。要求样本回归函数尽可能好地拟合这组值。综合起来看，这条直线处于样本数据的中心位置最合理。 选择最佳拟合曲线的标准可以确定为：使总的拟合误差（即总残差）达到最小。有以下三个标准可以选择： （1）用“残差和最小”确定直线位置是一个途径。但很快发现计算“残差和”存在相互抵消的问题。 （2）用“残差绝对值和最小”确定直线位置也是一个途径。但绝对值的计算比较麻烦。 （3）最小二乘法的原则是以“残差平方和最小”确定直线位置。用最小二乘法除了计算比较方便外，得到的估计量还具有优良特性。这种方法对异常值非常敏感。 3.普通最小二乘法(OrdinaryLeastSquare,OLS)最常用的是普通最小二乘法(OrdinaryLeastSquare,OLS)：所选择的回归模型应该使所有观察值的残差平方和达到最小。 为了方便讲清楚最小二乘法推导过程这里使用，数据集有1…N个数据组成，每个数据由、构成，x表示特征，y为结果；这里将线性回归模型定义为： 平均损失函数定义有： 要求得L的最小，其关于c与m的偏导数定为0，所以求偏导数，得出后让导数等于0，并对c与m求解便能得到最小的L此时的c与m便是最匹配该模型的； 关于c偏导数: 关于m的偏导数: 令关于c的偏导数等于0，求解： 令关于m的偏导数等于0，求解： 4.普通最小二乘法(OrdinaryLeastSquare,OLS)-矩阵形式模型变换 代价函数 根据矩阵乘积转置规则损失函数可以进一步化简为： 偏导数 5.最小二乘法与梯度下降法比较最小二乘法跟梯度下降法都是通过求导来求损失函数的最小值，那它们有什么区别呢。 相同 1.本质相同：两种方法都是在给定已知数据（independent &amp; dependent variables）的前提下对dependent variables算出出一个一般性的估值函数。然后对给定新数据的dependent variables进行估算。 2.目标相同：都是在已知数据的框架内，使得估算值与实际值的总平方差尽量更小（事实上未必一定要使用平方），估算值与实际值的总平方差的公式为： 其中x(i) 为第i组数据的independent variable，y(i) 为第i组数据的dependent variable，B 为系数向量。 不同 1.实现方法和结果不同：最小二乘法是直接对△求导找出全局最小，是非迭代法。而梯度下降法是一种迭代法，先给定一个B ，然后向△下降最快的方向调整B ，在若干次迭代之后找到局部最小。梯度下降法的缺点是到最小点的时候收敛速度变慢，并且对初始点的选择极为敏感，其改进大多是在这两方面下功夫。 参考资料:http://www.cnblogs.com/softlin/p/5815531.html]]></content>
      <categories>
        <category>回归算法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[决策树-随机森林-Boosting-Adaboost-GBDT由决策树衍生的分类算法]]></title>
    <url>%2F2016%2F12%2F29%2F2016-12-29-%E5%86%B3%E7%AD%96%E6%A0%91-%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97-Boosting-Adaboost-GBDT%E7%94%B1%E5%86%B3%E7%AD%96%E6%A0%91%E8%A1%8D%E7%94%9F%E7%9A%84%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[0.概述基于树模型的分类与回归算法。 1.决策树(Decision Tree,DT)分类算法决策树是一种常见的分类与回归模型，主要呈树结构，每一个节点代表一个集合，一条边代表一种属性，而叶子节点则表示对应的类别或值。根据节点分裂规则的不同，主要分为三种方法。 ID3算法 ID3算法采用的是选择一个特征使得分裂前后样本集合的不确定性降低最大，也就是信息增益最大。 计算方式：g(D,A)=H(D)-H(D/A)。H(D)表示分裂前对应样本集合的经验熵，而H(D/A)表示在A特征划分下的样本经验熵，也就是由特征A进行子集划分后的经验熵之和。 ID3算法采用信息增益最大的方式，对于一个节点而言，其对应的样本集合如果所有的类别不是一类，且样本集合不为空，逐个选择特征计算信息增益，选择最大的信息增益，如果其信息增益大于阈值，则按照对应的特征进行样本划分（分裂），然后对每个子节点和样本，循环上述的方法，否则停止。 C4.5算法 C4.5算法是ID3算法的改进，由于ID3计算方式会导致选择特征时倾向于选择值较多的特征，C4.5引入了信息增益比的方式。即当前特征下计算的信息增益除以此特征对应的经验熵，基于C4.5的决策树的生产方式与上述类似。 剪枝规则：剪枝的思想就是比较当前节点的下对应的整棵决策树的损失函数，与返回到其父节点上对应的损失函数，当父节点下对应的损失函数比子节点下的损失函数更小时，可以进行剪枝，将父节点变为叶子节点，去掉其子节点。至于决策树的损失函数，是各个叶子节点上的经验熵与节点样本数之积的总和，加上aT，T为叶子节点数。其中前半部分用于表征决策树的训练误差，而aT则代表了决策树的复杂程度。根据剃刀准则，只有在训练误差足够下的同时，模型也足够简单，这样的模型才是最好的，能够防止过拟合。 CART算法 CART算法也是对分裂规则进行改进，可以用来进行分类与回归，能够处理连续的数据。CART分类规则是选择特征A，使得划分前后基尼系数比的降低最大，也就是划分后左右节点的基尼系数之和最小。 在使用CART树进行回归时，可以采用基于方差的形式，由于回归时标签都是连续值，因此使用方差较为合适。即分别挑选一个特征，基于此特征下，逐个遍历特征值，将样本划分为左右子集（2层循环，第一层为特征数，第二层为某个特征对应的取值），计算左右子集的方差之和，找到所有的特征下特征值对应的方差最小的那个特征和特征值，作为划分特征和阈值，进行节点的分裂。CART树的生成方式是二叉树的形式，与上述两种方法有些微不同。但是大体的步骤相同。 剪枝规则：采用的是分别记录由根节点到各个节点下对应的决策树的损失函数序列，找到在设定值a下决策树对训练数据的预测误差最小对应的树结构。 2.随机森林(RandomForests/RandomTrees)随机森林类似bagging思想，对样本进行多次采用，并以此生成多颗决策树，通过投票获得判别结果。 随机森林中的每棵树与决策树的区别：主要包括3点： 1）.样本随机采样:n=2/3*N;就是说对训练样本而言，每棵树从样本集中采用大约2/3的样本进行决策树的训练； 2）.特征随机抽取：k&lt;&lt;K;对于样本集中的特征，不是逐个遍历所有的特征进行划分，而是在所有的特征中随机选择k个特征，从这k个特征中找到最优的划分特征，以此对节点的样本进行划分，因此用过的特征可能还会出现。 3）.无剪枝：由于随机森林在进行训练样本选择时是随机抽样的，选择划分特征时也是随机的，因此不需要进行剪枝。 OBB无偏估计：一般对于所有的训练样本，抽取2/3的样本数进行决策树的训练，那么大约有1/3的样本没有被抽取到，由limN-∞ (1-1/N)^N求得。这些样本成为袋外样本，利用这些样本对随机森林中的决策树进行预测误差的估计，称为obb无偏估计。 3.霍夫森林(HoughForests)主要用来进行目标检测，也有人用来进行头部姿态估计。它与随机森林相比，往往还需要每个样本到目标中心的距离值，作为额外的输入。 对于分裂规则：对于样本集合，包括特征、标签以及中心距离，首先生成二值测试特征集，对于当前节点的样本集，选择一个二值测试特征集中的一个特征，将样本集划分为两个子集{0,1}，对于0、1子集，分别随机选择类别不确定规则与位置不确定规则（可进行分类或回归，CART规则）计算总误差。遍历所有的二值测试集中的特征，找到最小的总误差对应的二值测试特征，将当前节点的样本集进行左右划分。此外当达到停止条件时就停止分裂。 4.Boosting算法Boosting算法是一种把若干个分类器整合为一个分类器的方法，在boosting算法产生之前，还出现过两种比较重要的将多个分类器整合为一个分类器的方法，即boostrapping方法和bagging方法。boosting算法的思想受到bootstraping思想和bagging想的启发而产生，大致原理是通过训练多个分类器作为一个模型，提升决策能力。我们先简要介绍一下bootstrapping方法和bagging方法。 (1)boosttraping ：是一种样本抽样方式，对一个样本集N，只采样其中的一部分子样本m个，放入模型中去学习，一般是有放回的抽样。跟随机森林中的样本随机选取一样。 主要步骤： i)重复地从一个样本集合D中采样n个样本 ii)针对每次采样的子样本集，进行统计学习，获得假设Hi iii)将若干个假设进行组合，形成最终的假设Hfinal iv)将最终的假设用于具体的分类任务 (2)bagging：其思想是指对一个样本集N，分别抽样m个子集合，每个子集分别对应一个模型进行训练。最后的输出结果为各个模型的结果投票。即对分类问题，各个类别结果相加取最大，对于回归问题，各模型输出的平均值。 主要思路: i)训练分类器 从整体样本集合中，抽样n* &lt; N个样本 针对抽样的集合训练分类器Ci。 ii)分类器进行投票，最终的结果是分类器投票的优胜结果。 述这两种方法，都只是将分类器进行简单的组合，实际上，并没有发挥出分类器组合的威力来。直到1989年，Yoav Freund与 Robert Schapire提出了一种可行的将弱分类器组合为强分类器的方法。并由此而获得了2003年的哥德尔奖（Godel price）。 Schapire还提出了一种早期的boosting算法，其主要过程如下： i)从样本整体集合D中，不放回的随机抽样n1 &lt; n 个样本，得到集合 D1 训练弱分类器C1 ii)从样本整体集合D中，抽取 n2 &lt; n 个样本，其中合并进一半被 C1 分类错误的样本。得到样本集合 D2 训练弱分类器C2 iii)抽取D样本集合中，C1 和 C2 分类不一致样本，组成D3 训练弱分类器C3 iv)用三个分类器做投票，得到最后分类结果 到了1995年，Freund and schapire提出了现在的adaboost算法，其主要框架可以描述为： i)循环迭代多次 更新样本分布 寻找当前分布下的最优弱分类器 计算弱分类器误差率 ii)聚合多次训练的弱分类器 现在，boost算法有了很大的发展，出现了很多的其他boost算法，例如：logitboost算法，gentleboost算法等等。我们将着重介绍adaboost算法的过程和特性。 5.Adaboost算法Adaboost算法能够进行实际应用的boosting算法。 Adaboost算法主要步骤： a.初始化样本的权值为1/n。 b.基于样本与权值训练弱分类器；这里的弱分类器就是个二分类器。 c.根据分类器对样本进行判别，如果判别正确，此样本的权值降低，判别错误，降低样本的权值，同时根据识别率计算出此分类器的权值。 d.利用改变权值的样本训练下一个分类器； e.循环得到N个分类器与其对应的权值； f.基于加权的分类器组合成为最终的模型。 Adaboost算法模型简单，不容易过拟合，无需调参，优点挺多。但是其实也是需要根据样本类型来使用。 Adaboost的特点 1）每次迭代改变的是样本的分布，而不是重复采样（re weight) 2）样本分布的改变取决于样本是否被正确分类 总是分类正确的样本权值低 总是分类错误的样本权值高（通常是边界附近的样本） 3）最终的结果是弱分类器的加权组合 权值表示该弱分类器的性能 Adaboost的优点: 1)adaboost是一种有很高精度的分类器 2)可以使用各种方法构建子分类器，adaboost算法提供的是框架 3)当使用简单分类器时，计算出的结果是可以理解的。而且弱分类器构造极其简单 4)简单，不用做特征筛选 5)不用担心overfitting！ 6.多分类Adaboost在日常任务中，我们通常需要去解决多分类的问题。而前面的介绍中，adaboost算法只能适用于二分类的情况。因此，在这一小节中，我们着重介绍如何将adaboost算法调整到适合处理多分类任务的方法。 目前有三种比较常用的将二分类adaboost方法: 1、adaboost M1方法 主要思路： adaboost组合的若干个弱分类器本身就是多分类的分类器。 在训练的时候，样本权重空间的计算方法不变，在解码的时候，选择一个最有可能的分类 2、adaboost MH方法 主要思路： 组合的弱分类器仍然是二分类的分类器，将分类label和分类样例组合，生成N个样本，在这个新的样本空间上训练分类器。 3、对多分类输出进行二进制编码 主要思路：对N个label进行二进制编码，例如用m位二进制数表示一个label。然后训练m个二分类分类器，在解码时生成m位的二进制数。从而对应到一个label上。 最后，我们可以总结下adaboost算法的一些实际可以使用的场景： 1）用于二分类或多分类的应用场景 2）用于做分类任务的baseline 无脑化，简单，不会overfitting，不用调分类器 3）用于特征选择（feature selection) 4）Boosting框架用于对badcase的修正 只需要增加新的分类器，不需要变动原有分类器 由于adaboost算法是一种实现简单，应用也很简单的算法。Adaboost算法通过组合弱分类器而得到强分类器，同时具有分类错误率上界随着训练增加而稳定下降，不会过拟合等的性质，应该说是一种很适合于在各种分类场景下应用的算法。 7.GBD误差函数的梯度。根据第一个模型可以写出对应的误差函数，通过最小化误差函数得到第一个模型的参数，此时再加入第二个模型，形成新的误差函数，此时模型一的参数已知了，通过最小化新的误差函数，得到第二个模型的参数。在每次得到的误差函数，对每个模型的参数的导数，为误差函数的梯度。 8.GBDTGBDT(Gradient Boosting Decision Tree) 又叫 MART（Multiple Additive Regression Tree)，是一种迭代的决策树算法，该算法由多棵决策树组成，所有树的结论累加起来做最终答案。它在被提出之初就和SVM一起被认为是泛化能力（generalization)较强的算法。近些年更因为被用于搜索排序的机器学习模型而引起大家关注。 GBDT主要由三个概念组成：Regression Decistion Tree（即DT)，Gradient Boosting（即GB)，Shrinkage (算法的一个重要演进分枝，目前大部分源码都按该版本实现）。搞定这三个概念后就能明白GBDT是如何工作的。 DT(回归树) 决策树分为两大类，回归树和分类树。GBDT中的树都是回归树，不是分类树。回归树总体流程也是类似，不过在每个节点（不一定是叶子节点）都会得一个预测值。 以年龄为例，该预测值等于属于这个节点的所有人年龄的平均值。分枝时穷举每一个feature的每个阈值找最好的分割点，但衡量最好的标准不再是最大熵，而是最小化均方差–即（每个人的年龄-预测年龄）^2 的总和 / N，或者说是每个人的预测误差平方和 除以 N。 GB(梯度迭代) GBDT的核心就在于，每一棵树学的是之前所有树结论和的残差，这个残差就是一个加预测值后能得真实值的累加量。 比如A的真实年龄是18岁，但第一棵树的预测年龄是12岁，差了6岁，即残差为6岁。那么在第二棵树里我们把A的年龄设为6岁去学习，如果第二棵树真的能把A分到6岁的叶子节点，那累加两棵树的结论就是A的真实年龄；如果第二棵树的结论是5岁，则A仍然存在1岁的残差，第三棵树里A的年龄就变成1岁，继续学。这就是Gradient Boosting在GBDT中的意义 那么哪里体现了Gradient呢？其实回到第一棵树结束时想一想，无论此时的cost function是什么，是均方差还是均差，只要它以误差作为衡量标准，残差向量(-1, 1, -1, 1)都是它的全局最优方向，这就是Gradient。 讲到这里我们已经把GBDT最核心的概念、运算过程讲完了！没错就是这么简单。不过讲到这里很容易发现三个问题： 1）使用回归决策树和GBDT有时最终效果相同，为何还需要GBDT呢？ 答案是过拟合。过拟合是指为了让训练集精度更高，学到了很多”仅在训练集上成立的规律“，导致换一个数据集当前规律就不适用了。其实只要允许一棵树的叶子节点足够多，训练集总是能训练到100%准确率的（大不了最后一个叶子上只有一个instance)。在训练精度和实际精度（或测试精度）之间，后者才是我们想要真正得到的。 2）Gradient呢？不是“G”BDT么？ 到目前为止，我们的确没有用到求导的Gradient。在当前版本GBDT描述中，的确没有用到Gradient，该版本用残差作为全局最优的绝对方向，并不需要Gradient求解. 3）这不是boosting吧？Adaboost可不是这么定义的。 这是boosting，但不是Adaboost。GBDT不是Adaboost Decistion Tree。就像提到决策树大家会想起C4.5，提到boost多数人也会想到Adaboost。Adaboost是另一种boost方法，它按分类对错，分配不同的weight，计算cost function时使用这些weight，从而让“错分的样本权重越来越大，使它们更被重视”。Bootstrap也有类似思想，它在每一步迭代时不改变模型本身，也不计算残差，而是从N个instance训练集中按一定概率重新抽取N个instance出来（单个instance可以被重复sample），对着这N个新的instance再训练一轮。由于数据集变了迭代模型训练结果也不一样，而一个instance被前面分错的越厉害，它的概率就被设的越高，这样就能同样达到逐步关注被分错的instance，逐步完善的效果。Adaboost的方法被实践证明是一种很好的防止过拟合的方法，但至于为什么则至今没从理论上被证明。GBDT也可以在使用残差的同时引入Bootstrap re-sampling，GBDT多数实现版本中也增加的这个选项，但是否一定使用则有不同看法。re-sampling一个缺点是它的随机性，即同样的数据集合训练两遍结果是不一样的，也就是模型不可稳定复现，这对评估是很大挑战，比如很难说一个模型变好是因为你选用了更好的feature，还是由于这次sample的随机因素。 Shrinkage(缩减) Shrinkage的思想认为，每次走一小步逐渐逼近结果的效果，要比每次迈一大步很快逼近结果的方式更容易避免过拟合。即它不完全信任每一个棵残差树，它认为每棵树只学到了真理的一小部分，累加的时候只累加一小部分，通过多学几棵树弥补不足。本质上，Shrinkage为每棵树设置了一个weight，累加时要乘以这个weight，但和Gradient并没有关系。这个weight就是step。就像Adaboost一样，Shrinkage能减少过拟合发生也是经验证明的，目前还没有看到从理论的证明。 9.GBDT的适用范围该版本GBDT几乎可用于所有回归问题（线性/非线性），相对logistic regression仅能用于线性回归，GBDT的适用面非常广。亦可用于二分类问题（设定阈值，大于阈值为正例，反之为负例）。 参考： http://baidutech.blog.51cto.com/4114344/743809/ http://blog.csdn.net/tianxiaguixin002/article/details/47701881 http://blog.csdn.net/w28971023/article/details/8240756]]></content>
      <categories>
        <category>分类算法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据挖掘导论-读书笔记]]></title>
    <url>%2F2016%2F12%2F28%2F2016-12-28-%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AF%BC%E8%AE%BA-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[0.概述数据挖掘导论涉及到的知识比较丰富,梳理下内容，为后面推荐系统设计做铺垫。 1.什么是数据挖掘数据挖掘是在大型数据存储库中，自动发现有用信息的过程。数据挖掘技术用来探测大型数据库，发现先前未知的有用模式。数据挖掘还可以预测未来观测结果，例如预测一位新的顾客是否会在一家百货公司消费100美元以上。 数据挖掘是数据库中知识发现(KDD)不可缺少的一部分，而KDD是将未加工的数据转换为有用信息的整个过程。 2.数据挖掘要解决的问题数据可伸缩，数据的高维性，异种数据和复杂数据，数据的所有权与分布，非传统的分析。 3.数据挖掘和其他领域之间的联系 4.数据挖掘任务1.预测任务。目标是根据其他属性的值，预测特定属性的值。被预测的属性一般称目标变量，而用来做预测的属性称说明变量。 2.描述任务。目标是导出概况数据中潜在联系的模式(相关、趋势、聚类、轨迹和异常)。 预测建模(predictive modeling):涉及以说明变量函数的方式为目标变量建立模型。有两类预测建模任务：分类(classification),用于预测离散的目标变量;回归(regression),用于预测连续的目标变量。 关联分析(association analysis):用来发现描述数据中强关联特征的模式。 聚类分析(cluster analysis):旨在发现紧密相关的观测值组群。 异常检测(anomaly detection):识别其特征显著不同于其他数据的观测值。这样的观测值称为异常点(anomaly)或离群点(outlier)。异常检测算法的目标是发现真正的异常点，而避免错误地将正常的对象标注为异常点。 5.分类分类法包括：决策树归纳，基于规则分类，最近邻分类，神经网络，支持向量机，朴素贝叶斯分类。 6.关联分析apriori算法,FP增长算法 7.聚类分析聚类类型：层次的与划分的，互斥的、重叠的与模糊的，完全的与部分的。 簇类型：明显分离的，基于原型的，基于图的，基于密度的，共同性质的(概念簇) 基于原型的算法：K均值，自组织映射(SOM)，期望最大化(EM), 基于密度的算法：DBSCAN,CLIQUE,DENCLUE 基于图的算法：MST(最小生成树)算法,Opossum算法,Chameleon算法,Jarvis-Patrick算法 凝聚的层次聚类:分两种产生层次聚类的方法：凝聚的，分裂的。 可伸缩的聚类:BIRCH,CURE 8.异常检测异常检测方法:基于模型的技术，基于临近度的技术，基于密度的技术，基于聚类的技术]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>数据挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[推荐系统比较重要的期刊和学术会议]]></title>
    <url>%2F2016%2F12%2F25%2F2016-12-25-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E6%9C%9F%E5%88%8A%E5%92%8C%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[0.概述关注最前沿的研究成果，是做好推荐系统的重要条件。 1.计算机国际学术会议和期刊目录中国计算机学会推荐国际学术会议和期刊目录 CCF是中国计算机学会推荐的比较好的会议和期刊目录，可以作为研究计算机领域问题比较好的参考资源列表。 dblp DBLP是计算机领域内对研究的成果以作者为核心的一个计算机类英文文献的集成数据库系统。按年代列出了作者的科研成果。包括国际期刊和会议等公开发表的论文。DBLP没有提供对中文文献的收录和检索功能，国内的权威期刊及重要会议的论文缺乏一个类似的集成检索系统。DBLP所收录的期刊和会议论文质量较高，DBLP的文献更新速度很快，很好地反应了国外学术研究的前沿方向。 这个项目是德国特里尔大学的Michael Ley负责开发和维护。它提供计算机领域科学文献的搜索服务，但只储存这些文献的相关元数据，如标题，作者，发表日期等。截至2009年7月已经有超过1,200,000文献。和一般流行的情况不同，DBLP并没有使用数据库而是使用XML存储元数据。 国内类似的权威期刊及重要会议论文集成检索系统有C-DBLP 文档下载:文档可以在dblp对应的view中链接的网址查看和下载论文，若给出的地址不能免费查看和下载可以使用百度学术来检索免费下载资源。 2.推荐系统相关的学术会议和重要论文paper：论文，journal：期刊，conference：会议。 RecSys是ACM主办的推荐系统旗舰会议，其征文范畴包含推荐系统的各个领域，包括算法设计、系统实现、理论推导和评估测试等。RecSys是推荐系统领域最好的专门会议，另外KDD、WWW和ICML跟推荐系统相关的track也属A+级别。 但是这个会议目前为止录用的论文质量参差不齐，除少数有影响力的论文之外，其它质量较一般，会议的reputation(声誉)和KDD、SIGIR、WWW，ICDM，甚至WSDM这些比肯定是差较多的，从参会的人就能看出来。另外目前CCF没有把它纳入推荐名单，这也是国内在这个会议上出现较少的原因吧。 重要论文： 1.综述： 1.Adomavicius G, Tuzhilin A. Toward the next generation of recommender systems: A survey of the state-of-the-art and possible extensions[J]. Knowledge and Data Engineering, IEEE Transactions on, 2005, 17(6): 734-749. 2005年的state-of-the-art的推荐综述，按照content-based, CF, Hybrid的分类方法进行组织，并介绍了推荐引擎设计时需要关注的特性指标，内容非常全。 2.Marlin B. Collaborative filtering: A machine learning perspective[D]. University of Toronto, 2004. 从传统机器学习的分类角度来介绍推荐算法，有一定机器学习背景的人来看该文章的话， 会觉得写得通俗易懂 3.Koren Y, Bell R. Advances in collaborative filtering[M]//Recommender Systems Handbook. Springer US, 2011: 145-186. RSs Handbook中专门讲述协同过滤的一章，其中对近年协同过滤的一些重要突破进行了介绍，包括因式分解，时间相关推荐，基于近邻的推荐以及多种方法的融合，内部不多，但其中引用的论文值得细看 4.Su X, Khoshgoftaar T M. A survey of collaborative filtering techniques[J]. Advances in artificial intelligence, 2009, 2009: 4. 协同过滤的篇survey， 按照memory-base, model-based, hybrid分类方法介绍各种协同过滤方法及评价标准，并在其中给出基于netflix数据进行评估的效果对比 5.Koren Y, Bell R, Volinsky C. Matrix factorization techniques for recommender systems[J]. Computer, 2009, 42(8): 30-37. 主要集中在因式分解实现协同过滤方法，如果看完Advances in collaborative filtering[M]//Recommender Systems Handbook的话，这篇文章就没有必要再看了 6.Pazzani M J, Billsus D. Content-based recommendation systems[M]//The adaptive web. Springer Berlin Heidelberg, 2007: 325-341.从宏观上介绍content-based的策略架构 2.Content-based方面的论文 content-based方法非常依赖于特定领域item的特征提取及处理，例如音乐推荐或是关键词推荐中很多细节内容信息处理过程都是不一样的，故这里仅列了content-based综述类的几篇文章。 1.Pazzani M J, Billsus D. Content-based recommendation systems[M]//The adaptive web. Springer Berlin Heidelberg, 2007: 325-341.从宏观上介绍content-based的策略架构 2.Lops P, de Gemmis M, Semeraro G. Content-based recommender systems: State of the art and trends[M]//Recommender Systems Handbook. Springer US, 2011: 73-105. RS Handbook中专门介绍content-based 算法的章节 3.Jannach D, Zanker M, Felfernig A, et al. Content-based recommendation [M] Charpter 3 Recommender systems: an introduction[M]. Cambridge University Press, 2010. 3.Collaborative Filtering方面的论文 Neighbourhood Based Methods 1.Sarwar B, Karypis G, Konstan J, et al. Item-based collaborative filtering recommendation algorithms[C]//Proceedings of the 10th international conference on World Wide Web. ACM, 2001: 285-295. KNN进行item-based推荐的经典文章，其中也介绍了多种相似度度量标准 2.Linden G, Smith B, York J. Amazon. com recommendations: Item-to-item collaborative filtering[J]. Internet Computing, IEEE, 2003, 7(1): 76-80. 经典的亚马逊item-based算法的文章 3.Gionis A, Indyk P, Motwani R. Similarity search in high dimensions via hashing[C]//VLDB. 1999, 99: 518-529. LSH 4.Bell R M, Koren Y. Scalable collaborative filtering with jointly derived neighborhood interpolation weights[C]//Data Mining, 2007. ICDM 2007. Seventh IEEE International Conference on. IEEE, 2007: 43-52. 5.Indyk P, Motwani R. Approximate nearest neighbors: towards removing the curse of dimensionality[C]//Proceedings of the thirtieth annual ACM symposium on Theory of computing. ACM, 1998: 604-613. LSH 6.Buhler J. Efficient large-scale sequence comparison by locality-sensitive hashing[J]. Bioinformatics, 2001, 17(5): 419-428. LSH应用 7.Chen T, Zheng Z, Lu Q, et al. Feature-based matrix factorization[J]. arXiv preprint arXiv:1109.2271, 2011.上交Apex实验室开发的svdfeature工具背后的原理。 优点是可以对照着代码学习 Model Based Methods 1.Koren Y, Bell R, Volinsky C. Matrix factorization techniques for recommender systems[J]. Computer, 2009, 42(8): 30-37.主要集中在因式分解实现协同过滤方法，如果看完Advances in collaborative filtering[M]//Recommender Systems Handbook的话，这篇文章就没有必要再看了 2.Singh A P, Gordon G J. A unified view of matrix factorization models[M]//Machine Learning and Knowledge Discovery in Databases. Springer Berlin Heidelberg, 2008: 358-373. Hybrid Methods 1.Koren Y. Factorization meets the neighborhood: a multifaceted collaborative filtering model[C]//Proceedings of the 14th ACM SIGKDD international conference on Knowledge discovery and data mining. ACM, 2008: 426-434. 因式分解与Neighbour-based方法融合 2.Burke R. Hybrid recommender systems: Survey and experiments[J]. User modeling and user-adapted interaction, 2002, 12(4): 331-370. 3.Burke R. Hybrid recommender systems: Survey and experiments[J]. User modeling and user-adapted interaction, 2002, 12(4): 331-370. 介绍了多种推荐算法进行融合的框架 3.参考内容Dustinsea]]></content>
      <categories>
        <category>学术会议</category>
      </categories>
      <tags>
        <tag>推荐系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[推荐系统比较-阿里RecEng、Amazon和开源EasyRrec]]></title>
    <url>%2F2016%2F12%2F23%2F2016-12-23-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%AF%94%E8%BE%83-%E9%98%BF%E9%87%8CRecEng%E3%80%81Amazon%E5%92%8C%E5%BC%80%E6%BA%90EasyRrec%2F</url>
    <content type="text"><![CDATA[0.概述研究了下阿里的RecEng、Amazon和开源EasyRec推荐系统，孰优孰劣,针对一个通用的推荐系统设计的方法是什么。 1.阿里推荐RecEng架构 离线计算的数据类型分为:接入数据、中间数据和输出数据三类。接入数据指客户离线提供的用户、物品、日志等数据，中间数据是在离线算法流程中产生的各种中间性质的结果数据表，输出数据是指推荐结果数据表，该结果最终将会被导入到在线存储中，供在线计算模块使用。 近线计算主要处理用户行为发生变化、推荐物品发生更新时，对离线推荐结果进行更新。近线程序的输入数据可以来自多个数据源，如在线的表格存储（原OTS），以及用户的API请求，又或者是程序中的变量；输出可以是程序变量，或者写回在线存储，或者返回给用户。 在线计算负责的任务是推荐API接收到API请求时，实时对离线和近线修正产生的推荐结果进行过滤、排重、补足等处理。 2.阿里推荐RecEng引擎流程 3.阿里推荐RecEng优缺点缺点：每个配置流程都很慢，依赖平台型太强。系统支持的推荐算法没有清晰的内部实现过程说明。 优点：配置度比较灵活，可以自定义模板和算法(但是成本太高，扩展性不太清楚,自定义算法手册没有找到)。和Amazon的架构有很多的相似处。架构理念正确。 4.Amazon推荐系统架构 系统被分为3部分， online，nearLine和离线部分(offLine)。Online和nearLine部分一起认为是实时部分。 离线部分就是传统的个性化推荐系统的主体，定期将大量存储的数据拿出来进行批处理运算，然后对模型进行建立与更新，这里就不详细介绍了。 nearLine部分，是将用户产生的事件，利用流式计算得到一些中间结果，这些中间结果一方面发送给online部分用于实时更新推荐模型，另一方面将中间结果存储起来，例如存储在MemCached、Cassandra、MySQL等可以快速查询的存储中作为备份。在NetFlix的系统中，他们的流式计算是通过一个叫做NetFlix.Manhattan来实现的，它是一个类似于Storm的实时流式计算框架，只是针对他们自己的应用有一定的特异性，不是通用的实时计算框架。 然后是online部分。这一部分利用离线部分的主体模型并考虑nearLine部分的实时数据对模型进行增量更新，然后可以得到一个实时的推荐模型，进而根据用户的行为来对用户进行实时推荐。 5.阿里RecEng和开源EasyRec的对比开源EasyRec是一个比较完整的推荐系统，内置已经实现的管理规则算法，插件话的开发模式，支持自定义插件和算法。但是属于半成品，itemitem,cf,svg等经典的推荐算法都没有完整实现，目前版本更新停止，整个系统是针对离线推荐做的，对在线推荐场景支持不到位，整个架构没有考虑到在线推荐的场景。但模块比较完整，报表，API等比较齐全。对企业自主研发推荐系统有很多借鉴的地方。架构方面可以和Amazon的做一个结合，在通用性方面已经比较完整。 个性化推荐系统架构的关键问题，就是如何以无缝方式实现在线和离线计算过程，说到底，也是算法的设计，如何将算法的计算步骤合理分配到各个部分，使得得到的模型既可以非常准确，又可以快速计算出来以满足实时性的要求。]]></content>
      <categories>
        <category>系统架构</category>
      </categories>
      <tags>
        <tag>推荐系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Duke-快速的相似数据过滤引擎]]></title>
    <url>%2F2016%2F12%2F20%2F2016-12-20-Duke-%E5%BF%AB%E9%80%9F%E7%9A%84%E7%9B%B8%E4%BC%BC%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[0.概述Duke是一个基于JAVA的快速灵活的重复数据过滤引擎。 1.实例假设我们正在处理一个客户资料数据库，并试图识别重复的客户记录。数据记录中有这样的三行数据： ID NAME ADDRESS ZIP EMAIL 1 J. Random Hacker Main St 101 21231 2 John Random Hacker Mian Street 101 21231 hack@gmail.com 3 Jacob Hacker Main Street 201 38122 jacob@hotmail.com 首先，Duke先从数据库中读取每条数据，并将数据记录转换为Duke记录对象。该过程中数据将被清洗。清洗后，数据如下： ID NAME ADDRESS ZIP EMAIL 1 j. random hacker main street 101 21231 2 john random hacker mian street 101 21231 hack@gmail.com 3 jacob hacker main street 201 38122 jacob@hotmail.com 然后，Duke将对记录做详细的比较，看看他们代表同一客户的可能性是多少？。我们使用以下配置： 12345678910111213141516171819202122232425262728293031&lt;schema&gt; &lt;threshold&gt;0.732&lt;/threshold&gt; &lt;property type="id"&gt; &lt;name&gt;ID&lt;/name&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;NAME&lt;/name&gt; &lt;comparator&gt;no.priv.garshol.duke.comparators.QGramComparator&lt;/comparator&gt; &lt;low&gt;0.35&lt;/low&gt; &lt;high&gt;0.88&lt;/high&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;ADDRESS1&lt;/name&gt; &lt;comparator&gt;address-comp&lt;/comparator&gt; &lt;low&gt;0.25&lt;/low&gt; &lt;high&gt;0.65&lt;/high&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;EMAIL&lt;/name&gt; &lt;comparator&gt;no.priv.garshol.duke.comparators.ExactComparator&lt;/comparator&gt; &lt;low&gt;0.4&lt;/low&gt; &lt;high&gt;0.8&lt;/high&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;ZIP&lt;/name&gt; &lt;comparator&gt;no.priv.garshol.duke.comparators.ExactComparator&lt;/comparator&gt; &lt;low&gt;0.45&lt;/low&gt; &lt;high&gt;0.6&lt;/high&gt; &lt;/property&gt; &lt;/schema&gt; 注意这个address-comp比较器，这是一个对象引用，通常，你可以用以下方式创建对象引用。然后在需要使用的地方引用就可以了。 12345678&lt;object class="no.priv.garshol.duke.comparators.WeightedLevenshtein$DefaultWeightEstimator" name="estimator"&gt; &lt;param name="digit-weight" value="10.0"/&gt;&lt;/object&gt;&lt;object class="no.priv.garshol.duke.comparators.WeightedLevenshtein" name="address-comp"&gt; &lt;param name="estimator" value="estimator"/&gt;&lt;/object&gt; 在上面的schema代码中，threshold(阀值)参数表示只有当概率为0.732(73.2%)或者更高时候，才能代表两个记录为同一事物。否则就认为这是两个不同的实物。含有忽略参数的属性将被忽略。 记录1和记录2的比较结果如下： 12345678910111213---ADDRESS1'main street 101' ~ 'mian street 101': 0.867 (prob 0.6127)Result: 0.5 -&gt; 0.6127---NAME'j. random hacker' ~ 'john random hacker': 0.8 (prob 0.78542)Result: 0.6127 -&gt; 0.8527---ZIP'21231' ~ '21231': 1.0 (prob 0.6)Result: 0.8527 -&gt; 0.8967Overall: 0.8967 如果我们比较记录1和3，结果是不同的： 12345678910111213---ADDRESS1'main street 101' ~ 'main street 201': 0.73 (prob 0.58)Result: 0.5 -&gt; 0.58---NAME'j. random hacker' ~ 'jacob hacker': 0.6 (prob 0.64)Result: 0.58 -&gt; 0.71---ZIP'21231' ~ '38122': 0.0 (prob 0.45)Result: 0.71 -&gt; 0.67Overall: 0.67 我希望这有助于说明Duke如何权衡来自不同领域的证据，并利用它来达成裁决。 参考地址:https://github.com/larsga/Duke/wiki]]></content>
      <categories>
        <category>Duke</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web架构基础-四部件]]></title>
    <url>%2F2016%2F12%2F17%2F2016-12-17-Web%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80-%E5%9B%9B%E9%83%A8%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[0.概述架构基础知识是需要对Web的运行周期有一个完整的掌握，才能在此基础上做技术上的架构设计。 1.Web底层学习资料servlet/filter/listener/interceptor区别与联系 http://www.cnblogs.com/doit8791/p/4209442.html Spring中ApplicationContext加载机制和配置初始化 http://zhangzhenting.iteye.com/blog/1827777 Spring MVC之MultiActionController http://blog.csdn.net/q3498233/article/details/6703101 SpringMVC 4.2.2 - Web.xml,Dispatcher-Servlet及ApplicationContext配置笔记 http://blog.csdn.net/chendev1/article/details/50294381 ApplicationContext http://blog.csdn.net/sinodragon21/article/details/25842667 Spring 的监听事件 ApplicationListener 和 ApplicationEvent 用法 http://blog.csdn.net/ilovejava_2010/article/details/7953419]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>Servlet3.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习算法-相似度-CosineSimilarity(余弦相似度)]]></title>
    <url>%2F2016%2F11%2F30%2F2016-11-30-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E7%9B%B8%E4%BC%BC%E5%BA%A6-CosineSimilarity(%E4%BD%99%E5%BC%A6%E7%9B%B8%E4%BC%BC%E5%BA%A6)%2F</url>
    <content type="text"><![CDATA[0.概述余弦相似度用向量空间中两个向量夹角的余弦值作为衡量两个个体间差异的大小。相比距离度量，余弦相似度更加注重两个向量在方向上的差异，而非距离或长度上。 1.余弦相似度描述 与欧几里德距离类似，基于余弦相似度的计算方法也是把用户的喜好作为n-维坐标系中的一个点，通过连接这个点与坐标系的原点构成一条直线（向量），两个用户之间的相似度值就是两条直线（向量）间夹角的余弦值。因为连接代表用户评分的点与原点的直线都会相交于原点，夹角越小代表两个用户越相似，夹角越大代表两个用户的相似度越小。同时在三角系数中，角的余弦值是在[-1, 1]之间的，0度角的余弦值是1，180角的余弦值是-1。 2.欧氏距离和余弦相似度的区别 从图上可以看出距离度量衡量的是空间各点间的绝对距离，跟各个点所在的位置坐标（即个体特征维度的数值）直接相关；而余弦相似度衡量的是空间向量的夹角，更加的是体现在方向上的差异，而不是位置。如果保持A点的位置不变，B点朝原方向远离坐标轴原点，那么这个时候余弦相似度cosθ是保持不变的，因为夹角不变，而A、B两点的距离显然在发生改变，这就是欧氏距离和余弦相似度的不同之处。 根据欧氏距离和余弦相似度各自的计算方式和衡量特征，分别适用于不同的数据分析模型：欧氏距离能够体现个体数值特征的绝对差异，所以更多的用于需要从维度的数值大小中体现差异的分析，如使用用户行为指标分析用户价值的相似度或差异；而余弦相似度更多的是从方向上区分差异，而对绝对的数值不敏感，更多的用于使用用户对内容评分来区分用户兴趣的相似度和差异，同时修正了用户间可能存在的度量标准不统一的问题（因为余弦相似度对绝对数值不敏感）。 3.调整余弦相似度——AdjustedCosineSimilarity在余弦相似度的介绍中说到：余弦相似度更多的是从方向上区分差异，而对绝对的数值不敏感。因此没法衡量每个维数值的差异，会导致这样一个情况：比如用户对内容评分，5分制，X和Y两个用户对两个内容的评分分别为(1,2)和(4,5)，使用余弦相似度得出的结果是0.98，两者极为相似，但从评分上看X似乎不喜欢这2个内容，而Y比较喜欢，余弦相似度对数值的不敏感导致了结果的误差，需要修正这种不合理性，就出现了调整余弦相似度，即所有维度上的数值都减去一个均值，比如X和Y的评分均值都是3，那么调整后为(-2,-1)和(1,2)，再用余弦相似度计算，得到-0.8，相似度为负值并且差异不小，但显然更加符合现实。]]></content>
      <categories>
        <category>相似度算法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习算法-相似度-JaccardSimilarityCoefficient(杰卡德相似系数)]]></title>
    <url>%2F2016%2F11%2F30%2F2016-11-30-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E7%9B%B8%E4%BC%BC%E5%BA%A6-JaccardSimilarityCoefficient(%E6%9D%B0%E5%8D%A1%E5%BE%B7%E7%9B%B8%E4%BC%BC%E7%B3%BB%E6%95%B0)%2F</url>
    <content type="text"><![CDATA[0.概述两个集合A和B的交集元素在A，B的并集中所占的比例，称为两个集合的杰卡德相似系数，用符号J(A,B)表示。杰卡德相似系数是衡量两个集合的相似度一种指标。与杰卡德相似系数相反的概念是杰卡德距离(Jaccard distance)。杰卡德距离可用如下公式表示：1-J(A,B) 1.公式 2.Octave实例]]></content>
      <categories>
        <category>相似度算法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习算法-相似度-HammingDistance(汉明距离)]]></title>
    <url>%2F2016%2F11%2F30%2F2016-11-30-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E7%9B%B8%E4%BC%BC%E5%BA%A6-HammingDistance(%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB)%2F</url>
    <content type="text"><![CDATA[0.概述两个等长字符串s1与s2之间的汉明距离定义为将其中一个变为另外一个所需要作的最小替换次数。例如字符串“1111”与“1001”之间的汉明距离为2。 1.应用场景信息编码（为了增强容错性，应使得编码间的最小汉明距离尽可能大）。 2.Octave实例]]></content>
      <categories>
        <category>相似度算法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习算法-相似度-MahalanobisDistance(马氏距离)]]></title>
    <url>%2F2016%2F11%2F30%2F2016-11-30-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E7%9B%B8%E4%BC%BC%E5%BA%A6-MahalanobisDistance(%E9%A9%AC%E6%B0%8F%E8%B7%9D%E7%A6%BB)%2F</url>
    <content type="text"><![CDATA[0.概述马氏距离是由印度统计学家马哈拉诺比斯提出的，表示数据的协方差距离。它是一种有效的计算两个未知样本集的相似度的方法。与欧氏距离不同的是它考虑到各种特征之间的联系，即独立于测量尺度。 1.马氏距离公式设总体G为m维总体(考察m个指标),均值向量为μ，协方差矩阵为S,则样品X=(x1,x2,…xm)’与总体G的马氏距离定义为: 向量Xi与Xj之间的马氏距离定义为： 若协方差矩阵是单位矩阵（各个样本向量之间独立同分布）,则公式就成了： 若协方差矩阵是对角矩阵，公式变成了标准化欧氏距离。 2.马氏距离可视化 3.优缺点马氏距离和量纲(尺寸)无关，排除变量之间的相关性干扰。]]></content>
      <categories>
        <category>相似度算法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习算法-相似度-SpearmanCorrelationSimilarity(皮尔斯曼相关系数相似度)]]></title>
    <url>%2F2016%2F11%2F30%2F2016-11-30-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E7%9B%B8%E4%BC%BC%E5%BA%A6-SpearmanCorrelationSimilarity(%E7%9A%AE%E5%B0%94%E6%96%AF%E6%9B%BC%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0%E7%9B%B8%E4%BC%BC%E5%BA%A6)%2F</url>
    <content type="text"><![CDATA[0.概述皮尔斯曼相关度的计算舍弃了一些重要信息，即真实的评分值。但它保留了用户喜好值的本质特性——排序（ordering），它是建立在排序（或等级，Rank）的基础上计算的。 1.皮尔斯曼相关性描述皮尔斯曼相关性可以理解为是排列后（Rank）用户喜好值之间的Pearson相关度。《Mahout in Action》中有这样的解释：假设对于每个用户，我们找到他最不喜欢的物品，重写他的评分值为“1”；然后找到下一个最不喜欢的物品，重写评分值为“2”，以此类推。然后我们对这些转换后的值求Pearson相关系数，这就是Spearman相关系数。 2.举例User1～5对Item101～103的喜好（评分）值，通过斯皮尔曼相关系数计算出的相似度为： 我们发现，计算出来的相似度值要么是1，要么是-1，因为这依赖于用户的喜好值和User1的喜好值是否趋于“一致变化”还是呈“相反趋势变化”。 Mahout对斯皮尔曼相关系数给出了实现，具体可参考SpearmanCorrelationSimilarity，它的执行效率不是非常高，因为斯皮尔曼相关性的计算需要花时间计算并存储喜好值的一个排序（Ranks），具体时间取决于数据的数量级大小。正因为这样，斯皮尔曼相关系数一般用于学术研究或者是小规模的计算。 代码： 考虑到Spearman Correlation的效率，可以把SpearmanCorrelationSimilarity包装一层Cache，具体做法为： UserSimilarity similarity2 = new CachingUserSimilarity(new SpearmanCorrelationSimilarity(model), model); 这样，每次计算的结果会直接放入Cache，下一次计算的时候可以立即得到结果，而不是重新再计算一次。]]></content>
      <categories>
        <category>相似度算法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习算法-相似度-PearsonCorrelationSimilarity(皮尔森相似度)]]></title>
    <url>%2F2016%2F11%2F30%2F2016-11-30-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E7%9B%B8%E4%BC%BC%E5%BA%A6-PearsonCorrelationSimilarity(%E7%9A%AE%E5%B0%94%E6%A3%AE%E7%9B%B8%E4%BC%BC%E5%BA%A6)%2F</url>
    <content type="text"><![CDATA[0.概述皮尔森相关系数反应了两个变量之间的线性相关程度，它的取值在[-1, 1]之间。当两个变量的线性关系增强时，相关系数趋于1或-1；当一个变量增大，另一个变量也增大时，表明它们之间是正相关的，相关系数大于0；如果一个变量增大，另一个变量却减小，表明它们之间是负相关的，相关系数小于0；如果相关系数等于0，表明它们之间不存在线性相关关系。 1.皮尔森相似度描述用数学公式表示，皮尔森相关系数等于两个变量的协方差除于两个变量的标准差。 2.协方差(Covariance)在概率论和统计学中用于衡量两个变量的总体误差。如果两个变量的变化趋于一致，也就是说如果其中一个大于自身的期望值，另一个也大于自身的期望值，那么两个变量之间的协方差就是正值；如果两个变量的变化趋势相反，则协方差为负值。 其中u表示X的期望E(X), v表示Y的期望E(Y) 3.标准差(Standard Deviation)标准差是方差的平方根 4.方差(Variance)在概率论和统计学中，一个随机变量的方差表述的是它的离散程度，也就是该变量与期望值的距离。即方差等于误差的平方和的期望 5.缺点基于皮尔森相关系数的相似度有两个缺点： (1) 没有考虑（take into account）用户间重叠的评分项数量对相似度的影响； (2) 如果两个用户之间只有一个共同的评分项，相似度也不能被计算 上表中，行表示用户（1～5）对项目（101～103）的一些评分值。直观来看，User1和User5用3个共同的评分项，并且给出的评分走差也不大，按理他们之间的相似度应该比User1和User4之间的相似度要高，可是User1和User4有一个更高的相似度1。 同样的场景在现实生活中也经常发生，比如两个用户共同观看了200部电影，虽然不一定给出相同或完全相近的评分，他们之间的相似度也应该比另一位只观看了2部相同电影的相似度高吧！但事实并不如此，如果对这两部电影，两个用户给出的相似度相同或很相近，通过皮尔森相关性计算出的相似度会明显大于观看了相同的200部电影的用户之间的相似度。 Mahout对基于皮尔森相关系数的相似度给出了实现，它依赖一个DataModel作为输入。 同时，Mahout还针对缺点(1)进行了优化，只需要在构造PearsonCorrelationSimilarity时多传入一个Weighting.WEIGHTED参数，就能使有更多相同评分项目的用户之间的相似度更趋近于1或-1。 UserSimilarity similarity1 = new PearsonCorrelationSimilarity(model); double value1 = similarity1.userSimilarity(1, 5); UserSimilarity similarity2 = new PearsonCorrelationSimilarity(model, Weighting.WEIGHTED); double value2 = similarity2.userSimilarity(1, 5); 结果： Similarity of User1 and User5: 0.944911182523068 Similarity of User1 and User5 with weighting: 0.9655694890769175]]></content>
      <categories>
        <category>相似度算法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习算法-相似度-TanimotoCoefficientSimilarity(谷本系数相似度)]]></title>
    <url>%2F2016%2F11%2F29%2F2016-11-29-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E7%9B%B8%E4%BC%BC%E5%BA%A6-TanimotoCoefficientSimilarity(%E8%B0%B7%E6%9C%AC%E7%B3%BB%E6%95%B0%E7%9B%B8%E4%BC%BC%E5%BA%A6)%2F</url>
    <content type="text"><![CDATA[0.概述它不关心用户对物品的具体评分值是多少，它在关心用户与物品之间是否存在关联关系。Tanimoto Coefficient依赖于用户和物品之间的这种Boolean关系作为输入。 1.谷本系数描述Tanimoto Coefficient主要用于计算符号度量或布尔值度量的个体间的相似度，因为个体的特征属性都是由符号度量或者布尔值标识，因此无法衡量差异具体值的大小，只能获得“是否相同”这个结果，所以Tanimoto Coefficient只关心个体间共同具有的特征是否一致这个问题。Tanimoto Coefficient又被叫做Jaccard Coefficient，其值等于两个用户共同关联（不管喜欢还是不喜欢）的物品数量除于两个用户分别关联的所有物品数量。 其值介于[0, 1]之间，如果两个用户关联的物品完全相同，交集等于并集，值为1；如果没有任何关联，交集为空，值为0。]]></content>
      <categories>
        <category>相似度算法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习算法-相似度-MinkowskiDistance(闵可夫斯基距离)]]></title>
    <url>%2F2016%2F11%2F28%2F2016-11-28-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E7%9B%B8%E4%BC%BC%E5%BA%A6-MinkowskiDistance(%E9%97%B5%E5%8F%AF%E5%A4%AB%E6%96%AF%E5%9F%BA%E8%B7%9D%E7%A6%BB)%2F</url>
    <content type="text"><![CDATA[0.概述距离计算中，非常常用的是欧几里得距离，和欧几里得距离相似的还有曼哈顿距离，切比雪夫距离，这些算法都是从闵可夫斯基距离演变出来的。 1.闵可夫斯基距离计算公式 2.图形化展示 3.闵可夫斯基距离的缺点 4.欧式距离公式推导 5.二维平面中闵可夫斯基图像展示]]></content>
      <categories>
        <category>相似度算法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习算法-聚类-K-Means(K均值)]]></title>
    <url>%2F2016%2F11%2F27%2F2016-11-27-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E8%81%9A%E7%B1%BB-K-Means(K%E5%9D%87%E5%80%BC)%2F</url>
    <content type="text"><![CDATA[0.概述无监督学习和监督学习的区别是，无监督学习使用一个未标记的训练集，而监督学习使用的是一个标记的训练集。换句话说，我们没有一个预期结果的向量，只有一个可以找到结构的特征数据集。 无监督学习可以适用于以下领域: 1.市场细分 2.社会网络分析 3.组织计算机集群 4.天文数据分析 1.K-Means(K-均值)k-均值算法是自动分组数据到相干子集问题中使用最流行和最广泛的算法。 1.在数据集中随机初始化两个点。(称为聚类中心)。 2.群集分配：根据当前例子距离哪个聚类中心最近，将所有的例子都分配到两个组中的一个。 3.移动聚类中心：计算两个聚类中心组内的所有点的平均值，然后将聚类中心点移动到这些平均值的位置上。 4.重复运行2,3步骤，直到找到我们的聚类。 我们使用的几个主要变量是: 1.K(聚类的数量) 2.训练集(x1,x2,…xm) 3.xi属于实数 注意：我们不使用x0=1这个参数。经过若干次的迭代，算法将会收敛，一旦收敛后，在新的迭代中不会影响现有的集群。 关于非分离聚类的注记：一些数据集没有真正的内分离或自然结构。k-均值仍然可以将您的数据均匀地分割成K个子集，因此在这种情况下仍然有用。 2.代价函数 3.初始化和簇的数目 4.降维(Dimensionality Reduction) 5.主成分分析(Principal Component Analysis)问题描述 6.PCA算法 7.解压缩数据 8.选择主成分的数量 9.使用PCA的建议]]></content>
      <categories>
        <category>聚类算法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习算法-分类-SVM(支持向量机)]]></title>
    <url>%2F2016%2F11%2F25%2F2016-11-25-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E5%88%86%E7%B1%BB-SVM(%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA)%2F</url>
    <content type="text"><![CDATA[0.概述SVM(支持向量机)是另一种监督机器学习算法。它有时更清洁，更强大。 1.逻辑回归和SVM对比 2.大边距分类器(Large Margin Classifiers) 3.核(Kernels) 4.参数选择和多分类 5.SVM和LogisticRegression选择对比]]></content>
      <categories>
        <category>分类算法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习算法-分类-NeuralNetwork(神经网络)]]></title>
    <url>%2F2016%2F11%2F24%2F2016-11-24-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E5%88%86%E7%B1%BB-NeuralNetwork(%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C)%2F</url>
    <content type="text"><![CDATA[0.概述当我们面对一个有许多特征和复杂假设函数的问题时，神经网络提供了一种替代的方式来执行机器学习。例如，对拥有大量像素的图片进行分类识别时，大量的特征值(每个像素)和复杂的假设函数(特征值的N次方组合)使其它监督学习算法执行效率和表现上都不太良好,神经网络能够提供一个高效的学习模型。 1.假设函数 2.代价函数 3.向后传播 4.向后传播-实现 5.向前-向后传播示意图 6.其他]]></content>
      <categories>
        <category>分类算法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习算法-回归-梯度下降(GradientDescent)]]></title>
    <url>%2F2016%2F11%2F23%2F2016-11-23-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E5%9B%9E%E5%BD%92-%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D(GradientDescent)%2F</url>
    <content type="text"><![CDATA[0.概述回归分析（regression analysis)是确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法。运用十分广泛，回归分析按照涉及的变量的多少，分为一元回归和多元回归分析；在线性回归中，按照因变量的多少，可分为简单回归分析和多重回归分析；按照自变量和因变量之间的关系类型，可分为线性回归分析和非线性回归分析。如果在回归分析中，只包括一个自变量和一个因变量，且二者的关系可用一条直线近似表示，这种回归分析称为一元线性回归分析。如果回归分析中包括两个或两个以上的自变量，且自变量之间存在线性相关，则称为多元线性回归分析。 在统计学中，线性回归(Linear Regression)是利用称为线性回归方程的最小平方函数对一个或多个自变量和因变量之间关系进行建模的一种回归分析。这种函数是一个或多个称为回归系数的模型参数的线性组合。只有一个自变量的情况称为简单回归,大于一个自变量情况的叫做多元回归。线性回归的主要问题是参数估计。 1.单参数-LinearRegression(线性回归)Hypothesis Function(假设函数): Cost Function(代价函数): Gradient Descent(梯度下降算法): 重复执行，直至收敛 Gradient Descent for Linear Regression(针对线性回归的梯度下降算法): 2.多参数-LinearRegression(线性回归)Hypothesis Function(假设函数): 向量化表示: 多训练集下： 对应的假设函数: Cost Function(代价函数): Gradient Descent for Multiple Linear Regression(针对多参数线性回归的梯度下降算法): Normal Equation(正规方程): 正规方程是从最小二乘法(矩阵形式)推导过来的，其本质是对代价函数求导，让导数等于0即可求极值，得到最优参数。 3.参数估计算法概述参数估计是指在已知系统模型结构时，用系统的输入和输出数据计算系统模型参数的过程。18世纪末德国数学家C.F.高斯首先提出参数估计的方法，他用最小二乘法计算天体运行的轨道。20世纪60年代，随着电子计算机的普及，参数估计有了飞速的发展。参数估计有多种方法，有矩估计、极大似然法、一致最小方差无偏估计、最小风险估计、同变估计、最小二乘法、贝叶斯估计、极大验后法、最小风险法和极小化极大熵法等。最基本的方法是最小二乘法和极大似然法。 最小二乘法的目标：求误差的最小平方和，对应有两种：线性和非线性。线性最小二乘的解是closed-form即，而非线性最小二乘没有closed-form，通常用迭代法求解。 迭代法，即在每一步update未知量逐渐逼近解，可以用于各种各样的问题（包括最小二乘），比如求的不是误差的最小平方和而是最小立方和。梯度下降是迭代法的一种，可以用于求解最小二乘问题（线性和非线性都可以）。高斯-牛顿法是另一种经常用于求解非线性最小二乘的迭代法（一定程度上可视为标准非线性最小二乘求解方法）。 还有一种叫做Levenberg-Marquardt的迭代法用于求解非线性最小二乘问题，就结合了梯度下降和高斯-牛顿法。]]></content>
      <categories>
        <category>回归算法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习算法-分类-LogisticRegression(逻辑回归)]]></title>
    <url>%2F2016%2F11%2F23%2F2016-11-23-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95-%E5%88%86%E7%B1%BB-LogisticRegression(%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92)%2F</url>
    <content type="text"><![CDATA[0.概述监督学习问题分为“回归”(regression)和“分类”(classification)问题。LinearRegression(线性回归)属于”回归”问题，而LogisticRegression(逻辑回归)属于”分类”问题。 1.LogisticRegression(逻辑回归)现在我们正在从回归问题切换到分类问题。不要被“逻辑回归”的名字混淆，它被命名为历史原因的方法，实际上是一种分类问题的方法，而不是回归问题。 Sigmoid Function(S函数): 我们的假设应该满足： 逻辑回归的假设函数： 针对分类问题，当假设函数预测的值达到一定概率后就判定为指定类别，预测值为: Decision Boundary(决策边界): 决策边界控制分类的界限，当预测函数值大于0.5就分类为1，当预测函数的值小于0.5就分类为0。针对S函数，当S函数中的X大于0是S函数就结果就大于0.5，相反则小于0.5。0.5就是决策边界，改变这个边界将影响到分类的结果。 当边界为0.5时，在逻辑函数里面就是假设函数为0的情况。 Cost Function(代价函数): 对数函数模型: 代价函数分析: 精简版代价函数: 向量化: Gradient Descent(梯度下降): 多分类:One-vs-all 我们先是选择一类，然后将所有的其它分到一个单一的二类。我们这样做是反复的，对每一种情况下应用二元逻辑回归，然后使用返回的最高值作为我们的预测的假设 2.Regularization(正则化)正则化是设计来解决过度拟合的问题。 正则化线性回归-梯度下降 正则化逻辑回归-代价函数 正则化逻辑回归-梯度下降 3.广义线性模型逻辑回归与多重线性回归实际上有很多相同之处，最大的区别就在于它们的因变量不同，其他的基本都差不多。正是因为如此，这两种回归可以归于同一个家族，即广义线性模型（generalizedlinear model）。 这一家族中的模型形式基本上都差不多，不同的就是因变量不同。 1.如果是连续的，就是多重线性回归； 2.如果是二项分布，就是Logistic回归； 3.如果是Poisson分布，就是Poisson回归； 4.如果是负二项分布，就是负二项回归。 Logistic回归的因变量可以是二分类的，也可以是多分类的，但是二分类的更为常用，也更加容易解释。所以实际中最常用的就是二分类的Logistic回归。 Logistic回归的主要用途： 寻找危险因素：寻找某一疾病的危险因素等； 预测：根据模型，预测在不同的自变量情况下，发生某病或某种情况的概率有多大； 判别：实际上跟预测有些类似，也是根据模型，判断某人属于某病或属于某种情况的概率有多大，也就是看一下这个人有多大的可能性是属于某病。 Logistic回归主要在流行病学中应用较多，比较常用的情形是探索某疾病的危险因素，根据危险因素预测某疾病发生的概率，等等。例如，想探讨胃癌发生的危险因素，可以选择两组人群，一组是胃癌组，一组是非胃癌组，两组人群肯定有不同的体征和生活方式等。这里的因变量就是是否胃癌，即“是”或“否”，自变量就可以包括很多了，例如年龄、性别、饮食习惯、幽门螺杆菌感染等。自变量既可以是连续的，也可以是分类的。]]></content>
      <categories>
        <category>分类算法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习算法总览表]]></title>
    <url>%2F2016%2F11%2F22%2F2016-11-22-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E6%80%BB%E8%A7%88%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[0.概述机器学习包含了许多的算法和设计规则，掌握这些算法对机器学习的设计和改善将会有很大的帮助。参考内容有Standford大学的NG老师的公开课machine-learning以及自己收集的一些算法介绍资料。 下面是常用算法列表，分类，聚类，相似度常用的算法。我会对每一个算法进行概述在以后的系列文章中。 1.算法列表分类算法： 1.LogisticRegression(逻辑回归) 2.NeuralNetwork(神经网络) 3.SVM(支持向量机) 4.Bayesian(朴素贝叶斯) 5.HMM(隐含马尔科夫模型) 6.DecisionForest(决策森林) 7.RandomForests(随机森林) 8.Perceptron(感知器算法) 9.RestrictedBoltzmannMachines(有限波尔兹曼) 10.KNN(K邻近) 聚类算法： 1.K-meansClustering(K均值算法) 2.FuzzyK-means(模糊K均值) 3.CanopyClustering(Canopy聚类) 4.LatentDirichletAllocation(LDA聚类) 5.SpectralClustering(谱聚类) 6.ExpectationMaximization(期望最大化聚类) 7.MeanShiftClustering(均值漂移聚类) 8.HierarchicalClustering(层次聚类) 9.DirichletProcessClustering(狄利克雷过程聚类) 相似度算法： 1.EuclideanDistance(欧几里得距离相似度) 2.ManhattanDistance(曼哈顿距离相似度) 3.ChebyshevDistance(切比雪夫距离相似度) 4.MinkowskiDistance(闵可夫斯基距离相似度) 5.MahalanobisDistance(马氏距离) 6.UncenteredCosineSimilarity(余弦相似度) 7.PearsonCorrelationSimilarity(皮尔森相似度) 8.SpearmanCorrelationSimilarity(皮尔斯曼相关系数相似度) 9.LogLikelihoodSimilarity(对数似然相似度) 10.TanimotoCoefficientSimilarity(谷本系数相似度) 11.HammingDistance(汉明距离) 12.JaccardSimilarityCoefficient(杰卡德相似系数) 13.CorrelationCoefficient(相关系数)与CorrelationDistance(相关距离) 14.InformationEntropy(信息熵) 2.机器学习概述Tom Mitchell 给机器学习一个明确的定义: “A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E.” 一般来说，任何机器学习问题可以分为两大分类:Supervised Learning(监督学习)和Unsupervised Learning(无监督学习). Supervised Learning(监督学习): 在监督学习中，我们给出了一个数据集，已经知道我们的正确的输出应该是什么样子的，输入和输出之间有一定关系。 监督学习问题分为“回归”(regression)和“分类”(classification)问题。在一个回归问题中，我们试图预测结果在一个连续的输出，这意味着我们正在试图将输入变量映射到一些连续函数。在一个分类问题中，我们试图预测结果在一个离散的输出。换句话说，我们正在试图将输入变量映射到离散的类别中。这是关于连续数据和离散数据的数学描述。 Unsupervised Learning(无监督学习): 无监督学习，使我们能够在很少或根本不知道我们的研究结果应该是什么样的情况下。从数据中获得结构，尽管我们不一定知道变量之间的关系。我们可以根据这种结构化的聚类数据，得出数据中变量之间的关系。 无监督学习，对预测结果没有任何反馈，也就是说，没有老师纠正你的结果。 3.机器学习笔记网上看到有人把NG老师的课程做成笔记的形式，可以回顾下学习的内容，不错。记到这里了。 知乎-机器学习笔记]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ROC曲线生成器]]></title>
    <url>%2F2016%2F09%2F22%2F2016-09-22-ROC%E6%9B%B2%E7%BA%BF%E7%94%9F%E6%88%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[0.概述ROC（Receiver Operating Characteristic）曲线和AUC常被用来评价一个二值分类器（binary classifier）的优劣，ROC和AUC介绍以及如何计算AUC这篇博文简单介绍ROC和AUC的特点，以及更为深入地，讨论如何作出ROC曲线图以及计算AUC。但该文中只介绍ROC曲线生成的方法，没有对具体的实现细节做说明，了解实现的细节将是对理论的最好证明。 1.ROC曲线生成公式: 测试数据集: ROC曲线: 代码实现: 代码输出:]]></content>
      <categories>
        <category>文本挖掘</category>
      </categories>
      <tags>
        <tag>ROC曲线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[均值公式推导]]></title>
    <url>%2F2016%2F09%2F21%2F2016-09-21-%E5%9D%87%E5%80%BC%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[0.概述均值算法在机器学习中应用的比较多，使用的时候直接是公式，若对其中的推导过程不熟悉则会很疑惑，为什么要这样计算，下面就是详细的推导过程。 1.一个算法问题已知：现有均值midle,现有次数:simples 输入：新值 输出：新的均值 以上是一个算法的基本描述，求计算新的均值公式。 Java代码： 2.mahout中的使用在mahout中评测分类效果的Auc类中，有一段将分类概率的均值更新到变量中就是使用的是该公式，注意新的值是Math.log1p(-limited) - v0) ，该值中的log1p(-limited)是指ln(1-limited)，转换为自然对数的形式。]]></content>
      <categories>
        <category>文本挖掘</category>
      </categories>
      <tags>
        <tag>均值算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中英文词性表]]></title>
    <url>%2F2016%2F09%2F15%2F2016-09-15-%E4%B8%AD%E8%8B%B1%E6%96%87%E8%AF%8D%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[0.概述中文词性和英文词性表，方便查阅。 1.中英文词性表英文词性表： 中文词性表：]]></content>
      <categories>
        <category>推荐</category>
      </categories>
      <tags>
        <tag>文本挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet配置总结]]></title>
    <url>%2F2016%2F08%2F20%2F2016-08-20-Servlet%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[0.概述Servlet在web.xml中的配置总结，对Servlet的生命周期和加载顺序的熟悉将会对系统架构有很大的帮助。 1.Servlet是什么Servlet 通过创建一个框架来扩展服务器的能力，以提供在 Web 上进行请求和响应服务。当客户机发送请求至服务器时，服务器可以将请求信息发送给 Servlet，并让 Servlet 建立起服务器返回给客户机的响应。 当启动 Web 服务器或客户机第一次请求服务时，可以自动装入 Servlet。装入后， Servlet 继续运行直到其它客户机发出请求。Servlet 的功能涉及范围很广。例如，Servlet 可完成如下功能： (1) 创建并返回一个包含基于客户请求性质的动态内容的完整的 HTML页面。 (2) 创建可嵌入到现有 HTML 页面中的一部分 HTML 页面（HTML 片段）。 (3) 与其它服务器资源（包括数据库和基于 Java 的应用程序）进行通信。 (4) 用多个客户机处理连接，接收多个客户机的输入，并将结果广播到多个客户机上。例如，Servlet 可以是多参与者的游戏服务器。 (5) 当允许在单连接方式下传送数据的情况下，在浏览器上打开服务器至applet的新连接，并将该连接保持在打开状态。当允许客户机和服务器简单、高效地执行会话的情况下，applet也可以启动客户浏览器和服务器之间的连接。可以通过定制协议或标准（如 IIOP）进行通信。 (6) 对特殊的处理采用 MIME 类型过滤数据，例如图像转换和服务器端包括（SSI）。 (7) 将定制的处理提供给所有服务器的标准例行程序。例如，Servlet 可以修改如何认证用户。 2.Servlet的配置Servlet的配置是在web.xml中，与该配置相关的节点有filter,listener,context-param等。context-param，它用于向 ServletContext 提供键值对，即应用程序上下文信息。我们的 listener, filter 等在初始化时会用到这些上下文中的信息，正确的加载顺序为：context-param -&gt; listener -&gt; filter -&gt; servlet。 对于某类配置节而言，与它们出现的顺序是有关的。以 filter 为例，web.xml 中当然可以定义多个 filter，与 filter 相关的一个配置节是 filter-mapping，这里一定要注意，对于拥有相同 filter-name 的 filter 和 filter-mapping 配置节而言，filter-mapping 必须出现在 filter 之后，否则当解析到 filter-mapping 时，它所对应的 filter-name 还未定义。web 容器启动时初始化每个 filter 时，是按照 filter 配置节出现的顺序来初始化的，当请求资源匹配多个 filter-mapping 时，filter 拦截资源是按照 filter-mapping 配置节出现的顺序来依次调用 doFilter() 方法的。 3.Filter的功能filter功能，它使用户可以改变一个 request和修改一个response. Filter 不是一个servlet,它不能产生一个response,它能够在一个request到达servlet之前预处理request,也可以在离开 servlet时处理response.换种说法,filter其实是一个”servlet chaining”(servlet 链). 一个Filter包括：1）、在servlet被调用之前截获;2）、在servlet被调用之前检查servlet request;3）、根据需要修改request头和request数据;4）、根据需要修改response头和response数据;5）、在servlet被调用之后截获. 4.listener的功能它是基于观察者模式设计的，Listener 的设计对开发 Servlet 应用程序提供了一种快捷的手段，能够方便的从另一个纵向维度控制程序和数据。目前 Servlet 中提供了 5 种两类事件的观察者接口，它们分别是：4 个 EventListeners 类型的，ServletContextAttributeListener、ServletRequestAttributeListener、ServletRequestListener、HttpSessionAttributeListener 和 2 个 LifecycleListeners 类型的，ServletContextListener、HttpSessionListener。如下图所示： Listener是Servlet的监听器，它可以监听客户端的请求、服务端的操作等。通过监听器，可以自动激发一些操作，比如监听在线的用户的数量。当增加一个HttpSession时，就激发sessionCreated(HttpSessionEvent se)方法，这样就可以给在线人数加1。 常用的监听接口有以下几个： ServletContextAttributeListener监听对ServletContext属性的操作，比如增加、删除、修改属性。 ServletContextListener监听ServletContext。当创建ServletContext时，激发contextInitialized(ServletContextEvent sce)方法；当销毁ServletContext时，激发contextDestroyed(ServletContextEvent sce)方法。 HttpSessionListener监听HttpSession的操作。当创建一个Session时，激发session Created(HttpSessionEvent se)方法；当销毁一个Session时，激发sessionDestroyed (HttpSessionEvent se)方法。 HttpSessionAttributeListener监听HttpSession中的属性的操作。当在Session增加一个属性时，激发attributeAdded(HttpSessionBindingEvent se) 方法；当在Session删除一个属性时，激发attributeRemoved(HttpSessionBindingEvent se)方法；当在Session属性被重新设置时，激发attributeReplaced(HttpSessionBindingEvent se) 方法。 5.web.xml文件详解Web.xml常用元素]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>Servlet3.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker常用指令备忘录]]></title>
    <url>%2F2016%2F07%2F22%2F2016-07-22-Docker%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E5%A4%87%E5%BF%98%E5%BD%95%2F</url>
    <content type="text"><![CDATA[0.概述Docker常用的指令，方便以后查找 1.查看镜像docker images 2.拉取镜像docker pull &lt;镜像名:tag&gt; #从官网拉取镜像 docker search &lt;镜像名&gt; #搜索在线可用镜像名 3.查看容器docker ps #查看正在运行的容器 docker ps -l #查看最后退出的容器的ID docker ps -a #查看所有的容器，包括退出的。 docker start [PID] //启动停止的容器 docker stop [PID] //停止运行的容器 docker kill [PID] //杀死容器 4.设置后台运行容器docker run -d -i –name zkServer -p 2181:2181 index.tenxcloud.com/sdvdxl/zookeeper -d :后台运行 –name：设置容器名称 -p：设置端口对应 -i:保持输入流开放即使没有附加输入流 -t=false:分配一个伪造的终端输入 5.删除容器与删除镜像docker rm$(docker ps -a -q) #删除所有容器 docker rm &lt;容器名or ID&gt; #删除单个容器 docker rmi #删除单个镜像 docker rmi$(docker images | grep none | awk ‘{print $3}’ | sort -r) 6.进入容器docker attach [ID或名称] 可以attach到一个已经运行的容器的stdin，然后进行命令执行的动作。但是需要注意的是，如果从这个stdin中exit，会导致容器的停止。 docker exec -it [ID或名称] /bin/sh 只使用-i时，由于没有分配伪终端，看起来像pipe执行一样。但是执行结果、命令返回值都可以正确获取。 只使用-t参数，则可以看到一个console窗口，但是执行命令会发现由于没有获得stdin的输出，无法看到命令执行情况。 使用-it时，则和我们平常操作console界面类似。而且也不会像attach方式因为退出，导致整个容器退出。这种方式可以替代ssh或者nsenter、nsinit方式，在容器内进行操作。 7.常见错误端口映射配置前需要确保iptables服务开启 若遇到以下错误:COMMAND_FAILED: ‘/sbin/iptables -t nat -A DOCKER -p tcp -d 0/0 –dport 8111 -j DNAT –to-destination 172.17.0.6:8111 ! -i docker0’ failed: iptables: No chain/target/match by that name. 执行以下操作: service docker stop iptables -t nat -F ifconfig docker0 down brctl delbr docker0 service docker start 8.Dockerfile构建命令从fesaDockerFile中构建容器 docker build -t fesa:latest - &lt; fesaDockerFile]]></content>
      <categories>
        <category>Docker指令</category>
      </categories>
      <tags>
        <tag>备忘录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[推荐场景1-推荐用户已购买的内容]]></title>
    <url>%2F2016%2F07%2F22%2F2016-07-22-%E6%8E%A8%E8%8D%90%E5%9C%BA%E6%99%AF1-%E6%8E%A8%E8%8D%90%E7%94%A8%E6%88%B7%E5%B7%B2%E8%B4%AD%E4%B9%B0%E7%9A%84%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[0.概述推荐场景中，存在给用户推荐自己已经购买的商品，其实用户对自己购买过的商品基本上不会再去买了，没有挖掘出用户的下一步诉求，就不能引导用户进行新的尝试。用户买过手机后我们可以在推荐列表中去放入用户下一步可能要买的商品，比如说：耳机，充电器，其他品牌的手机。不要把用户买过的商品大量的放入推荐列表中，转换效果不好，用户点击欲望也不会高。 1.购物场景用户买了手机套，给用户的推荐结果是手机套，手机套，手机套。。。其实我们应该让用户看到其他和手机套的相关的内容，而不是一味的去推荐已经购买的商品。推荐系统应该要自己猜测到用户其实是拥有一部什么样牌子的手机，用户的年龄是多少？用户的购物能力有多高？可以给用户推荐一些其他领域的商品。]]></content>
      <categories>
        <category>用户场景</category>
      </categories>
      <tags>
        <tag>推荐系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[推荐系统建设流程]]></title>
    <url>%2F2016%2F07%2F20%2F2016-07-20-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%BB%BA%E8%AE%BE%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[0.概述推荐系统的三要素：推荐内容，推荐算法，推荐流程。 1.图解]]></content>
      <categories>
        <category>系统架构</category>
      </categories>
      <tags>
        <tag>推荐系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字签名过程图解]]></title>
    <url>%2F2016%2F06%2F28%2F2016-06-28-%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E8%BF%87%E7%A8%8B%E5%9B%BE%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[0.概述常见的对称加密:DES,AES。常见的非对称加密:RSA,DSA。常见的不可逆加密:MD5等。 1.图解]]></content>
      <categories>
        <category>加密解密</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mahout构建推荐系统-相似度算法]]></title>
    <url>%2F2016%2F06%2F13%2F2016-06-13-Mahout%E6%9E%84%E5%BB%BA%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E7%9B%B8%E4%BC%BC%E5%BA%A6%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[0.概述Mahout中包含了相似度、邻间，推荐算法。了解每种算法的原来和使用场景对构建推荐系统非常有必要。 1.类图相似度类图： 邻居类图： 推荐类图:]]></content>
      <categories>
        <category>相似度算法</category>
      </categories>
      <tags>
        <tag>推荐系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存模型与线程同步问题整理]]></title>
    <url>%2F2016%2F04%2F15%2F2016-04-15-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[0.概述对高并发程序编写需要对JAVA内存模型有一个清晰的认识。以下是整理的JAVA内存模型和线程的相关内容，内容转自互联网。 1.硬件的效率与一致性由于计算机的存储设备与处理器的运算能力之间有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中没这样处理器就无需等待缓慢的内存读写了。 基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是引入了一个新的问题：缓存一致性（Cache Coherence）。在多处理器系统中，每个处理都有自己的高速缓存，而他们又共享同一主存，如下图所示：多个处理器运算任务都涉及同一块主存，需要一种协议可以保障数据的一致性，这类协议有MSI、MESI、MOSI及Dragon Protocol等。Java虚拟机内存模型中定义的内存访问操作与硬件的缓存访问操作是具有可比性的，后续将介绍Java内存模型。 除此之外，为了使得处理器内部的运算单元能竟可能被充分利用，处理器可能会对输入代码进行乱起执行（Out-Of-Order Execution）优化，处理器会在计算之后将对乱序执行的代码进行结果重组，保证结果准确性。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有类似的指令重排序（Instruction Recorder）优化。 2.Java内存模型定义Java内存模型并不是一件容易的事情，这个模型必须定义得足够严谨，才能让Java的并发操作不会产生歧义；但是，也必须得足够宽松，使得虚拟机的实现能有足够的自由空间去利用硬件的各种特性（寄存器、高速缓存等）来获取更好的执行速度。经过长时间的验证和修补，在JDK1.5发布后，Java内存模型就已经成熟和完善起来了。 2.1 主内存与工作内存 Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样底层细节。此处的变量与Java编程时所说的变量不一样，指包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，后者是线程私有的，不会被共享。 Java内存模型中规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存（可以与前面将的处理器的高速缓存类比），线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成，线程、主内存和工作内存的交互关系如下图所示，和上图很类似。 这里的主内存、工作内存与Java内存区域的Java堆、栈、方法区不是同一层次内存划分。 2.2 内存间交互操作关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成： • lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。 • unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 • read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用 • load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。 • use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。 • assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 • store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。 • write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。 如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。也就是read和load之间，store和write之间是可以插入其他指令的，如对主内存中的变量a、b进行访问时，可能的顺序是read a，read b，load b， load a。Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则： • 不允许read和load、store和write操作之一单独出现 • 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。 • 不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。 • 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。 • 一个变量在同一时刻只允许一条线程对其进行lock操作，lock和unlock必须成对出现 • 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值 • 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。 •对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。 2.3 重排序在执行程序时为了提高性能，编译器和处理器经常会对指令进行重排序。重排序分成三种类型： 1.编译器优化的重排序。编译器在不改变单线程程序语义放入前提下，可以重新安排语句的执行顺序。 2.指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。 3.内存系统的重排序。由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。 从Java源代码到最终实际执行的指令序列，会经过下面三种重排序： 为了保证内存的可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。Java内存模型把内存屏障分为LoadLoad、LoadStore、StoreLoad和StoreStore四种： 2.4 线程同步的方法介绍volatile、synchronized和final 2.5 多线程并发的三个特性分别为“原子性”、“可见性”、“有序性”三个特性。 原子性 原子性是指不可再分的最小操作指令，即单条机器指令，原子性操作任意时刻只能有一个线程，因此是线程安全的。 Java内存模型中通过read、load、assign、use、store和write这6个操作保证变量的原子性操作。 long和double这两个64位长度的数据类型java虚拟机并没有强制规定他们的read、load、store和write操作的原子性，即所谓的非原子性协定，但是目前的各种商业java虚拟机都把long和double数据类型的4中非原子性协定操作实现为原子性。所以java中基本数据类型的访问读写是原子性操作。 对于大范围的原子性保证需要通过lock和unlock操作以及synchronized同步块来保证。 可见性 可见性是指当一个线程修改了共享变量的值，其他线程可以立即得知这个修改。 Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。 Java中通过volatile、final和synchronized这三个关键字保证可见性： volatile：通过刷新变量值确保可见性。 synchronized：同步块通过变量lock锁定前必须清空工作内存中变量值，重新从主内存中读取变量值，unlock解锁前必须把变量值同步回主内存来确保可见性。 final：被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把this引用传递进去，那么在其他线程中就能看见final字段的值，无需同步就可以被其他线程正确访问。 有序性 线程的有序性是指：在线程内部，所有的操作都是有序执行的，而在线程之间，因为工作内存和主内存同步的延迟，操作是乱序执行的。 Java通过volatile和synchronized关键字确保线程之间操作的有序性。 volatile禁止指令重排序优化实现有序性。 synchronized通过一个变量在同一时刻只允许一个线程对其进行lock锁定操作来确保有序性。 2.6 线程实现的三种方式内核线程（Kernal thread） 内核线程（Kernel Thread， KLT）就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操作调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程（Light Weight Process，LWP），轻量级进程就是我们通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。这种轻量级进程与内核线程之间1：1的关系称为一对一的线程模型。轻量级进程要消耗一定的内核资源（如内核线程的栈空间），而且系统调用的代价相对较高，因此一个系统支持轻量级进程的数量是有限的。 轻量级用户进程（Light weight process） 广义上来讲，一个线程只要不是内核线程，那就可以认为是用户线程（User Thread，UT），而狭义的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知到线程存在的实现，用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。如果程序实现得当，这种线程不需要切换到内核态，因此操作可以是非常快速且低消耗的，也可以支持规模更大的线程数量，部分高性能数据库中的多线程就是由用户线程实现的。这种进程与用户线程之间1：N的关系称为一对多的线程模型。（Windows和Linux使用的是这种方式） 使用用户线程的优势在于不需要系统内核的支援，劣势在于没有系统内核的支援，所有的线程操作都需要用户程序自己处理，因而使用用户线程实现的程序一般都比较复杂，现在使用用户线程的程序越来越少了。 用户线程/混合线程（User thread） 既存在用户线程，又存在轻量级进程。用户线程还是完全建立在用户空间中，而操作系统所支持的轻量级进程则作为用户线程和内核线程之间的桥梁。这种混合模式下，用户线程与轻量级进程的数量比是不定的，是M：N的关系。许多Unix系列的系统，都提供了M：N的线程模型实现。 2.7 线程调度Java线程在JDK1.2之前，是基于名为“绿色线程”的用户线程实现的，而在JDK1.2中，线程模型被替换为基于操作系统原生线程模型来实现。因此，在目前的JDK版本中，操作系统支持怎样的线程模型，在很大程度上就决定了Java虚拟机的线程是怎样映射的，这点在不同的平台上没有办法达成一致，虚拟机规范中也未限定Java线程需要使用哪种线程模型来实现。 线程调度有两种方式 协同式：线程的执行时间由线程本身来控制，线程任务执行完成之后主动通知系统切换到另一个线程去执行。（ 不推荐） 优点：实现简单，线程切换操作对线程本身是可知的，不存在线程同步问题。 缺点：线程执行时间不可控制，如果线程长时间执行不让出CPU执行时间可能导致系统崩溃。 抢占式：每个线程的执行时间有操作系统来分配，操作系统给每个线程分配执行的时间片，抢到时间片的线程执行，时间片用完之后重新抢占执行时间，线程的切换不由线程本身来决定（ Java使用的线程调度方式就是抢占式调度）。 优点：线程执行时间可控制，不会因为一个线程阻塞问题导致系统崩溃 2.8 线程安全等级不可变： 可以是基本类型的final；可以是final对象，但对象的行为不会对其状态产生任何影响，比如String的subString就是new一个String对象各种Number类型如BigInteger和BigDecimal等大数据类型都是不可变的，但是同为Number子类型的AtomicInteger和AtomicLong则并非不可变。原因与它里面状态对象是unsafe对象有关，所做的操作都是CAS操作，可以保证原子性。 绝对线程安全： 不管运行时环境如何，调用者都不需要任何额外的同步措施。 相对线程安全： 这是我们通常意义上的线程安全。需要保证对象单独的操作是线程安全的。比如Vector，HashTable，synchronizedCollection包装集合等。 线程兼容： 对象本身不是线程安全的，但可以通过同步手段实现。一般我们说的不是线程安全的，绝大多数是指这个。比如ArrayList，HashMap等。 线程对立： 不管调用端是否采用了同步的措施，都无法在并发中使用的代码。 2.9 线程安全的实现方式互斥同步 在多线程访问的时候，保证同一时间只有一条线程使用。 临界区(Critical Section)，互斥量(Mutex)，信号量(Semaphore)都是同步的一种手段 java里最基本的互斥同步手段是synchronized，编译之后会形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象，还有一个锁的计数器，来记录加锁的次数，加锁几次就要同样解锁几次才能恢复到无锁状态。 其实在“Java与线程”里已经提到，java的线程是映射到操作系统的原生线程之上的，不管阻塞还是唤醒都需要操作系统的帮忙完成，都需要从用户态转换到核心态，这是很耗费时间的，是java语言中的一个重量级(Heavyweight)操作，虽然虚拟机本身会做一点优化的操作，比如通知操作系统阻塞之前会加一段自旋等待的过程，避免频繁切换到核心态。 ReentrantLock相比于synchronized的优势：等待可中断：在持有锁的线程长时间不释放锁的时候,等待的线程可以选择放弃等待.公平锁：按照申请锁的顺序来一次获得锁称为公平锁.synchronized的是非公平锁,ReentrantLock可以通过构造函数实现公平锁. new RenentrantLock(boolean fair)锁绑定多个条件：通过多次newCondition可以获得多个Condition对象,可以简单的实现比较复杂的线程同步的功能.通过await(),signal(); 非阻塞同步 互斥和同步最主要的问题就是阻塞和唤醒所带来的性能问题，所以这通常叫阻塞同步(悲观的并发策略)。随着硬件指令集的发展，我们有另外的选择：基于冲突检测的乐观并发策略，通俗讲就是先操作，如果没有其他线程争用共享的数据，操作就成功，如果有，则进行其他的补偿(最常见就是不断的重试)，这种乐观的并发策略许多实现都不需要把线程挂起，这种同步操作被称为非阻塞同步。 这类的指令有： 1)测试并设置(test-and-set) 2)获取并增加 3)交换 4)比较并交换(CAS) 5)加载链接/条件储存(Load-Linked/Store-Conditional LL/SC) 后面两条是现代处理器新增的处理器指令，在JDK1.5之后，java中才可以使用CAS操作，就是传说中的sun.misc.Unsafe类里面的compareAndSwapInt()和compareAndSwapLong()等几个方法的包装提供，虚拟机对这些方法做了特殊的处理，及时编译出来的结果就是一条平台相关的处理器CAS指令，没有方法调用的过程，可以认为是无条件的内联进去。 原来需要对i++进行同步，但现在有了这种CAS操作来保证原子性，比如用AtomicInteger。 但是CAS存在一个ABA的问题。可以通过AtomicStampedReference来解决（鸡肋）。 无同步 有一些代码天生就是线程安全的，不需要同步。其中有如下两类： 可重入代码（Reentrant Code）：纯代码，具有不依赖存储在堆上的数据和公用的系统资源，用到的状态量都由参数中传入，不调用非可重入的方法等特征，它的返回结果是可以预测的。 线程本地存储（Thread Local Storage）：把共享数据的可见范围限制在同一个线程之内，这样就无须同步也能保证线程之间不出现数据争用问题。可以通过java.lang.ThreadLocal类来实现线程本地存储的功能。 2.10 锁机制悲观锁 假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。悲观锁假定其他线程企图访问或者改变你正在访问、更改的对象的概率是很高的，因此在悲观锁的环境中，在你开始改变此对象之前就将该对象锁住，并且直到你提交了所作的更改之后才释放锁。 乐观锁 假设不会发生并发冲突。轻易不加锁。 自旋锁与自适应自旋 线程挂起和恢复的操作都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的压力，在许多应用中，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得，可以让后请求锁的线程等待一会儿，但不放弃处理器的执行时间，让线程执行一个忙循环（自旋）。 自旋锁默认的自旋次数值是10次，可以使用参数-XX:PreBlockSpin更改。 自适应自旋意味着自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。 锁清除： 虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持。 锁粗化： 如果虚拟机探测到有一系列连续操作都对同一个对象反复加锁和解锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。 锁升级 Java SE1.6为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在Java SE1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。 偏向锁 Hotspot的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要花费CAS操作来加锁和解锁，而只需简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁，如果测试成功，表示线程已经获得了锁，如果测试失败，则需要再测试下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁），如果没有设置，则使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。 偏向锁的撤销：偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态，如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。下图中的线程1演示了偏向锁初始化的流程，线程2演示了偏向锁撤销的流程。 关闭偏向锁：偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟-XX：BiasedLockingStartupDelay = 0。如果你确定自己应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁-XX:-UseBiasedLocking=false，那么默认会进入轻量级锁状态。 轻量级锁： 轻量级锁加锁：线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。 轻量级锁解锁：轻量级解锁时，会使用原子的CAS操作来将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。下图是两个线程同时争夺锁，导致锁膨胀的流程图。 因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。 重量级锁： 重量锁在JVM中又叫对象监视器（Monitor），它至少包含一个竞争锁的队列，和一个信号阻塞队列（wait队列），前者负责做互斥，后一个用于做线程同步。 偏向锁轻量级锁概念参考文章： http://www.infoq.com/cn/articles/java-se-16-synchronized]]></content>
      <categories>
        <category>JVM高级特性</category>
      </categories>
      <tags>
        <tag>内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[互联网团队技术-新浪微博]]></title>
    <url>%2F2016%2F04%2F10%2F2016-04-10-%E4%BA%92%E8%81%94%E7%BD%91%E5%9B%A2%E9%98%9F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84-%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A%2F</url>
    <content type="text"><![CDATA[0.概述新浪微博的技术分享。 1.微博技术介绍新浪微博：http://weibo.com/timyangTimYang站点-后端技术 http://timyang.net/category/architecture/微信号：高可用架构]]></content>
      <categories>
        <category>互联网团队技术</category>
      </categories>
      <tags>
        <tag>新浪微博</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK源码分析之IO类汇总]]></title>
    <url>%2F2016%2F04%2F08%2F2016-04-08-JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BIO%E7%B1%BB%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[0.概述JDK中包含的IO类的梳理，对IO操作有一个全面的认识，在JDK中IO操作还有一个包NIO。都是对IO的操作，但是实现的原理还是不一样的。 1.类图]]></content>
      <categories>
        <category>JAVA源码</category>
      </categories>
      <tags>
        <tag>IO类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK源码分析之并发类汇总]]></title>
    <url>%2F2016%2F04%2F08%2F2016-04-08-JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%B1%BB%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[0.概述JDK中包含的并发类的梳理。主要集中在java.util.concurrent包中。 1.类图]]></content>
      <categories>
        <category>JAVA源码</category>
      </categories>
      <tags>
        <tag>并发类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK源码分析之集合类汇总]]></title>
    <url>%2F2016%2F04%2F04%2F2016-04-04-JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E9%9B%86%E5%90%88%E7%B1%BB%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[0.概述JAVA中包含了好多集合类，这些类在我们日常开发中非常重要，这些类主要集中在java.util包中，熟悉和掌握这些类的使用和原理，对我们提高代码质量非常重要。 1.类图 2.总结http://www.cnblogs.com/linjiqin/archive/2013/05/30/3107785.html http://www.cnblogs.com/devinzhang/archive/2012/01/25/2329434.html http://www.cnblogs.com/end/archive/2012/10/25/2738493.html]]></content>
      <categories>
        <category>JAVA源码</category>
      </categories>
      <tags>
        <tag>Collection集合类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSO解决方案汇总]]></title>
    <url>%2F2016%2F03%2F14%2F2016-03-14-SSO%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[0.概述SSO英文全称Single Sign On（单点登录）。SSO是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。它包括可以将这次主要的登录映射到其他应用中用于同一个用户的登录的机制。它是目前比较流行的企业业务整合的解决方案之一. 随着SSO技术的流行，SSO的产品也是满天飞扬。所有著名的软件厂商都提供了相应的解决方案。常见的开源解决方案有：JA-SIG CAS、OpenSSO、JOSSO、Passport.js、Atlassian Crowd、GodAuth等。商业解决方案有Tivoli、Siteminder、RSA Secure SSO等。商业产品的安全性和用户体验比开源的相对来说比较好点。但是接触最多的还属于开源的方案。 基本上SSO的实现分为3类：基于WEB的WEB SSO、基于Windows域的桌面SSO、SAML(Security Assertion Markup Language安全断言标记语言)。 1.SSO原理1.1 SSO体系中的角色 1.User （多个） 2.Web 应用（多个） 3.SSO 认证中心（ 1 个 ） 1.2 SSO 实现模式的原则 1.所有的认证登录都在 SSO 认证中心进行； 2.SSO 认证中心通过一些方法来告诉 Web 应用当前访问用户究竟是不是已通过认证的用户； 3.SSO 认证中心和所有的 Web 应用建立一种信任关系，也就是说 web 应用必须信任认证中心。（单点信任） 1.3 SSO 主要实现方式 1.共享 cookies 基于共享同域的 cookie 是 Web 刚开始阶段时使用的一种方式，它利用浏览同域名之间自动传递 cookies 机制，实现两个域名之间系统令牌传递问题；另外，关于跨域问题，虽然 cookies本身不跨域，但可以利用它实现跨域的 SSO 。如：代理、暴露 SSO 令牌值等。 缺点：不灵活而且有不少安全隐患，已经被抛弃。 2.Broker-based(基于经纪人) 这种技术的特点就是，有一个集中的认证和用户帐号管理的服务器。经纪人给被用于进一步请求的电子身份存取。中央数据库的使用减少了管理的代价，并为认证提供一个公共和独立的 “第三方 “ 。例如 Kerberos 、 Sesame 、 IBM KryptoKnight （凭证库思想 ) 等。 Kerberos是由麻省理工大学发明的安全认证服务，已经被 UNIX 和 Windows 作为默认的安全认证服务集成进操作系统。 3.Agent-based(基于代理人) 在这种解决方案中，有一个自动地为不同的应用程序认证用户身份的代理程序。这个代理程序需要设计有不同的功能。比如，它可以使用口令表或加密密钥来自动地将认证的负担从用户移开。代理人被放在服务器上面，在服务器的认证系统和客户端认证方法之间充当一个 “ 翻译 “。例如 SSH 等。 4.Token-based 例如 SecureID,WebID ，现在被广泛使用的口令认证，比如 FTP 、邮件服务器的登录认证，这是一种简单易用的方式，实现一个口令在多种应用当中使用。 5.基于网关 在网关处实现身份认证。 6.基于SAML SAML(Security Assertion Markup Language ，安全断言标记语言）的出现大大简化了 SSO ，并被 OASIS 批准为 SSO 的执行标准 。开源组织 OpenSAML 实现了 SAML 规范。 2.SSO开源解决方案-CAS概述CAS(Central Authentication Service) 是 Yale 大学发起的一个开源项目，据统计使用开源SSO方案的大部分选择CAS，CAS简单高效并且足够安全。这也是本文介绍的主角。 2.1 CAS的特征: 开源的、多协议:支持的协议包括 Custom Protocol 、 CAS 、 OAuth 、 OpenID 、 RESTful API 、 SAML1.1 、 SAML2.0 等。 支持多种认证机制： Active Directory 、 JAAS 、 JDBC 、 LDAP 、 X.509 Certificates 等。 安全策略：使用票据(Ticket)来实现支持的认证协议。 支持授权:可以决定哪些服务可以请求和验证服务票据(Service Ticket)。 高可用性支持：通过把认证过的状态数据存储在 TicketRegistry 组件中，这些组件有很多支持分布式环境的实现，如： BerkleyDB 、 Default 、 EhcacheTicketRegistry 、 JDBCTicketRegistry 、 JBOSS TreeCache 、 JpaTicketRegistry 、 MemcacheTicketRegistry 等。 支持多种客户端: Java 、 .Net 、 PHP 、 Perl 、 Apache, uPortal 等。 2.2 CAS的结构体系从结构体系看， CAS 包括两部分： CAS Server 和 CAS Client 。 CAS Server CAS Server 负责完成对用户的认证工作 , 需要独立部署 , CAS Server 会处理用户名 / 密码等凭证(Credentials) 。 CAS Client 负责处理对客户端受保护资源的访问请求，需要对请求方进行身份认证时，重定向到 CAS Server 进行认证。（原则上，客户端应用不再接受任何的用户名密码等 Credentials ）。CAS Client 与受保护的客户端应用部署在一起，以 Filter 方式保护受保护的资源。 2.3 CAS原理和协议CAS协议是由Drew Mazurek编写，最新版本为3.0.1，发布时间为:2015-01-13。 从 CAS v1 到现在的 CAS v3 ，整个协议的基础思想都是基于 Kerberos 的票据方式。 CAS v1 非常原始，传送一个用户名居然是 ”yes”ndavid.turing” 的方式， CAS v2 开始使用了 XML 规范，大大增强了可扩展性， CAS v3 开始使用 AOP 技术，让 Spring 爱好者可以轻松配置 CAS Server 到现有的应用环境中。 CAS 是通过 TGT(Ticket Granting Ticket) 来获取 ST(Service Ticket) ，通过 ST 来访问服务，而 CAS 也有对应 TGT ， ST 的实体，而且他们在保护 TGT 的方法上虽然有所区别，但是，最终都可以实现这样一个目的——免去多次登录的麻烦。 CAS协议分为基础模式和代理模式两种。 CAS协议官方规范 2.3.1 基础模式的认证过程： CAS服务端控制台日志： 2.3.2 代理模式的认证过程： 3.CAS安全性CAS 的安全性仅仅依赖于 SSL，使用的是 secure cookie，CAS 协议从几个方面让认证变得更加安全。 有关CAS安全特性，请看CAS v4 安全手册 3.1 TGC/PGT 安全性对于一个 CAS 用户来说，最重要是要保护它的 TGC ，如果 TGC 不慎被 CAS Server 以外的实体获得， Hacker 能够找到该 TGC ，然后冒充 CAS 用户访问 所有 授权资源。 PGT 的角色跟 TGC 是一样的。 从基础模式可以看出， TGC 是 CAS Server 通过 SSL 方式发送给终端用户，因此，要截取 TGC 难度非常大，从而确保 CAS 的安全性。 TGT 的存活周期默认为 120 分钟。 3.2 ST/PT 安全性ST （ Service Ticket ）是通过 Http 传送的，因此网络中的其他人可以 Sniffer 到其他人的 Ticket 。 CAS 通过以下几方面来使 ST 变得更加安全（事实上都是可以配置的）： 1、ST 只能使用一次 CAS 协议规定，无论 Service Ticket 验证是否成功， CAS Server 都会清除服务端缓存中的该Ticket ，从而可以确保一个 Service Ticket 不被使用两次。 2、ST 在一段时间内失效 CAS 规定 ST 只能存活一定的时间，然后 CAS Server 会让它失效。默认有效时间为 5 分钟。 3、ST 是基于随机数生成的 ST 必须足够随机，如果 ST 生成规则被猜出， Hacker 就等于绕过 CAS 认证，直接访问 对应的服务。]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>单点登录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双高配置之Nginx+Keepalived整理]]></title>
    <url>%2F2016%2F03%2F13%2F2016-03-13-%E5%8F%8C%E9%AB%98%E9%85%8D%E7%BD%AE%E4%B9%8BNginx%2BKeepalived%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[0.概述前几天发的一篇”系统架构总结之高可用高负载”文章里面讲到的双高策略，里面包含的详细配置，在这里整理出来以做备忘。 1.Nginx安装版本:1.9.11 依赖pcre-8.38.tar.gz 安装: ./configure --with-pcre=/aclome/pcre-8.38 --prefix=/aclome/nginx Make Make install 配置负载策略: http{ ...... upstream myServer{ server 199.31.165.61:8080; server 199.31.165.62:8080; } server{ listen 8001; location / { root html; index index.html index.htm; proxy_pass http://myServer; } } ...... } 启动 /sbin/nginx 停止 ps -ef |grep nginx kill -9 &lt;pid&gt; 访问 http://199.31.165.61:8001 可以在61:8080和62:8080之间跳转 nginx的upstream目前支持的5种方式的分配 1、轮询（默认） 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。 upstream backserver { server 192.168.0.14; server 192.168.0.15; } 2、weight 指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 upstream backserver { server 192.168.0.14 weight=10; server 192.168.0.15 weight=10; } 3、ip_hash 每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 upstream backserver { ip_hash; server 192.168.0.14:88; server 192.168.0.15:80; } 4、fair（第三方） 按后端服务器的响应时间来分配请求，响应时间短的优先分配。 upstream backserver { server server1; server server2; fair; } 5、url_hash（第三方） 按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 upstream backserver { server squid1:3128; server squid2:3128; hash $request_uri; hash_method crc32; } 在需要使用负载均衡的server中增加 proxy_pass http://backserver/ ; upstream backserver{ ip_hash; server 127.0.0.1:9090 down; (down 表示单前的server暂时不参与负载) server 127.0.0.1:8080 weight=2; (weight 默认为1.weight越大，负载的权重就越大) server 127.0.0.1:6060; server 127.0.0.1:7070 backup; (其它所有的非backup机器down或者忙的时候，请求backup机器) } max_fails ：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误。 2.Keepalived安装版本:1.2.19 安装 ./configure --disable-fwmark --prefix=/aclome/keepalived //使用root安装指定如下: ./configure --prefix=/usr --sysconf=/etc make make install 配置 主: vi /etc/keepalived/keepalived.conf global_defs{ smtp_server 127.0.0.1 } vrrp_instance_VI_1{ state MASTER interface eth1 priority 100 ...... virtual_ipaddress{ 199.31.165.65 } } 备: vi /etc/keepalived/keepalived.conf global_defs{ smtp_server 127.0.0.1 } vrrp_instance_VI_1{ state BACKUP interface eth1 priority 50 ...... virtual_ipaddress{ 199.31.165.65 } } 启动 sudo service keepalived start sudo service keepalived status sudo service keepalived stop 验证 3.Redis安装版本:3.0.7 安装: Make PREFIX=/aclome/redis install 配置: cp /aclome/redis-3.0.7/utils/redis_init_script /aclome/redis/ vi redis_init_script EXEC=/aclome/redis/bin/redis-server CLIEXEC=/aclome/redis/bin/redis-cli cp /aclome/redis-0.0.7/redis.conf /aclome/redis/ Vi redis.conf dir ./data mkdir data mkdir data/sentinel 启动： nohup bin/redis-server conf/redis.conf &amp; 停止: bin/redis-cli -p 6379 shutdown 验证状态: ps -ef |grep redis 客户端: /aclome/redis/bin/redis-cli -p 6379 连接到远程的redis服务器: bin/redis-cli -h 199.31.165.62 -p 6379 get myname 存储KEY/VALUE命令：set myname “lvyafei” 读取Value命令: get myname 删除缓存命令: del myname 批量删除缓存: ./redis-cli -p 6379 KEYS “*” | xargs ./redis-cli -p 6379 DEL 获取所有Key命令: keys * Redis-HA方案-Sentinel配置: Redis-server端口:6379 Redis-sentinel端口:7031 1.master-slave配置 只需要在slave上配置redis.conf即可,master不用配置 slaveof 199.31.165.61 6379 slave-read-only yes 在master,slave上分别启动nohup bin/redis-server conf/redis.conf &amp; 停止master/slave命令:bin/redis-cli -p 6379 shutdown 2.Sentinel配置 在master/slave上配置sentinel.conf（master/slave相同配置） #######redis-sentinel###################### port 7031 dir ./data/sentinel sentinel monitor mymaster 199.31.165.61 6379 1 sentinel down-after-milliseconds mymaster 5000 sentinel parallel-syncs mymaster 1 sentinel failover-timeout mymaster 15000 启动sentinel： 分别在master/slave上执行命令：nohup bin/redis-sentinel conf/sentinel.conf &amp; 3.验证： Bin/redis-cli -p 7031 sentinel masters 停止master: 在master上执行bin/redis-cli -p 6379 shutdown.观察sentinel输出. 停止sentinel:bin/redis-cli -p 7031 shutdown 4.Tomcat Session共享配置拷贝 jar包到tomcat 的libs目录下: 1.x版本：不支持Redis集群 2.x版本：支持Redis集群 配置:vi /tomcat/config/content.xml 注意：1.x版本的包名和2.x版本的包名不一样，且2.x中多的参数1.x版本中不支持。 1.x版本配置: 2.x版本配置： 启动即可，在redis客户端验证存储的KEY/VALUE 5.CAS ticket共享复制redis-ticket-registry.jar包到 cas/WEB-INF/libs和cas/libs目录下。 编辑cas/WEB-INF/spring-configuration/ticketRegistry.xml文件]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>双高架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统架构总结之高可用高负载]]></title>
    <url>%2F2016%2F03%2F10%2F2016-03-10-%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E6%80%BB%E7%BB%93%E4%B9%8B%E9%AB%98%E5%8F%AF%E7%94%A8%E9%AB%98%E8%B4%9F%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[0.概述现有项目的一次架构总结,对一般的高可用、高负载策略也比较全面的接触了。 现行方案： 备案： ActiveMQ使用场景: postgres方案：]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>双高架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Java虚拟机-内存区域与内存溢出异常]]></title>
    <url>%2F2016%2F02%2F22%2F2016-02-22-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[0.概述内容选自周志明的&lt;&lt;深入理解Java虚拟机-JVM高级特性与最佳实战&gt;&gt;第2版(2013年6月第二版)。内存区域与内存溢出异常章节。 以下是工具集合和常用命令:]]></content>
      <categories>
        <category>JVM高级特性</category>
      </categories>
      <tags>
        <tag>内存区域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何做好一个项目型的需求分析]]></title>
    <url>%2F2016%2F01%2F17%2F2016-01-17-%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E5%9E%8B%E7%9A%84%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[0.概述无论你是一个产品经理或者项目经理,你都不能避免一件事情-需求分析。对于一个产品经理来说，需求分析就是挖掘用户的需求点，找到正确的、合理的、有效的、潜在的需求，对挖掘到的需求进行分析、归类、筛选，不断完善产品的功能，巩固产品的核心要素。而对于项目经理来说，由于是从一个项目的角度出发，所有的需求都是由客户发出的，要做的工作就是整理需求、理解需求，筛选需求，实现需求。无论怎样，都要经过下面的几个过程：对需求的收集、分析理解、筛选、管理以及挖掘。 1.收集需求作为项目型的经理，在需求收集阶段需要数次和客户沟通。对于一个投标型的项目来说，客户的需求在规格说明书中会有所阐述，这个说明只是对客户的需求的一个自我的表述，不能很有调理的整理出来，需要我们沟通和确认。前期的沟通一定要充分的理解客户的需求，若对客户现有的需求不太理解，可以向客户阐述自己的理解。比较好的方式是画出架构图，逻辑图等，不断的和客户确认，直到客户认可未知，在这个阶段不仅要去理解，还要去把现有的产品和技术往需求上靠拢，最好能确定大致的模块，这个阶段能确认的东西越多后面遇到的问题就越少，最后一定要落实的文档或者线框图上，这对后期的需求管理留下了基础，也为需求的挖掘留下了依据。 2.分析理解对收集过的需求进行分析的时候，要做到有理有据，结合现有的技术或者产品将客户的需求转换为解决方案，其实做需求分析的结果就是要产出一个符合客户的诉求和能够结合自身的产品或者技术优势的交付物。客户不仅仅是想我们去理解他的想法和愿景，更多的是在想我们发出帮助的信号，我们若能够帮着他来解决现有的问题将会得到很大的反响。有的时候提出需求的人其实未必是真的想好了如何去做，我们要及时的去理解和沟通它们真正的想法，只是一味的梳理客户的需求，而不去理解这些需求的本质，只能让我们后期被客户的无理需求牵着鼻子走。 需求的最终交付物是一个能让客户满意的解决方案，这个方案和客户原本的需求规格说明书可能有很多的差异，这才是对需求理解的最终目的。因为人的想法在刚产生的时候会有很多不确定的因素在里面，随着和客户的不断交流，我们能够替他们去挑出一些真正的需求，在最终的剩下的需求里面，我们又能够将多个不同的想法组合和精简成一个可行的功能点。 3.筛选需求筛选需求是在整理需求之后必经的一个阶段，该阶段中会有很多我们可以遵循的方法。最常用的有：做减法、做加法。 需求分析人员要做的就是从这些林林总总的需求当中找出可实现的，有价值的需求，排除那些无意义，不可实现的需求，或者是当前暂时先不实现，或者是这个产品不实现但可以利用在别的产品身上的，反正与当前产品无关的需求，都需要排除掉，这个过程就是在做减法。比如说，我们收集到10个功能需求，觉得其中有两个是没必要做的，或者是可以以后再做的，就把这2个需求功能先排除掉，先做剩下的8个功能需求。应该来说，做减法是需求分析人员最基本的素养了，一般都是有东西去给你做减法的。 需求分析人员依靠自身的工作经验，和对产品设计理念的理解，可以提出新的需求，这些新的需求不一定就是最终的需求，但需求分析人员要有能力去总结发现。因为往往人们在考虑问题的时候都是不全面的，所以才古语有云，三个臭皮匠顶个诸葛亮，把所有的意见综合在一起，很有可能就是个非常棒的点。这里做加法主要还是要依靠自身的经验来取决，比如要做5个功能需求，需求分析人员觉得应该再加上报表统计的功能，这就是在做加法。 当我们面对一件全新的产品设计任务时，没有任何现成的数据去提供给我们做分析，或者说数据很少，这个时候需求分析人员要去挖掘需求，也可以说是发现新需求，这个新需求是全新的，没有任何经验可借鉴的。挖掘需求对于产品经理来说是必不可备的，因为一个产品的发展过程中需要不断地注入新鲜的元素，才能符合适合市场的需要。而对一个项目来说，深挖需求能够孵化出其他的潜在项目，这也是评价一个项目经理是否具有“可持续发展”的潜质。 4.需求的管理对于很多刚入行做需求的人来说，分析需求可能是他们认为很重要的一个点，其实如果不能有效地把控需求，归纳和整理，在项目后期将会遇到一些让人不可预料的新的问题。因此，需求的管理是至关重要的，我们要不断地坚持总结和分析，这样才能够在客户提出问题之前，我们能够做到未雨绸缪。最好的办法是将每个阶段的需求按照时间线来整理，这样从一个时间的角度发现问题的本质。]]></content>
      <categories>
        <category>项目管理</category>
      </categories>
      <tags>
        <tag>需求分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[消息中间件ActiveMQ双高架构演进]]></title>
    <url>%2F2015%2F12%2F27%2F2015-12-27-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6ActiveMQ%E5%8F%8C%E9%AB%98%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%2F</url>
    <content type="text"><![CDATA[0.概述对于高可用高并发的架构需求，有很多方案，但每种方案都要和具体的使用场景相结合，比如网站的双高方案，中间件的双高方案。工作中遇到的消息中间件的双高需求，结合了ActiveMQ官网的指导，整理了以下的架构演进方案。 1.架构演进图]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>消息中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目管理之如何提高工作效率]]></title>
    <url>%2F2015%2F11%2F01%2F2015-11-01-%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E4%B9%8B%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87%2F</url>
    <content type="text"><![CDATA[0.背景最近项目马上就要进入攻坚阶段了，前期的需求分析和目前的工作进度都存在一定程度的不足。作为这个项目中的参与者，我身有体会当时间越来越短，客户要的东西越来越逼近，我们会忙得不可开交。会议一个接一个，客户在不断的要求我们交付一些中间产物，而我们也在马不停蹄的赶功能，按着前期的需求分析一步一步在实现每个模块。突然间感到想迈开步子大步向前，但是脚下好像绊着很多的障碍，项目的进度缓慢，我需要把自己理解的东西一遍一遍的向别人讲述，但是作用不是很大，我在思考到底是什么影响了项目的进度？从众多的因素中我慢慢看清了一些，比如客户的需求还在变动，一些外围的支持不到位，团队的整体能力不强，时间的规划不科学等。 这么多的因素中我能自己改变的东西很少，并且很多因素是做项目常遇到的，比如客户需求的不断变化，有的需求客户也只是前期的一个想法，但后期会不断的讨论讨论，耽误了真正需要花费时间的内容。外围的支持不到位，这个是项目的决策者去改变的，我只能及时提出发现的问题，不能等到真正遇到的时候才提出来。还有时间的规划，这一点我也没有权利去要求，合同上写的时间既然你签了就要在这个时间点内交出东西，别的都是屁话。最后一点：团队的效率问题，这一点就是我自己认为能够稍稍改变的东西，我自己也身为其中一员，自己能看到一些问题。 1.在一个项目中个人工作效率与哪些因素有关？一个项目是由一个团队去完成的，团队的整体力量是否强看的是每个人的能力，最短的板子决定了木桶装水的总量。一个人的工作效率的高低和自己的能力还有外围的阻力有关系。 能力一般的人，可能是这样： 能力较强的人，可能是这样： 能力较差的人，可能是这样： 可以看到同样的工作量，在规定的时间内，能力不一样的人完成需要的时间也是不一样的。但是工作效率不仅和个人的工作能力有关系，还与工作中遇到的阻力有关系，试想如果一个能力很很高的人，但是相关资源不到位，也同样会延期完成任务。 能力：能力是一个队员在完成任务时平均花费的时间。能力与自己的工作经验，工作习惯、技术的积累、理解能力、沟通能力等因素有关。并且随着工作年限的增长每个人的能力都会不同程度的提升。 阻力：阻力是分配给一个队员的任务中遇到的外围因素的干扰。比如相关资源不到位，外围环境的影响，生活琐事的影响等，作为项目的管理者和负责人应当尽量减少队员的阻力，这样对整体的工作效率都会有很大的提升。 2.项目中的风险把控项目中的风险有一些会在前期暴露出来，有些是在项目中暴露出来。项目前期的风险可以做到风险防御和风险规避，但是中期的风险是最可怕的，如果处理不好，将会影响整个项目的进度和最终的效果。 需求分析过程中要把项目会遇到的风险主管推断出来，不然后期就会一直遇到问题，让人精疲力尽，这个阶段也是发现问题，推断问题的关键时期，要把项目中的问题整理梳理一遍，讨论解决，要是等到建设过程中才发现就会害死人的。 项目中期发现风险要及时提出，及时解决。项目负责人和管理者要阶段性的总结发现问题，如果想一劳永逸的靠前期的需求分析就会漏洞百出，因为风险的出现和外围的因素有很大的关系，比如客户的主观改变、实际的发展和预期不一致等。 3.关于团队建设团队的建设是一个很需要思考的问题，整体人员的水平决定了项目的最终的效果。客户对这个也很看重，尤其对于投标性的项目，很注重团队的建设。做项目是在和人打交道，和客户和领导和同事。管项目是在和人打交道，分配任务要看人看内容，不能蒙着眼分配。一些风投在投资项目时如果是一个黄金团队就会很愿意投，如果没有背景的团队(当然是实力了),再好的点子也会犹豫不定的。]]></content>
      <categories>
        <category>项目管理</category>
      </categories>
      <tags>
        <tag>工作效率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web技术架构演进]]></title>
    <url>%2F2015%2F10%2F27%2F2015-10-27-Web%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%2F</url>
    <content type="text"><![CDATA[0.概述大型网站的架构都是从简单的、单一的架构不断演进到复杂的、多层次的设计。这个过程中会衍生出好多架构的思想和解决办法，我们可以从中看到随着需求的不断变化，架构的重心也会不断的调整。从现有的架构发展可以看出以后的方向，更能指引我们向着正确的地方前进。 1.架构演进图 2.架构思想从架构的演进过程中我们可以看到这里面有几个重要的分割点，还有对待现实产生的问题对待的解决办法 1.堆机器 从单台服务器到多台服务器，硬件方面是为了增大机器的总内存，总CPU，软件方面是为了减少单服务器的访问瓶颈，分流减压。 2.拆模块 一个大的模块会导致牵一发而动全身，常规的解决办法是根据分类将一个大的模块拆分成多个小的，这样对于维护来说不仅能够灵活的应对需求的变更，还能够不断优化整体的结构。最终还可以将小的模块作为服务来提供，真正做到面向服务的架构。 3.做缓冲 为了不断提高性能，我们可以采用本地缓存，分布式缓存，反向代理，动静分离缓存，CDN加速以及采用消息总线的方式，这些技术都是为了将实际从远处或者获取一些大的数据量时能够对数据做一个缓冲，而不需要局限于网络和IO的瓶颈，真正提高访问的速度。 4.分分合合 分的时间长了，或者分的太细了就会很繁琐，不便于管理。我们就要将繁琐的东西归类起来，统一管理，统一配置，SOA服务治理，配置的集中管理等都是在拆分后产生问题的应对措施。 3.解决办法常见的解决办法是，分布式部署，集中式管理。解决了一个现有的需求问题，就会带来其他的问题，我们要有所权重，服务的治理，是在做了服务的拆分后出现的，如果没有提出抽取出服务的方案就不必对服务进行治理。但是我们不能害怕产生新的问题就不采取这种方式，敢于大胆尝试才能创造出跟优良的解决方案。 4.发展的方向随着WEB3.0的到来，技术架构的方向会不断的变化，但是基本的的原点就是应用和存储的不断转移，可以从运维的角度到软件的架构间选择，改变的方式也是在分布式和集中式间变化，各有利弊，关键是当前的架构重心是在哪里，要有取舍才能更出色。]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>网站架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求最短路径算法-Dijkstra]]></title>
    <url>%2F2015%2F09%2F28%2F2015-09-28-%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-Dijkstra%2F</url>
    <content type="text"><![CDATA[0.算法属性类别：查找算法 数据结构：图 性能：O(|E|+|V|log|V|) 1.算法介绍Dijkstra算法是求图中两节点间最短路径的一种算法。它可以表示：例如，道路网络。 它的构思是由计算机科学家Edsger W. Dijkstra在1956想出并在三年后提出的。 这个算法存在许多版本；Dijkstra的最初版本是求两结点之间的最短路径，但更常见的版本是将单一节点作为“源”节点，去计算从源头到图中的所有其他节点的最短路径，并生成树。 最短路径的算法被广泛应用于网络的路由协议，比如最著名的是OSPF(优先开放最短路径)。也被用作子算法，如Johnson’s algorithm Dijkstra原始算法并没有使用最小优先队列，运行时间为O(|V|^2)(其中|V|表示节点的数量)。 这种算法思想在1957年被Leyzorek等人提出。在1984年被Fredman和Tarjan实现在斐波那契堆中，并且运行时间为O(|E|+|V|\log|V|)(其中 |E|为边的数量) 这是在任意有向图和无界非负权重的情况下，一个以渐进的方式最快的算出已知单源最短路径算法。 2.算法示意图示意一： 计算a到b的距离。其中： 1.两点间的实际距离为连接线上的数字。 2.节点圆圈中的数字为该节点的标示符。 3.节点边上蓝色数字为起始节点a到该节点的最小距离。 4.若计算出的距离值比当前所标示的距离值小，则更新反之不更新。节点初始值为无限大。 5.访问过的节点标示为红色，下一次忽略该节点(即该节点的最小距离值不再改变,状态为out)。 计算结果： a到节点1的最小距离为：0 a到节点2的最小距离为: 7 a到节点3的最小距离为: 9 a到节点6的最小距离为：11 a到节点5的最小距离为: 20 示意二： 从开始节点(左下角的红色节点)到目标节点(右上角的绿色节点)的查找示意图。其中空心节点表示“暂定”集，填充节点表示”被访问”过的。颜色代表距离，颜色越绿代表距离越远。不同方向上的节点是均匀分布的，Dijkstra算法使用了一个启发式恒等于0，像波浪一样渐进发现节点。 示意三： 从左到右，从上到下： 图一：以左上角的点为起始节点，计算到图中所有其它节点的最小距离。初始值为99(一个很大的值)，起始节点初始值为0，各相邻节点的实际距离为边线上的值。 图二：以“起始节点”为“当前节点”，计算出到各相邻节点的最小距离，由于各相邻节点的初始值为99，比实际距离要大，所以更新各自的值，依次为2,6,9. 图三：在2、6、9中最小的是2，所以将2作为“当前节点”，更新2的相邻节点为3(2+1=3),5(2+3=5&lt;6).注意发现过的节点不能再计算，并且要遵守图的有向性。 图四：在3、5中最小的是3，所以将3当做“当前节点”，更新3的相邻节点为4(3+1=4&lt;5),9(3+6=9). 图五：在4、9中最小的为4，所以将4当做“当前节点”，更新4的相邻节点为13(4+9=13),11(4+7=11),6(4+2=6&lt;9). 图六：在13,11,6中最小的为6，所以将6当做“当前节点”，更新6的相邻节点为10(6+4=10&lt;11). 图七：只有10这条路，所以更新10相邻的节点为11(10+1) 图八：…. 图九：…. 3.算法思路让我们把开始的节点称为“起始节点”，从“起始节点”到节点Y的距离标记为Y。Dijkstra算法事先分配一些初始的距离值，并在后面逐步提高他们。 1.分配给每个节点一个暂定的距离值，设置起始节点值为0，其余节点值为无限大。 2.设置起始节点为当前(current)。标记其它所有节点为未发现(unvisited)。创建一个数据集合(包含所有未发现的节点),称作未发现数据集(unvisited set). 3.对于当前的节点，考虑所有未访问过的邻居并计算出他们“暂时距离”。比较新计算出的“暂时距离”和当前分配的值，并分配较小的一个。例如，如果当前节点A被标记距离值为6，A距离邻居节点B的长度为2，计算出一个临时值(通过A)为6+2=8.如果B事先标记的值大于8，则将其改为8。否则，保持当前值。 4.当我们考虑完所有当前节点的邻居节点后，标记当前节点为已发现节点(visited node)并且把它从未发现数据集(unvisited set)中移除。已发现节点(visited node)永远不会被再次检查。 5.如果目标节点被标记为已发现(当规划两个节点之间的路径时)或者如果这个最小距离在未发现节点集合中被计算为无限大(当计划一个完整的遍历，发现没有一个连接从起始节点到剩余未访问的节点)，然后就停止，这个算法就结束了。 6.否则，选择一个未访问过的节点(被标记为最小临时距离的)作为新的“当前节点”，然后回到步骤3重复执行。 4.伪代码1 function Dijkstra(Graph,source): 2 3 dist[source] ← 0 //从起始节点到起始节点的距离 4 prev[source] ← undefined //最优路径初始化中的前一个节点 5 6 create vertex set Q //创建节点集 7 8 for each vertex v in Graph: //初始化 9 if v ≠ source: //v 还没从Q中移除(未发现的节点) 10 dist[v] ← INFINITY //不知道从source到v的距离 11 prev[v] ← UNDEFINED //上一个到source最佳路径的节点 12 add v to Q //Q中所有初始的节点(未发现的节点) 13 14 while Q is not empty: 15 u ← vertex in Q with min dist[u] //第一种情况下的源节点 16 remove u from Q 17 18 for each neighbor v of u: //v还在Q中 19 alt ← dist[u] + length(u,v) 20 if alt &lt; dist[v]: //到V的最短路径被发现 21 dist[v] ← alt 22 prev[v] ← u 23 24 return dist[],prev[] 如果我们只是计算从源节点到目标节点的最短路径，我们可以在第16行后终止搜索，如果u = target。现在我们可以通过反向迭代的方式读取从源到目标的最短路径： 1 S ← empty sequence 2 u ← target 3 while prev[u] is defined: // 用栈S构建最短路径 4 insert u at the beginning of S // 将顶点推到堆栈上 5 u ← prev[u] // 从目标转向源节点 使用优先队列： 最小优先队列是一个抽象数据类型，它提供了3个基本操作：add_with_priority()，decrease_priority()和extract_min()。如前所述，使用这样的数据结构可以比使用一个基本队列产生更快的计算时间。值得注意的是，斐波那契堆（Fredman和Tarjan 1984提出的）或Brodal队列提供了这3个操作的最佳实现。由于算法是有点不同的，我们在这里提到了，它的伪代码： 1 function Dijkstra(Graph, source): 2 dist[source] ← 0 // 初始化 3 4 create vertex set Q 5 6 for each vertex v in Graph: 7 if v ≠ source 8 dist[v] ← INFINITY // 不知道从源节点到V的距离 9 prev[v] ← UNDEFINED // v的前一个节点 10 11 Q.add_with_priority(v, dist[v]) 12 13 14 while Q is not empty: // 主循环 15 u ← Q.extract_min() // 删除并返回最佳顶点 16 for each neighbor v of u: // 只有v仍然在Q中 17 alt = dist[u] + length(u, v) 18 if alt &lt; dist[v] 19 dist[v] ← alt 20 prev[v] ← u 21 Q.decrease_priority(v, alt) 22 23 return dist[], prev[] 不是在初始化时将所有节点都填充到优先级队列中，也可以在初始化时只包含源节点，当alt &lt; dist[v]时，并且没有在队列中，那么这个节点必须被插入。 5.代码实现java版： 6.参考说明MBA lib,Wikipedia]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Search-algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于NodeJS的开发框架和优秀项目]]></title>
    <url>%2F2015%2F09%2F25%2F2015-09-25-%E5%9F%BA%E4%BA%8ENodeJS%E7%9A%84%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E5%92%8C%E4%BC%98%E7%A7%80%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[目录{:toc #meuid} 0.如何进阶NodeJS?通过前面”四个例子入门NodeJS”后，我们可以写出一个简单的Web应用，但似乎和真实的大型项目好像有一点不同，原因在哪里？其实我们前面掌握的那些都是NodeJS比较基础但很重要的内容，想要进阶学习,必须要掌握和熟悉至少一个优秀的应用框架和项目。 1.Express -NodeJS的Web应用框架 Web 应用Express 是一个基于 Node.js 平台的极简、灵活的 web 应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。 API丰富的 HTTP 快捷方法和任意排列组合的 Connect 中间件，让你创建健壮、友好的 API 变得既快速又简单。 性能Express 不对 Node.js 已有的特性进行二次抽象，我们只是在它之上扩展了 Web 应用所需的基本功能。 LoopBack 提供赞助Develop model-driven apps with an Express-based framework.Find out more at loopback.io. Express官网 2.Hexo -静态博客框架 如果你想在github上部署个人blog的话，有两种方式：一种是使用Jekyll，一种是使用Hexo。这两种是目前github支持的方式。Hexo比Jekyll有更多的主题，若你是一个Geek，对一切包装过的东西很讨厌的话，选择Jekyll也很不错! 特性 风一般的速度Hexo基于Node.js，支持多进程，几百篇文章也可以秒生成。 流畅的撰写支持GitHub Flavored Markdown和所有Octopress的插件。 扩展性Hexo支持EJS、Swig和Stylus。通过插件支持Haml、Jade和Less. 3.Ghost -NodeJS平台最强博客平台 Ghost是Node.js开发最新博客系统, 简单简洁, 响应式设计, 支持完全自定义, 免费, 专注博客 github源码 我在daocloud上部署的ghost镜像站点：http://lvyafei-myhost.daoapp.io/ 4.Cheerio/Request -Web爬虫工具包用nodejs写采集程序还是比较有效率，使用nodejs实现数据采集器，主要使用到request和cheerio。 request :用于http请求 https://github.com/request/request cheerio:用于提取request返回的html中需要的信息（和jquery用法一致） https://github.com/cheeriojs/cheerio]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开始使用Python吧]]></title>
    <url>%2F2015%2F09%2F25%2F2015-09-25-%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8Python%E5%90%A7%2F</url>
    <content type="text"><![CDATA[目录{:toc #meuid} 0.Python介绍Python是一种解释型、面向对象、动态数据类型的高级程序设计语言。 Python由Guido van Rossum于1989年底发明，第一个公开发行版发行于1991年。像Perl语言一样, Python 源代码同样遵循 GPL(GNU General Public License)协议。 Python语法简洁清晰，特色之一是强制用空白符(white space)作为语句缩进。 Python具有丰富和强大的库。它常被昵称为胶水语言，能够把用其他语言制作的各种模块（尤其是C/C++）很轻松地联结在一起。常见的一种应用情形是，使用Python快速生成程序的原型（有时甚至是程序的最终界面），然后对其中有特别要求的部分，用更合适的语言改写. 1.Python能做什么?系统编程：提供API，能方便进行系统维护和管理，Linux下标志性语言之一，是很多系统管理员理想的编程工具 图形处理：有PIL、Tkinter等图形库支持，能方便进行图形处理。 数学处理：NumPy扩展提供大量与许多标准数学库的接口。 文本处理：python提供的re模块能支持正则表达式，还提供SGML，XML分析模块，许多程序员利用python进行XML程序的开发。数据库编程：程序员可通过遵循Python DB-API（数据库应用程序编程接口）规范的模块与Microsoft SQL Server，Oracle，Sybase，DB2，MySQL、SQLite等数据库通信。python自带有一个Gadfly模块，提供了一个完整的SQL环境。 网络编程：提供丰富的模块支持sockets编程，能方便快速地开发分布式应用程序。很多大规模软件开发计划例如Zope，Mnet 及BitTorrent. Google都在广泛地使用它。 Web编程：应用的开发语言，如 Pylons(Web应用框架)、Zope(应用服务器)、Plone(内容管理系统)、Twisted(Python的网络应用程序框架)、Webpy(微Web框架)、Reddit(社交分享网站)、Dropbox(文件分享服务)、Fabric(管理Linux主机的程序库)、Trac(BUG管理系统)、Mailman(邮件列表软件)、Mezzanine(基于Django编写的内容管理系统)、Blender(以C与Python开发的开源3D绘图软件). 多媒体应用：Python的PyOpenGL模块封装了“OpenGL应用程序编程接口”，能进行二维和三维图像处理。PyGame模块可用于编写游戏软件。 PYMO引擎：PYMO全称为python memories off，是一款运行于Symbian S60V3,Symbian3,S60V5, Symbian3, Android系统上的AVG游戏引擎。因其基于python2.0平台开发，并且适用于创建秋之回忆（memories off）风格的AVG游戏，故命名为PYMO。 黑客编程：python有一个hack的库,内置了你熟悉的或不熟悉的函数. 爬虫: Scrapy-开源Python爬虫框架 2.Python学习资源RUNOOB.com -Python基础学习 3.Python经典项目一个好的项目是对学习一个语言或工具是有很大的指引作用的，现在基于Python语言的出色的项目有很多，我自己发现的项目中，其中有几个是对进阶学习Python有很大帮助的。也是自己比较感兴趣的, 这里只做一个简单的引入, 如果你感兴趣，请关注我的后续文章。。 3.1 Django- 鼓励快速开发的Web应用框架 Django 是由 Python 开发的一个免费的开源网站框架，可以用于快速搭建高性能，优雅的网站！ 教程: 自强学堂 -Diango开发教程 3.2 Flask- Python微Web框架 Flask是一个使用 Python 编写的轻量级 Web 应用框架。其 WSGI 工具箱采用 Werkzeug ，模板引擎则使用 Jinja2. 使用 BSD 授权。 Flask -官方教程中文版 Flask -官方 3.3 Scrapy- Python网络爬虫框架 Scrapy，Python开发的一个快速,高层次的屏幕抓取和web抓取框架，用于抓取web站点并从页面中提取结构化的数据。Scrapy用途广泛，可以用于数据挖掘、监测和自动化测试。Scrapy吸引人的地方在于它是一个框架，任何人都可以根据需求方便的修改。它也提供了多种类型爬虫的基类，如BaseSpider、sitemap爬虫等. Scrapy教程]]></content>
      <categories>
        <category>后端脚本</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四个例子入门NodeJS]]></title>
    <url>%2F2015%2F08%2F31%2F2015-08-31-%E5%9B%9B%E4%B8%AA%E4%BE%8B%E5%AD%90%E5%85%A5%E9%97%A8NodeJS%2F</url>
    <content type="text"><![CDATA[目录{:toc #meuid} 0.前言NodeJS是什么?JavaScript是一种运行在浏览器的脚本，它简单，轻巧，易于编辑，这种脚本通常用于浏览器的前端编程，但是一位开发者Ryan有一天发现这种前端式的脚本语言可以运行在服务器上的时候，一场席卷全球的风暴就开始了。 Node.js是一个基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的网络应用。Node.js 使用事件驱动， 非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行的数据密集型的实时应用。 Node是一个Javascript运行环境(runtime)。实际上它是对Google V8引擎进行了封装。V8引 擎执行Javascript的速度非常快，性能非常好。Node对一些特殊用例进行了优化，提供了替代的API，使得V8在非浏览器环境下运行得更好。 我们该如何入门学习？对于一个新的技术来说，入门学习很重要，如果有一个好的入门学习资料，将会对以后深入学习该技术产生很大的帮助，本文就是以这中思想来解说的，希望能够对学习NodeJS的人来说有一个好的开始，也欢迎大家对本文指出不足。 本文源码 关于如何安装NodeJS,对于Linux上用户直接到官网下载编译过的安装包，然后加入到环境变量中即可 ln -s /home/software/node-v0.12.7-linux-x64/bin/node /usr/local/bin/node ln -s /home/software/node-v0.12.7-linux-x64/bin/npm /usr/local/bin/npm 输入node回车即可进入node命令。 1.了解结构入口： var server=require(&quot;./server&quot;); server.start(); NodeJS入口是指node命令后面要执行的文件，例如”node helloworld.js”即可之执行编写的代码，其中require是之加载模块，这里加载了本地的一个模块，也可加载内置的模块,比如require(“http”),是指加载node中自带的http模块，这点和函数式编程有点像。后面就可以调用具体的function了，这点就是Javascript里面的东西了，很简单吧。 server: function start(){ function onRequest(request,response){ router.route(pathname,request,response,null); } http.createServer(onRequest).listen(8888); } exports.start=start; server.js中的内容就是服务请求的入口了，包含请求的处理，路由的处理。最好是把处理放在一个单独的文件中这样管理起来也很方便。exports就是把该方法暴露出去，可以让外边的程序调用。最后在一个端口上监听就可以了. route: function route(pathname,request,response,data){ handler.menu(request,response,data); } exports.route=route; 对于路由后的内容要有一个处理的文件，就是requestHandlers,这个文件中是对每个路由到的地址进行具体的请求。 handler: function menu(request,response,postdata){} function start(request,response,postdata){} function textpost(request,response,postdata){} function filepost(request,response,postdata){} exports.menu=menu; exports.start=start; exports.textpost=textpost; exports.filepost=filepost; 每个对应一个请求，这是一种最简单的处理方式。 了解以上的内容后，就可以写一个简单的有结构的程序了，下面的示例是在以上的基础上演示了几种常见的情景:非阻塞请求，post数据，查看图片,上传图片。 2.示例一：阻塞演示对于处理一个比较费时的操作，如果要在当前线程中处理的话会阻塞，一旦产生阻塞就会影响其它请求的执行，一种处理阻塞的方法时利用回调，将好事耗时的任务利用child_process的操作来执行，也可以将response的方法在数据处理完后发送给客户端。 在requestHandlers.js中start的方法演示了如何处理阻塞请求: function start(request,response,postdata){ console.log(&quot;request handler &apos;start&apos; was called.&quot;); exec(&quot;find /&quot;,{timeout:10000,maxBuffer:20000*1024},function(error,stdout,stderr){ response.writeHead(200,{&quot;Content-Type&quot;:&quot;text/plain&quot;}); response.write(stdout); response.end(); }); } 3.示例二:post请求对于一个请求，如果不带参数的化可以直接路由即可，但对于post方法中带的数据的情况，node 中有专门的方法处理，由于该过程也回产生阻塞，为了使整个过程非阻塞，Node.js会将POST数据拆分成很多小的数据块，然后通过触发特定的事件，将这些小数据块传递给回调函数。这里的特定的事件有data事件（表示新的小数据块到达了）以及end事件（表示所有的数据都已经接收完毕）。 我们需要告诉Node.js当这些事件触发的时候，回调哪些函数。怎么告诉呢？ 我们通过在request对象上注册监听器（listener） 来实现。这里的request对象是每次接收到HTTP请求时候，都会把该对象传递给onRequest回调函数。 在server.js中onRequest的方法演示了如何该情况: request.setEncoding(&quot;utf-8&quot;); request.addListener(&quot;data&quot;,function(postDataChunk){ postData+=postDataChunk; console.log(&quot;Received POST data:&quot;+postDataChunk+&quot;.&quot;); }); request.addListener(&quot;end&quot;,function(){ router.route(pathname,request,response,postData); }); requestHandlers.js中upload方法就可以拿到数据，然后写回客户端: response.writeHead(200,{&quot;Content-Type&quot;:&quot;text/plain&quot;}); response.write(&quot;You&apos;ve sent : &quot;+querystring.parse(postdata).text); response.end(); 4.示例三:查看图片对于查看服务器上的资源，可以用file system模块，调用方式如：require(“fs”).requestHandlers.js中show方法就是读取一个图片的示例: fs.readFile(&quot;/root/图片/new.png&quot;,&quot;binary&quot;,function(error,file){ if(error){ response.writeHead(500,{&quot;Content-Type&quot;:&quot;text/plain&quot;}); response.write(error+&quot;\n&quot;); response.end(); }else{ response.writeHead(200,{&quot;Content-Type&quot;:&quot;image/png&quot;}); response.write(file,&quot;binary&quot;); response.end(); } }); 在示例中不仅此处用了该方法，加载具体的html文件也用到该模块。 5.示例四:图片上传文件上传也是一个比较常见的情形，单要用到一个模块formidable，该模块需要自己安装，node默认没有自带. 安装方法: npm install formidable requestHandlers.js中uploadfile方法就是处理上传上来的文件的示例: var form=new formidable.IncomingForm(); form.parse(request,function(error,fields,files){ fs.renameSync(files.upload.path,&quot;/root/图片/new.png&quot;); response.writeHead(200,{&quot;Content-Type&quot;:&quot;text/html&quot;}); response.write(&quot;received image:&lt;br/&gt;&quot;); response.write(&quot;&lt;img src=&apos;/show&apos; /&gt;&quot;); response.end(); }); 注意的是：这里不再调用addListener方法，而是要自己处理上传的资源。单独的处理，避免和其它处理方式混淆: if(pathname==&quot;/uploadfile&quot;){ router.route(pathname,request,response,null); }else{ //..... } 6.总结通过这几个示例可以更加深入的了解到node的开发方式，希望能对刚入门的人有一个指导性的作用。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用一天时间来学习angularjs]]></title>
    <url>%2F2015%2F08%2F16%2F2015-08-16-%E7%94%A8%E4%B8%80%E5%A4%A9%E6%97%B6%E9%97%B4%E6%9D%A5%E5%AD%A6%E4%B9%A0angularjs%2F</url>
    <content type="text"><![CDATA[目录{:toc #meuid} 对于学习angulaJS来说，更多的是对整体的了解。看了Todd Motto 的一篇文章后，对这个框架有了一个比较清晰的认识。查看原文 I.什么是AngularJS? Angular 是一个客户端MVC/MVVM框架，内置在JavaScript中，是现在流行的单页面web应用（甚至是网站）必不可少的东西。这篇文章是我学习angularjs的全部的经验，建议和最佳的做法。通过掌握它你会学会很多东西。 II.Terminology(术语)Angular 有一个短的学习路线，掌握了基本知识后你会发现它的优点和缺点，对学习这个框架来说，掌握这些术语和学会用MVC思考是非常重要的，下面是一些Angular中包含的一些高级并且重要的api和术语。 III.MVC你可能听说过MVC，用在许多编程语言中来构建应用程序/软件/架构的一种手段。这里是每个部分的简单含义： Model：每一个应用中都离不开数据结构，通常放在JSON中。在开始Angular之前先要读懂JSON，因为它对了解server和view是如何通信的非常重要。例如，一组用户身份标识可以有以下模型： { &quot;users&quot; : [{ &quot;name&quot;: &quot;Joe Bloggs&quot;, &quot;id&quot;: &quot;82047392&quot; },{ &quot;name&quot;: &quot;John Doe&quot;, &quot;id&quot;: &quot;65198013&quot; }] } 然后你就可以从服务器通过XHR抓取信息（XMLHTTP请求），在Jquery中是通过$.ajax方法，在Angular中是$http,或者它会写进你的代码在页面解析（从一个数据仓库/数据库）时，然后你可以推送更新到你的模型，并把它发送回。 View: View是非常容易理解的，它是你的HTML页面或呈现的输出。使用MVC框架，你会使用Model数据来更新View和HTML中显示的相关数据。 Controller：Controller直接访问服务器中的View，作为中间人，你能够在Controller中更新Model中的数据来改变View。 0.建立一个AngularJS项目（基本要点）首先，我们需要确认安装了AngularJS必备的基础环境，在我们开始前有一些事情是需要注意的，一般由ng-app声明来定义你的应用程序,一个Controller和View页面、一些DOM邦定还有Angular来交互。以下是基本要点： 一些带“ng-*” 声明的HTML &lt;div ng-app=&quot;myApp&quot;&gt; &lt;div ng-controller=&quot;MainCtrl&quot;&gt; &lt;!-- controller logic --&gt; &lt;/div&gt; &lt;/div&gt; Angular的 Module 和 Controller: var myApp = angular.module(&apos;myApp&apos;, []); myApp.controller(&apos;MainCtrl&apos;, [&apos;$scope&apos;, function ($scope) { // Controller magic }]); 在开始动手之前，我们需要创建一个包含所有逻辑的Angular module,有很多种方法来声明 modules,你可以将所有的逻辑像这样串联起来（我不喜欢这种做法）： angular.module(&apos;myApp&apos;, []) .controller(&apos;MainCtrl&apos;, [&apos;$scope&apos;, function ($scope) {...}]) .controller(&apos;NavCtrl&apos;, [&apos;$scope&apos;, function ($scope) {...}]) .controller(&apos;UserCtrl&apos;, [&apos;$scope&apos;, function ($scope) {...}]); 在我的使用中，建立一个全局的Module被证明是一个非常好的方式。缺少分号和意外关闭的’连接’证明适得其反，会出现一些不必要的编译错误，像这样： var myApp = angular.module(&apos;myApp&apos;, []); myApp.controller(&apos;MainCtrl&apos;, [&apos;$scope&apos;, function ($scope) {...}]); myApp.controller(&apos;NavCtrl&apos;, [&apos;$scope&apos;, function ($scope) {...}]); myApp.controller(&apos;UserCtrl&apos;, [&apos;$scope&apos;, function ($scope) {...}]); 我创建的每一文件都使用简单的myApp命名空间并自动的邦定到Application上，没错，我会为每个Controller, Directive, Factory 和其它的内容创建一个文件，关联和压缩这些文件到一个脚本文件中，然后引入到DOM中（使用Grunt或Gulp类似的工具） 1.Controllers(控制器)现在你已经掌握了MVC设计模式的概念和基本设置，让我们看看Angular中是如何运用Controllers的。从上面的例子中我们可以很简单的从一个Controller中拿到数据然后放入到DOM中，Angular采用一种模板风格 嵌在你的HTML中，你的HTML应该（最好）不包含物理文本或硬编码的值以最大限度地利用Angular，下面是一个将字符串推送到页面上的例子： &lt;div ng-app=&quot;myApp&quot;&gt; &lt;div ng-controller=&quot;MainCtrl&quot;&gt; { { text } } &lt;/div&gt; &lt;/div&gt; 脚本： var myApp = angular.module(&apos;myApp&apos;, []); myApp.controller(&apos;MainCtrl&apos;, [&apos;$scope&apos;, function ($scope) { $scope.text = &apos;Hello, Angular fanatic.&apos;; }]); 演示：http://runjs.cn/code/jgevzqjd 这里的核心法则是“$scope”的概念，你会在一个特定的Controller里面邦定所有的功能。$scope代表的是DOM中当前的元素，封装一个非常好的观察能力，保持元素范围内的数据和逻辑完完美邦定。它提供了JavaScript的公共/私有范围的DOM，这很神奇。 $scope的范围概念似乎有点可怕，但这是你从服务器到DOM的交互方式（静态数据，如果你有过）！这个例子教你了一个如何把数据“推”到DOM的办法。 让我们看一个比较有代表性的数据结构，我们假设从服务器检索显示用户的登录信息。现在我将使用静态数据；我后边会告诉你如何获取动态JSON数据。 首先我们要编写JavaScript： var myApp = angular.module(&apos;myApp&apos;, []); myApp.controller(&apos;UserCtrl&apos;, [&apos;$scope&apos;, function ($scope) { // Let&apos;s namespace the user details // Also great for DOM visual aids too $scope.user = {}; $scope.user.details = { &quot;username&quot;: &quot;Todd Motto&quot;, &quot;id&quot;: &quot;89101112&quot; }; }]); 然后交给DOM来显示这些数据： &lt;div ng-app=&quot;myApp&quot;&gt; &lt;div ng-controller=&quot;UserCtrl&quot;&gt; &lt;p class=&quot;username&quot;&gt;Welcome, { { user.details.username } }&lt;/p&gt; &lt;p class=&quot;id&quot;&gt;User ID: { { user.details.id } }&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; 演示：http://runjs.cn/code/4xrlzycm 重要的一点要记住，控制器只为数据，并创建函数（也包括事件函数）！它跟服务器交互并且推/拉JSON数据。这里没有DOM操作，所以不需要jQery工具。指令(Directives )是DOM操作，这是下一个要介绍的。 小提示：在Angular的官方文档中（我在写这篇文章时）他们的例子中使用这种方式创建Controllers： var myApp = angular.module(&apos;myApp&apos;, []); function MainCtrl ($scope) { //... }; …不要这样做。这将所有的功能都暴露在全局范围内，并不会让它们与应用程序很好地联系在一起。这也意味着你不能很容易的缩小你的代码或运行测试。不要滥用全局名称空间，要保证Controller只在您的应用程序内。 2.Directives(指令)指令最简化形式是一段HTML模板，在应用程序需要的地方最好能多次使用。这是毫不费力的注入DOM到应用中最简单的方式，或执行自定义DOM交互。指令并不简单，想完全征服他们需要一个非常令人难以置信的学习路线，但通过这一小节的学习会让你基本掌握它。 那指令有什么用处？很多事情，包括DOM组件，例如制表符或导航元素会依赖你的应用程序中使用的UI。让我这样说吧，如果你有过ng-show或者ng-hide，这就是指令（虽然他们不注入DOM）。 对于这个练习，我想把它弄的很简单，创建一个自定义按钮（称为CustomButton）注入一些标记，我讨厌写很多字。有各种不同的方式定义DOM中的指令，这些可能看起来像这样： &lt;!-- 1: as an attribute declaration --&gt; &lt;a custom-button&gt;Click me&lt;/a&gt; &lt;!-- 2: as a custom element --&gt; &lt;custom-button&gt;Click me&lt;/custom-button&gt; &lt;!-- 3: as a class (used for old IE compat) --&gt; &lt;a class=&quot;custom-button&quot;&gt;Click me&lt;/a&gt; &lt;!-- 4: as a comment (not good for this demo, however) --&gt; &lt;!-- directive: custom-button --&gt; 我更喜欢他们作为一个属性使用，自定义元素作为HTML5未来的一个Web组件特性，但Angular指出这在一些老的浏览器上会当成是一个BUG。 现在你知道在使用/注入指令的时候如何声明了吧，让我们创建这个自定义按钮。再次，我会回调我的全局命名空间MyApp的应用，这是最简形式的指令： myApp.directive(&apos;customButton&apos;, function () { return { link: function (scope, element, attrs) { // DOM manipulation/events here! } }; }); 我使用 .directive()方法来创建指令，传入指令的名称“CustomButton“。当你在指令的名称中使用一些字母，它会通过DOM中的连字符进行分割（如上图）。 一个指令简单的返回一个带有参数的对象。对我来说最重要的是：restrict, replace, transclude, template 和 templateUrl,当然还有 link 属性。让我把其它的也加入进来吧： myApp.directive(&apos;customButton&apos;, function () { return { restrict: &apos;A&apos;, replace: true, transclude: true, template: &apos;&lt;a href=&quot;&quot; class=&quot;myawesomebutton&quot; ng-transclude&gt;&apos; + &apos;&lt;i class=&quot;icon-ok-sign&quot;&gt;&lt;/i&gt;&apos; + &apos;&lt;/a&gt;&apos;, link: function (scope, element, attrs) { // DOM manipulation/events here! } }; }); 演示： http://runjs.cn/code/xtupcxdh 验证你是否插入元素，请确认你是否注入附加标记。指令的属性解释： restrict：[约束]看下上面的例子我们是怎么使用restrict的，如果你的项目需要支持IE的话，你可能需要声明attribute或class。使用“A”意味着你限制它作为一个Attribute，E代表Element，C代表Class，M代表Comment。默认是“EA”，对的，你可以限制多个。 replace：[替换]替换DOM为指令中定义的内容，在这个例子中，你会注意到初始DOM已经被指令的模板替换。 transclude：[嵌入]简单地说，使用嵌入允许现有的DOM内容被复制到指令中。你会看到单词’点击我’已被’移’到指令中，在显示的时候。 template：[模板]模板（如上）允许你将标记为被注入。这是一个好主意，用这一小段HTML片断。注入模板都通过Angular编译，这意味着你可以定义处理的方法已更好的邦定使用。 templateUrl：[模板Url]类似于一个模板，但保持在它自己的文件或&lt;脚本&gt;标签。你可以指定一个模板的URL，你会使用一个单独的文件来管理HTML模板，请指定路径和文件名，最好放在自己的模板目录中： myApp.directive(&apos;customButton&apos;, function () { return { templateUrl: &apos;templates/customButton.html&apos; // directive stuff... }; }); 加入你的文件（文件名不敏感）： &lt;!-- inside customButton.html --&gt; &lt;a href=&quot;&quot; class=&quot;myawesomebutton&quot; ng-transclude&gt; &lt;i class=&quot;icon-ok-sign&quot;&gt;&lt;/i&gt; &lt;/a&gt; 这样做真的很好，浏览器会缓存HTML文件，干的漂亮！设置不缓存的另一个选择是在script标签中声明一个模板： &lt;script type=&quot;text/ng-template&quot; id=&quot;customButton.html&quot;&gt; &lt;a href=&quot;&quot; class=&quot;myawesomebutton&quot; ng-transclude&gt; &lt;i class=&quot;icon-ok-sign&quot;&gt;&lt;/i&gt; &lt;/a&gt; &lt;/script&gt; 你会告诉Angular它是一个模板并且还有一个ID，Angular会查找NG模板或*.HTML文件,他们很容易管理，提高性能和保持DOM很干净，你可以建立1个或100个指令，你可以很容易的浏览它们。 3.Services(服务)服务通常是混淆点。从经验和研究上，他们更多的是一种风格的设计模式，而不是提供更多的功能差异。在深入到Angular源码后,他们指望通过相同的编译器运行，并共享大量的功能。从我的研究来看，你应该在单例，工厂以及其它更复杂的功能上使用服务，如对象字面量和更复杂的用例。 下面是一个Service例子,计算2个数字的乘积： myApp.service(&apos;Math&apos;, function () { this.multiply = function (x, y) { return x * y; }; }); 然后，你应该使用这样的内部控制器： myApp.controller(&apos;MainCtrl&apos;, [&apos;$scope&apos;, function ($scope) { var a = 12; var b = 24; // outputs 288 var result = Math.multiply(a, b); }]); 是的，乘法是很容易的，不需要一个服务，但你领会到了其中的要点。 当你创建一个服务（或工厂）时，你需要使用依赖注入来告诉Angular需要扑获新的服度，否则你会得到编译错误，你的控制器会中断。你可能已经注意到了这个函数($scope)的部分，现在，这是简单的依赖注入。看下你的代码,你也会注意到（$scope）之前的功能（$scope），我会到后面解释。这里是如何使用依赖注入来告诉你需要你的服务： // Pass in Math myApp.controller(&apos;MainCtrl&apos;, [&apos;$scope&apos;, &apos;Math&apos;, function ($scope, Math) { var a = 12; var b = 24; // outputs 288 var result = Math.multiply(a, b); }]); 4.Factories(工厂)从服务到工厂现在应该是简单的，我们可以在工厂里创建一个对象字面量或简单地提供一些更深入的方法： myApp.factory(&apos;Server&apos;, [&apos;$http&apos;, function ($http) { return { get: function(url) { return $http.get(url); }, post: function(url) { return $http.post(url); }, }; }]); 下面，在依赖注入到一个控制器后，我创造了一个Angular的XHR自定义包装。这个例子很简单： myApp.controller(&apos;MainCtrl&apos;, [&apos;$scope&apos;, &apos;Server&apos;, function ($scope, Server) { var jsonGet = &apos;http://myserver/getURL&apos;; var jsonPost = &apos;http://myserver/postURL&apos;; Server.get(jsonGet); Server.post(jsonPost); }]); 如果你想为了改变而轮询服务，你可以设置一个Server.poll(jsonPool),或者假如你正在使用一个Socket,你可以设置Server.socket(jsonSocket).它打开了大门，模块化代码以及创造您使用和保持代码内的控制器，作为一个最小的完整集合。 5.Filters(过滤器)过滤器一般和数组一块使用，用在循环外，如果你遍历数组来筛选出特定的东西，在正确的地方，你也可以使用过滤器过滤用户想要的类型在标签为例，有几个方法可以使用过滤器，在控制器里面或作为一个定义的方法。这里有使用的方法，您可以在全局使用： myApp.filter(&apos;reverse&apos;, function () { return function (input, uppercase) { var out = &apos;&apos;; for (var i = 0; i &lt; input.length; i++) { out = input.charAt(i) + out; } if (uppercase) { out = out.toUpperCase(); } return out; } }); // Controller included to supply data myApp.controller(&apos;MainCtrl&apos;, [&apos;$scope&apos;, function ($scope) { $scope.greeting = &apos;Todd Motto&apos;; }]); DOM内容： &lt;div ng-app=&quot;myApp&quot;&gt; &lt;div ng-controller=&quot;MainCtrl&quot;&gt; &lt;p&gt;No filter: { { greeting } }&lt;/p&gt; &lt;p&gt;Reverse: { { greeting | reverse } }&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; 例子：http://runjs.cn/code/ina2n1lb 可以看到我们通过传递过滤符号“|”在greeting 数据上，对该数据进行逆向过滤。 在标签ng-repeat中的用法为： &lt;ul&gt; &lt;li ng-repeat=&quot;number in myNumbers |filter:oddNumbers&quot;&gt;{{ number }}&lt;/li&gt; &lt;/ul&gt; 一个在controller中使用过滤器的简明例子： myApp.controller(&apos;MainCtrl&apos;, [&apos;$scope&apos;, function ($scope) { $scope.numbers = [10, 25, 35, 45, 60, 80, 100]; $scope.lowerBound = 42; // Does the Filters $scope.greaterThanNum = function (item) { return item &gt; $scope.lowerBound; }; }]); 在ng-repeat标签中的用法为: &lt;li ng-repeat=&quot;number in numbers | filter:greaterThanNum&quot;&gt; {{ number }} &lt;/li&gt; 演示:http://runjs.cn/code/xiricwi3 这是AngularJS中的主体部分和API，虽然这只是冰山一角，但利用这些内容足以建立起你自己的angular应用。 6.Two-way data-binding(双向数据绑定)当我第一次听说双向数据绑定时，我并不太明白它是什么。双向数据绑定是最好的理解为一个完全同步的数据循环：更新模型并更新视图，更新视图并更新模型。这意味着数据不需要做任何操作都是同步的。如果我将一个ng模型绑定到一个标签然后开始输入，这将在同一时间创建（或更新一个现有的）模型。 我创建的一个标签并绑定模型称为”myModel”，然后我可以利用angularjs中的语法来反射这个模型并同时更新视图： &lt;div ng-app=&quot;myApp&quot;&gt; &lt;div ng-controller=&quot;MainCtrl&quot;&gt; &lt;input type=&quot;text&quot; ng-model=&quot;myModel&quot; placeholder=&quot;Start typing...&quot; /&gt; &lt;p&gt;My model data: {{ myModel }}&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; myApp.controller(&apos;MainCtrl&apos;, [&apos;$scope&apos;, function ($scope) { // Capture the model data // and/or initialise it with an existing string $scope.myModel = &apos;&apos;; }]); 示例：http://runjs.cn/code/fu074xjf 7.XHR/Ajax/$http calls and binding JSON你已经掌握了如何把一个基础数据邦定到$scope上，并大致了解了这个model是如何工作的，包括数据的双向邦定。现在是时候学习一些真正的XHR去调用一个服务。对于网站来说，这是没有必要的除非你有特别的Ajax要求，这主要是集中在抓取数据的Web应用程序。 当你在做本地开发时，你可能使用类似Java，ASP.NET，PHP或别的东西来运行一个本地服务器。无论您是和本地数据库通信还是实际使用服务器作为接口来与其他资源进行通信，这都是相同的。 输入$http,就可以愉快的开始了。$HTTP方法是从服务器访问数据的一个很好的Angular包装，你可以很方便的使用。这里是一个“GET”请求的简单例子，它从服务器获取数据。它的语法很像是jQuery，所以很好理解： myApp.controller(&apos;MainCtrl&apos;, [&apos;$scope&apos;, &apos;$http&apos;, function ($scope, $http) { $http({ method: &apos;GET&apos;, url: &apos;//localhost:9000/someUrl&apos; }); }]); Angular然后返回内容(叫做承诺)，这是处理回调的一种更有效和可读的方式。承诺是链接function到他们从使用点.mypromise()。正如预期的那样，我们有错误和成功的处理程序： myApp.controller(&apos;MainCtrl&apos;, [&apos;$scope&apos;, function ($scope) { $http({ method: &apos;GET&apos;, url: &apos;//localhost:9000/someUrl&apos; }) .success(function (data, status, headers, config) { // successful data retrieval }) .error(function (data, status, headers, config) { // something went wrong :( }); }]); 非常好的可读性。这就是我们合并视图和绑定模式或更新模型数据到DOM的服务器。让我们假设一个设置和推动一个用户名的DOM，通过Ajax调用。 理想情况下，我们应该首先建立和设计我们的JSON，这将影响我们如何构造我们的数据。让我们保持简单，这是一个后端开发者将开放一个API在应用程序中，您希望如下： { &quot;user&quot;: { &quot;name&quot;: &quot;Todd Motto&quot;, &quot;id&quot;: &quot;80138731&quot; } } 这意味着我们会得到一个从服务器返回的对象（化名就叫‘数据’[你可以看到数据被传递到我们的承诺处理]），并嵌有data.user属性。在data.user属性里面，有name和id,访问这些很容易的，我们需要寻找data.user.name这个属性时，它将返回这个属性的值。现在让我们来操作下吧！ JavaScript代码： myApp.controller(&apos;UserCtrl&apos;, [&apos;$scope&apos;, &apos;$http&apos;, function ($scope, $http) { // create a user Object $scope.user = {}; // Initiate a model as an empty string $scope.user.username = &apos;&apos;; // We want to make a call and get // the person&apos;s username $http({ method: &apos;GET&apos;, url: &apos;//localhost:9000/someUrlForGettingUsername&apos; }) .success(function (data, status, headers, config) { // See here, we are now assigning this username // to our existing model! $scope.user.username = data.user.name; }) .error(function (data, status, headers, config) { // something went wrong :( }); }]); DOM代码： &lt;div ng-controller=&quot;UserCtrl&quot;&gt; &lt;p&gt;{{ user.username }}&lt;/p&gt; &lt;/div&gt; 它会打印username的值。下面我们将进一步了解声明式数据绑定，这是非常令人兴奋的。 8.Declarative data-binding(声明式数据邦定)Angular的理念是创建动态HTML.它是一个强大的功能,代替了你在客户端做的大量工作。这正是他的目的所在。 让我们想象一下，我们刚刚作了一个Ajax请求得到一些电子邮件的列表包含主题，发送日期，现在想把它们展示在DOM中。这里会体现出Angular的优势。首先，我需要设置一个电子邮件的controller： myApp.controller(&apos;EmailsCtrl&apos;, [&apos;$scope&apos;, function ($scope) { // create a emails Object $scope.emails = {}; // pretend data we just got back from the server // this is an ARRAY of OBJECTS $scope.emails.messages = [{ &quot;from&quot;: &quot;Steve Jobs&quot;, &quot;subject&quot;: &quot;I think I&apos;m holding my phone wrong :/&quot;, &quot;sent&quot;: &quot;2013-10-01T08:05:59Z&quot; },{ &quot;from&quot;: &quot;Ellie Goulding&quot;, &quot;subject&quot;: &quot;I&apos;ve got Starry Eyes, lulz&quot;, &quot;sent&quot;: &quot;2013-09-21T19:45:00Z&quot; },{ &quot;from&quot;: &quot;Michael Stipe&quot;, &quot;subject&quot;: &quot;Everybody hurts, sometimes.&quot;, &quot;sent&quot;: &quot;2013-09-12T11:38:30Z&quot; },{ &quot;from&quot;: &quot;Jeremy Clarkson&quot;, &quot;subject&quot;: &quot;Think I&apos;ve found the best car... In the world&quot;, &quot;sent&quot;: &quot;2013-09-03T13:15:11Z&quot; }]; }]); 现在我们需要把它插入到我们的HTML中。这时我们会使用声明式绑定宣布什么应用程序将创建我们的第一个动态HTML。我们要用到Angular的内置指令ng-repeat，它会遍历数据，完全没有回调或状态变化的渲染输出，这都是非常灵活的： &lt;ul&gt; &lt;li ng-repeat=&quot;message in emails.messages&quot;&gt; &lt;p&gt;From: {{ message.from }}&lt;/p&gt; &lt;p&gt;Subject: {{ message.subject }}&lt;/p&gt; &lt;p&gt;{{ message.sent | date:'MMM d, y h:mm:ss a' }}&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; 示例：http://runjs.cn/code/q9beqc9s 我使用了一个日期过滤器，从中你可以看到如何处理UTC日期。 深入Angular的ng-*指令,你将完全释放出angular的声明式绑定的能力，这里展示了如何从服务器到模型，以及模拟和渲染数据。 9.Scope functions(范围函数)作为声明性绑定的延续，范围函数是在创建应用程序时的下一个层次。这里展示了一个基本功能，删除我们的电子邮件中的一个数据： myApp.controller(&apos;MainCtrl&apos;, [&apos;$scope&apos;, function ($scope) { $scope.deleteEmail = function (index) { $scope.emails.messages.splice(index, 1) }; }]); 友情提示：重要的一点是要考虑从模型中删除数据。不删除元素或任何实际的DOM相关，angular是一个MVC框架，将为您处理这一切与它的双向绑定和回调的自由世界，你只需要设置你的代码可以让它响应你的数据！ &lt;a ng-click=&quot;deleteEmail($index)&quot;&gt;Delete email&lt;/a&gt; 这是一种不同的内联点击处理程序，因为许多原因。这将很快覆盖。你会看到我也在通过$index，angular知道你正在删除的项目（这样可以节省你多少代码和逻辑！）。 示例：http://runjs.cn/code/jm84qnh3 10.Declarative DOM methods(陈述性DOM方法)现在我们要转移到的DOM方法，这些也都是些指令和模拟功能的DOM，你通常会写出更多的逻辑脚本。这个例子是一个简单的切换导航。用一个简单的ng-show和一个简单的ng-click设置，我们可以创建一个完美无瑕的切换导航： &lt;a href=&quot;&quot; ng-click=&quot;toggle = !toggle&quot;&gt;Toggle nav&lt;/a&gt; &lt;ul ng-show=&quot;toggle&quot;&gt; &lt;li&gt;Link 1&lt;/li&gt; &lt;li&gt;Link 2&lt;/li&gt; &lt;li&gt;Link 3&lt;/li&gt; &lt;/ul&gt; 我们开始进入MVVM的学习，你会发现脚本里没有controller的代码，我们会很快进入MVVM。 示例：http://runjs.cn/code/r5tlnqrb 11.Expressions(表达式)我最喜欢Angular的一部分是，你会用JavaScript写出很多重复的代码。 你尝试过这个吗？ elem.onclick = function (data) { if (data.length === 0) { otherElem.innerHTML = &apos;No data&apos;; } else { otherElem.innerHTML = &apos;My data&apos;; } }; 这可能是一个GET请求回调，你会改变基于数据的DOM。Angular给你这个自由，你就可以做到无需编写任何内置的JavaScript！ &lt;p&gt;{{ data.length > 0 && 'My data' || 'No data' }}&lt;/p&gt; 这会动态更新自己而没有回调应用程序获取数据。如果没有数据，它会告诉你，如果有数据，它会显示数据。针对Angular处理自动双向绑定数据，会有很多的使用情况。 示例：http://runjs.cn/code/ahl0hfcc 12.Dynamic views and routing(动态视图和路由)单页面web应用(也包括网站)背后的理念是: 你有一个标题，页脚，侧边栏，和中间的内容,通过设置URL可以神奇地注入新的内容。 Angular通过一个简单的设置来配置我们所说的动态视图。动态视图依靠URL注入每个视图，通过$routeprovider。一个简单的设置如下： myApp.config([&apos;$routeProvider&apos;, function ($routeProvider) { /** * $routeProvider */ $routeProvider .when(&apos;/&apos;, { templateUrl: &apos;views/main.html&apos; }) .otherwise({ redirectTo: &apos;/&apos; }); }]); 你会看到，当URL是”/“(即该站点的根目录),你会注入main.html。当你在一个单页面应用中已经有一个index.html页面，这是一个好的方法去调用内部的main.html视图而不是index.html。依靠URL去添加更多的视图是如此简单： myApp.config([&apos;$routeProvider&apos;, function ($routeProvider) { /** * $routeProvider */ $routeProvider .when(&apos;/&apos;, { templateUrl: &apos;views/main.html&apos; }) .when(&apos;/emails&apos;, { templateUrl: &apos;views/emails.html&apos; }) .otherwise({ redirectTo: &apos;/&apos; }); }]); 我们可以在emails.html上简单的加载HTML去生成我们的邮件列表,最终你可以毫不费力的创建一个复杂的应用程序。 13.Global static data(全局静态数据)Gmail处理很多内部初始化数据是通过将JSON加入到页面中(右键查看源代码)。如果你想立即在你的页面设置数据，它会加快渲染时间并且Angular将更快的执行。 当我们开发应用程序时，页面渲染时，Java标签放置在DOM中，数据从后台发送过来。[我没有Java开发经验，你需要知道一个下面的声明，虽然在服务器上你可以使用任何语言。]这里是如何把JSON加入到网页中，然后把它传给一个控制器,为即时邦定使用： &lt;!-- inside index.html (bottom of page ofc) --&gt; &lt;script&gt; window.globalData = {}; globalData.emails = &lt;javaTagHereToGenerateMessages&gt;; &lt;/script&gt; 我定义的java标签使数据能在页面中渲染，Angular会轻松的渲染你的emails数据，只要把你的数据放入到controller中即可: myApp.controller(&apos;EmailsCtrl&apos;, [&apos;$scope&apos;, function ($scope) { $scope.emails = {}; // Assign the initial data! $scope.emails.messages = globalData.emails; }]); 14.Minification(精简)这一段是关于精简你的angular代码内容。在这方面你可能已经尝试过了，有时跑一个精简过的代码，会遇到了一个错误！ 精简你的AngularJS代码很简单，你需要指定你的依赖注入的内容在函数数组： myApp.controller(&apos;MainCtrl&apos;, [&apos;$scope&apos;, &apos;Dependency&apos;, &apos;Service&apos;, &apos;Factory&apos;, function ($scope, Dependency, Service, Factory) { // code }]); 精简后: myApp.controller(&apos;MainCtrl&apos;, [&apos;$scope&apos;, &apos;Dependency&apos;, &apos;Service&apos;, &apos;Factory&apos;, function (a,b,c,d) { // a = $scope // b = Dependency // c = Service // d = Factory // $scope alias usage a.someFunction = function () {...}; }]); 请记住，以保持参数的顺序出现，否则你可能会导致你和你的团队费劲。 15.Differences in MVC and MVVM(MVC和MVVM的差异)这里简要介绍两者的区别: MVC: 用一个controller交互,关系是Model-View-ControllerMVVM: 封装声明数据邦定,Model-View-View-Model,Model和View交互,View也可以和Model交互,Angular的双向数据绑定允许它在不做任何事情时保持同步。它还允许你在没有控制器的情况下,编写逻辑代码！ 一个简单的例子，你可以创建一个ng-repeat标签去提供数据,而不需要Controller: &lt;li ng-repeat=&quot;number in [1,2,3,4,5,6,7,8,9]&quot;&gt; {{ number }} &lt;/li&gt; 对于快速测试这是很有帮助的，但对与复杂的情况时，我建议使用一个Controller。 16.HTML5 Web Components(HTML5组件)在早些时候你会发现AngularJS允许你创建自定义的元素: &lt;myCustomElement&gt;&lt;/myCustomElement&gt; 这实际上是符合HTML5未来的特性。HTML5 Web部件和模板元素，Angular让我们今天就能这样用。Web部件包括通过动态JavaScript注入生成的自定义元素！ 17.Scope comments(范围注释)范围注释,我觉得真的是一个不错特性,代替了HTML注释，像这样的块： &lt;!-- header --&gt; &lt;header&gt; Stuff. &lt;/header&gt; &lt;!-- /header --&gt; 引入Angular后，让我们思考的是Views和Scopes，而不是DOM，除非你故意共享控制器间的数据，我发现使用范围是一个很大的帮助： &lt;!-- scope: MainCtrl --&gt; &lt;div class=&quot;content&quot; ng-controller=&quot;MainCtrl&quot;&gt; &lt;/div&gt; &lt;!-- /scope: MainCtrl --&gt; 18.Debugging AngularJS(调试)对于调试AngularJS的话，可以使用Chrome的一个扩展工具-Batarang,你可以去下载下看看。 结束到此本文结束,希望能够对大家学习angular有一个好的指导，更多关于angular的细节可以参看Todd Motto 的系列文章再次感谢原作者的整理，文中如有不对的地方可以指出。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>AngularJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据处理工具汇总]]></title>
    <url>%2F2015%2F07%2F29%2F2015-07-29-%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[目录{:toc #meuid} 查询引擎一、Phoenix贡献者：：Salesforce 简介：这是一个Java中间层，可以让开发者在Apache HBase上执行SQL查询。Phoenix完全使用Java编写，代码位于GitHub上，并且提供了一个客户端可嵌入的JDBC驱动。 Phoenix查询引擎会将SQL查询转换为一个或多个HBase scan，并编排执行以生成标准的JDBC结果集。直接使用HBase API、协同处理器与自定义过滤器，对于简单查询来说，其性能量级是毫秒，对于百万级别的行数来说，其性能量级是秒。 Phoenix最值得关注的一些特性有： ❶嵌入式的JDBC驱动，实现了大部分的java.sql接口，包括元数据API ❷可以通过多部行键或是键/值单元对列进行建模 ❸完善的查询支持，可以使用多个谓词以及优化的扫描键 ❹DDL支持：通过CREATE TABLE、DROP TABLE及ALTER TABLE来添加/删除列 ❺版本化的模式仓库：当写入数据时，快照查询会使用恰当的模式 ❻DML支持：用于逐行插入的UPSERT VALUES、用于相同或不同表之间大量数据传输的UPSERT ❼SELECT、用于删除行的DELETE ❽通过客户端的批处理实现的有限的事务支持 ❾单表——还没有连接，同时二级索引也在开发当中 ➓紧跟ANSI SQL标准 Phoenix官方网站&gt;&gt;&gt; 二、Stinger贡献者：：Hortonworks 简介：原叫Tez，下一代Hive,Hortonworks主导开发，运行在YARN上的DAG计算框架。 某些测试下，Stinger能提升10倍左右的性能，同时会让Hive支持更多的SQL，其主要优点包括： ❶让用户在Hadoop获得更多的查询匹配。其中包括类似OVER的字句分析功能，支持WHERE查询，让Hive的样式系统更符合SQL模型。 ❷优化了Hive请求执行计划，优化后请求时间减少90%。改动了Hive执行引擎，增加单Hive任务的被秒处理记录数。 ❸在Hive社区中引入了新的列式文件格式（如ORC文件），提供一种更现代、高效和高性能的方式来储存Hive数据。 ❹引入了新的运行时框架——Tez，旨在消除Hive的延时和吞吐量限制。Tez通过消除不必要的task、障碍同步和对HDFS的读写作业来优化Hive job。这将优化Hadoop内部的执行链，彻底加速Hive负载处理。 Stinger官方网站&gt;&gt;&gt; 三、Presto贡献者：：Facebook 简介：Facebook开源的数据查询引擎Presto ，可对250PB以上的数据进行快速地交互式分析。该项目始于 2012 年秋季开始开发，目前该项目已经在超过 1000 名 Facebook 雇员中使用，运行超过 30000 个查询，每日数据在 1PB 级别。Facebook 称 Presto 的性能比诸如 Hive 和 Map*Reduce 要好上 10 倍有多。 Presto 当前支持 ANSI SQL 的大多数特效，包括联合查询、左右联接、子查询以及一些聚合和计算函数；支持近似截然不同的计数(DISTINCT COUNT)等。 github源代码下载&gt;&gt;&gt; 四、Shark简介：Shark即Hive on Spark，本质上是通过Hive的HQL解析，把HQL翻译成Spark上的RDD操作，然后通过Hive的metadata获取数据库里的表信息，实际HDFS上的数据和文件，会由Shark获取并放到Spark上运算。Shark的特点就是快，完全兼容Hive，且可以在shell模式下使用rdd2sql()这样的API，把HQL得到的结果集，继续在scala环境下运算，支持自己编写简单的机器学习或简单分析处理函数，对HQL结果进一步分析计算。 ❶Shark速度快的原因除了Spark平台提供的基于内存迭代计算外，在设计上还存在对Spark上进行了一定的改造，主要有 ❷partial DAG execution：对join优化，调节并行粒度，因为Spark本身的宽依赖和窄依赖会影响并行计算和速度 基于列的压缩和存储：把HQL表数据按列存，每列是一个array，存在JVM上，避免了JVM GC低效，而压缩和解压相关的技术是Yahoo!提供的。 结来说，Shark是一个插件式的东西，在我现有的Spark和Hive及hadoop-client之间，在这两套都可用的情况下，Shark只要获取Hive的配置（还有metastore和exec等关键包），Spark的路径，Shark就能利用Hive和Spark，把HQL解析成RDD的转换，把数据取到Spark上运算和分析。在SQL on Hadoop这块，Shark有别于Impala，Stringer，而这些系统各有自己的设计思路，相对于对MR进行优化和改进的思路，Shark的思路更加简单明了些 Shark官方网站&gt;&gt;&gt; 五、Pig简介：Pig是一种编程语言，它简化了Hadoop常见的工作任务。Pig可加载数据、表达转换数据以及存储最终结果。Pig内置的操作使得半结构化数据变得有意义（如日志文件）。同时Pig可扩展使用Java中添加的自定义数据类型并支持数据转换。 Pig最大的作用就是对mapreduce算法(框架)实现了一套shell脚本 ，类似我们通常熟悉的SQL语句，在Pig中称之为Pig Latin，在这套脚本中我们可以对加载出来的数据进行排序、过滤、求和、分组(group by)、关联(Joining)，Pig也可以由用户自定义一些函数对数据集进行操作，也就是传说中的UDF(user-defined functions)。 Pig官方网站&gt;&gt;&gt; 六、Cloudera Impala贡献者：:Cloudera 简介：Cloudera Impala 可以直接为存储在HDFS或HBase中的Hadoop数据提供快速，交互式的SQL查询。除了使用相同的存储平台外， Impala和Apache Hive一样也使用了相同的元数据，SQL语法（Hive SQL），ODBC驱动和用户接口（Hue Beeswax），这就很方便的为用户提供了一个相似并且统一的平台来进行批量或实时查询。 Cloudera Impala 是用来进行大数据查询的补充工具。 Impala 并没有取代像Hive这样基于MapReduce的分布式处理框架。Hive和其它基于MapReduce的计算框架非常适合长时间运行的批处理作业，例如那些涉及到批量 Extract、Transform、Load ，即需要进行ETL作业。 Impala 提供了： ❶数据科学家或数据分析师已经熟知的SQL接口 ❷能够在Apache Hadoop 的大数据中进行交互式数据查询 ❸ Single system for big data processing and analytics so customers can avoid costly modeling and ETL just for analytics Cloudera Impala官方网站&gt;&gt;&gt; 七、Apache Drill贡献者：：MapR 简介：Apache Drill是是一个能够对大数据进行交互分析、开源的分布式系统，且基于Google Dremel实现，它能够运行在上千个节点的服务器集群上，且能在几秒内处理PB级或者万亿条的数据记录。Drill能够帮助企业用户快速、高效地进行Hadoop数据查询和企业级大数据分析。Drill于2012年8月份由Apache推出。 从Drill官方对其架构的介绍中得知，其具有适于实时的分析和快速的应用开发、适于半结构化/嵌套数据的分析、兼容现有的SQL环境和Apache Hive等特征。另外，Drill的核心模块是Drillbit服务，该服务模块包括远程访问子模块、SQL解析器、查询优化器、任务计划执行引擎、存储插件接口（DFS、HBase、Hive等的接口）、分布式缓存模块等几部分，如下图所示： Apache Drill官方网站&gt;&gt;&gt; 八、Apache Tajo简介：Apache Tajo项目的目的是在HDFS之上构建一个先进的数据仓库系统。Tajo将自己标榜为一个“大数据仓库”，但是它好像和之前介绍的那些低延迟查询引擎类似。虽然它支持外部表和Hive数据集（通过HCatalog），但是它的重点是数据管理，提供低延迟的数据访问，以及为更传统的ETL提供工具。它也需要在数据节点上部署Tajo特定的工作进程。 Tajo的功能包括： ❶ANSI SQL兼容❷JDBC 驱动❸集成Hive metastore能够访问Hive数据集❹一个命令行客户端❺一个自定义函数API Apache Tajo官方网站&gt;&gt;&gt; 九、Hive简介：hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供简单的sql查询功能，可以将sql语句转换为MapReduce任务进行运行。 其优点是学习成本低，可以通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析。 Hive官方网站&gt;&gt;&gt; 流式计算一、Facebook Puma贡献者：Facebook 简介：实时数据流分析 二、Twitter Rainbird贡献者：Twitter 简介：Rainbird一款基于Zookeeper, Cassandra, Scribe, Thrift的分布式实时统计系统，这些基础组件的基本功能如下： ❶ Zookeeper，Hadoop子项目中的一款分布式协调系统，用于控制分布式系统中各个组件中的一致性。 ❷Cassandra，NoSQL中一款非常出色的产品，集合了Dynamo和Bigtable特性的分布式存储系统，用于存储需要进行统计的数据，统计数据，并且提供客户端进行统计数据的查询。（需要使用分布式Counter补丁CASSANDRA-1072） ❸ Scribe，Facebook开源的一款分布式日志收集系统，用于在系统中将各个需要统计的数据源收集到Cassandra中。 ❹ Thrift，Facebook开源的一款跨语言C/S网络通信框架，开发人员基于这个框架可以轻易地开发C/S应用。 用处 Rainbird可以用于实时数据的统计： ❶统计网站中每一个页面，域名的点击次数 ❷内部系统的运行监控（统计被监控服务器的运行状态） ❸记录最大值和最小值 三、Yahoo S4贡献者：Yahoo 简介：S4（Simple Scalable Streaming System）最初是Yahoo!为提高搜索广告有效点击率的问题而开发的一个平台，通过统计分析用户对广告的点击率，排除相关度低的广告，提升点击率。目前该项目刚启动不久，所以也可以理解为是他们提出的一个分布式流计算（Distributed Stream Computing）的模型。 S4的设计目标是： ·提供一种简单的编程接口来处理数据流 ·设计一个可以在普通硬件之上可扩展的高可用集群。 ·通过在每个处理节点使用本地内存，避免磁盘I/O瓶颈达到最小化延迟 ·使用一个去中心的，对等架构；所有节点提供相同的功能和职责。没有担负特殊责任的中心节点。这大大简化了部署和维护。 ·使用可插拔的架构，使设计尽可能的即通用又可定制化。 ·友好的设计理念，易于编程，具有灵活的弹性 Yahoo S4官方网站&gt;&gt;&gt; 四、Twitter Storm贡献者：Twitter 简介：Storm是Twitter开源的一个类似于Hadoop的实时数据处理框架，它原来是由BackType开发，后BackType被Twitter收购，将Storm作为Twitter的实时数据分析系统。 实时数据处理的应用场景很广泛，例如商品推荐，广告投放，它能根据当前情景上下文（用户偏好，地理位置，已发生的查询和点击等）来估计用户点击的可能性并实时做出调整。 storm的三大作用领域： 1.信息流处理（Stream Processing） Storm可以用来实时处理新数据和更新数据库，兼具容错性和可扩展性,它 可以用来处理源源不断的消息，并将处理之后的结果保存到持久化介质中。 2.连续计算（Continuous Computation） Storm可以进行连续查询并把结果即时反馈给客户，比如将Twitter上的热门话题发送到客户端。 3.分布式远程过程调用（Distributed RPC） 除此之外，Storm也被广泛用于以下方面： 精确的广告推送实时日志的处理 Twitter Storm官方网站&gt;&gt;&gt; ##迭代计算 一、Apache Hama简介：Apache Hama是一个纯BSP（Bulk Synchronous Parallel）计算框架，模仿了Google的Pregel。用来处理大规模的科学计算，特别是矩阵和图计算。 ❶建立在Hadoop上的分布式并行计算模型。 ❷基于 Map/Reduce 和 Bulk Synchronous 的实现框架。 ❸运行环境需要关联 Zookeeper、HBase、HDFS 组件。 Hama中有2个主要的模型: – 矩阵计算(Matrix package) – 面向图计算(Graph package) Apache Hama官方网站&gt;&gt;&gt; 二、Apache Giraph代码托管地址： GitHub 简介：Apache Giraph是一个可伸缩的分布式迭代图处理系统，灵感来自BSP（bulk synchronous parallel）和Google的Pregel，与它们 区别于则是是开源、基于 Hadoop 的架构等。 Giraph处理平台适用于运行大规模的逻辑计算，比如页面排行、共享链接、基于个性化排行等。Giraph专注于社交图计算，被Facebook作为其Open Graph工具的核心，几分钟内处理数万亿次用户及其行为之间的连接。 三、HaLoop简介：迭代的MapReduce，HaLoop——适用于迭代计算的Hadoop 。 Hadoop与HaLoop的不同 与Hadoop比较的四点改变： 1.提供了一套新的编程接口，更加适用于迭代计算； HaLoop给迭代计算一个抽象的递归公式： 2.HaLoop的master进行job内的循环控制，直到迭代计算结束； 3.Task Scheduler也进行了修改，使得任务能够尽量满足data locality 4.slave nodes对数据进行cache并index索引，索引也以文件的形式保存在本地磁盘。 HaLoop官网&gt;&gt;&gt; 四、Twister简介：Twister， 迭代式MapReduce框架，Twister是由一个印度人开发的，其架构如下： 在Twister中，大文件不会自动被切割成一个一个block，因而用户需提前把文件分成一个一个小文件，以供每个task处理。在map阶段，经过map（）处理完的结果被放在分布式内存中，然后通过一个broker network（NaradaBroking系统）将数据push给各个reduce task（Twister假设内存足够大，中间数据可以全部放在内存中）；在reduce阶段，所有reduce task产生的结果通过一个combine操作进行归并，此时，用户可以进行条件判定， 确定迭代是否结束。combine后的数据直接被送给map task，开始新一轮的迭代。为了提高容错性，Twister每隔一段时间会将map task和reduce task产生的结果写到磁盘上，这样，一旦某个task失败，它可以从最近的备份中获取输入，重新计算。 为了避免每次迭代重新创建task，Twister维护了一个task pool，每次需要task时直接从pool中取。在Twister中，所有消息和数据都是通过broker network传递的，该broker network是一个独立的模块，目前支持NaradaBroking和ActiveMQ。 离线计算一、Hadoop MapReduce简介：MapReduce是一种编程模型，用于大规模数据集（大于1TB）的并行运算。概念”Map（映射）”和”Reduce（归约）”，和它们的主要思想，都是从函数式编程语言里借来的，还有从矢量编程语言里借来的特性。它极大地方便了编程人员在不会分布式并行编程的情况下，将自己的程序运行在分布式系统上。 当前的软件实现是指定一个Map（映射）函数，用来把一组键值对映射成一组新的键值对，指定并发的Reduce（归约）函数，用来保证所有映射的键值对中的每一个共享相同的键组。 Hadoop MapReduce官方网站&gt;&gt;&gt; 二、Berkeley Spark简介：Spark是UC Berkeley AMP lab所开源的类Hadoop MapReduce的通用的并行，Spark，拥有Hadoop MapReduce所具有的优点；但不同于MapReduce的是Job中间输出结果可以保存在内存中，从而不再需要读写HDFS，因此Spark能更好地适用于数据挖掘与机器学习等需要迭代的map reduce的算法。 三、DataTorrent简介：DataTorrent基于Hadoop 2.x构建，是一个实时的、有容错能力的数据流式处理和分析平台，它使用本地Hadoop应用程序，而这些应用程序可以与执行其它任务，如批处理，的应用程序共存。该平台的架构如下图所示： 相关文章：DataTorrent 1.0每秒处理超过10亿个实时事件 DataTorrent 将数据分析速度从“实时”提升至“现在时” 键值存储一、LevelDB 贡献者：Google 简介：Leveldb是一个google实现的非常高效的kv数据库，目前的版本1.2能够支持billion级别的数据量了。 在这个数量级别下还有着非常高的性能，主要归功于它的良好的设计。特别是LMS算法。 LevelDB 是单进程的服务，性能非常之高，在一台4核Q6600的CPU机器上，每秒钟写数据超过40w，而随机读的性能每秒钟超过10w。 此处随机读是完全命中内存的速度，如果是不命中 速度大大下降。 LevelDB官方网站&gt;&gt;&gt; 二、RocksDB贡献者：facebook 简介：RocksDB虽然在代码层面上是在LevelDB原有的代码上进行开发的，但却借鉴了Apache HBase的一些好的idea。在云计算横行的年代，开口不离Hadoop，RocksDB也开始支持HDFS，允许从HDFS读取数据。RocksDB支持一次获取多个K-V，还支持Key范围查找。LevelDB只能获取单个Key。 RocksDB除了简单的Put、Delete操作，还提供了一个Merge操作，说是为了对多个Put操作进行合并。 RocksDB提供一些方便的工具，这些工具包含解析sst文件中的K-V记录、解析MANIFEST文件的内容等。RocksDB支持多线程合并，而LevelDB是单线程合并的。 RocksDB官方网站&gt;&gt;&gt; 三、HyperDex贡献者：Facebook HyperDex是一个分布式、可搜索的键值存储系统，特性如下： 分布式KV存储，系统性能能够随节点数目线性扩展吞吐和延时都能秒杀现在风头正劲的MonogDB，吞吐甚至强于Redis使用了hyperspace hashing技术，使得对存储的K-V的任意属性进行查询成为可能 官网：http://hyperdex.org/ 四、TokyoCabinet 日本人Mikio Hirabayashi（平林干雄）开发的一款DBM数据库。Tokyo Cabinet 是一个DBM的实现。这里的数据库由一系列key-value对的记录构成。key和value都可以是任意长度的字节序列,既可以是二进制也可以是字符串。这里没有数据类型和数据表的概念。当 做为Hash表数据库使用时，每个key必须是不同的,因此无法存储两个key相同的值。提供了以下访问方法:提供key,value参数来存储，按 key删除记录，按key来读取记录，另外，遍历key也被支持，虽然顺序是任意的不能被保证。这些方法跟Unix标准的DBM,例如GDBM,NDBM 等等是相同的，但是比它们的性能要好得多（因此可以替代它们) 。下一代KV存储系统，支持strings、integers、floats、lists、maps和sets等丰富的数据类型。 TokyoCabinet官方网站&gt;&gt;&gt; 五、Voldemort Voldemort是一个分布式键值存储系统，是Amazon’s Dynamo的一个开源克隆。特性如下：支持自动复制数据到多个服务器上。支持数据自动分割所以每个服务器只包含总数据的一个子集。提供服务器故障透明处理功能。支持可拨插的序化支持，以实现复杂的键-值存储，它能够很好的5.集成常用的序化框架如：Protocol Buffers、Thrift、Avro和Java Serialization。数据项都被标识版本能够在发生故障时尽量保持数据的完整性而不会影响系统的可用性。每个节点相互独立，互不影响。支持可插拔的数据放置策略官网：http://project-voldemort.com/ 六、Amazon Dynamo贡献者：亚马逊 简介：Amazon Dynamo 是一个经典的分布式Key-Value 存储系统，具备去中心化，高可用性，高扩展性的特点，但是为了达到这个目标在很多场景中牺牲了一致性。Dynamo在Amazon中得到了成功的应用，能够跨数据中心部署于上万个结点上提供服务，它的设计思想也被后续的许多分布式系统借鉴。如近来火热的Cassandra，实际上就是基本照搬了Dynamo的P2P架构，同时融合了BigTable的数据模型及存储算法。 Amazon Dynamo官方网站&gt;&gt;&gt; 七、Tair贡献者：淘宝 简介：tair 是淘宝自己开发的一个分布式 key/value 存储引擎. tair 分为持久化和非持久化两种使用方式. 非持久化的 tair 可以看成是一个分布式缓存. 持久化的 tair 将数据存放于磁盘中. 为了解决磁盘损坏导致数据丢失, tair 可以配置数据的备份数目, tair 自动将一份数据的不同备份放到不同的主机上, 当有主机发生异常, 无法正常提供服务的时候, 其于的备份会继续提供服务.tair 的总体结构 Tairtair 作为一个分布式系统, 是由一个中心控制节点和一系列的服务节点组成. 我们称中心控制节点为config server. 服务节点是data server. config server 负责管理所有的data server, 维护data server的状态信息. data server 对外提供各种数据服务, 并以心跳的形式将自身状况汇报给config server. config server是控制点, 而且是单点, 目前采用一主一备的形式来保证其可靠性. 所有的 data server 地位都是等价的. 八、Apache Accumulo Apache Accumulo 是一个可靠的、可伸缩的、高性能的排序分布式的 Key-Value 存储解决方案，基于单元访问控制以及可定制的服务器端处理。Accumulo使用 Google BigTable 设计思路，基于 Apache Hadoop、Zookeeper 和 Thrift 构建。 官网：http://accumulo.apache.org/ 九、Redis Redis是一个高性能的key-value存储系统，和Memcached类似，它支持存储的value类型相对更多，包括string（字符串）、list（链表）、set（集合）和zset（有序集合）。与memcached一样，为了保证效率，数据都是缓存在内存中，区别的是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了主从同步。 Redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部分场合可以对关系数据库起到很好的补充作用。它提供了Python、Ruby、Erlang、PHP客户端，使用很方便。 官网：http://redis.io/ 表格存储一、OceanBase贡献者：阿里巴巴 相关文章：26页PPT解密支撑支付宝交易的分布式数据库系统——OceanBase 简介：OceanBase是一个支持海量数据的高性能分布式数据库系统，实现了数千亿条记录、数百TB数据上的跨行跨表事务，由淘宝核心系统研发部、运维、DBA、广告、应用研发等部门共同完成。在设计和实现OceanBase的时候暂时摒弃了不紧急的DBMS的功能，例如临时表，视图(view)，研发团队把有限的资源集中到关键点上，当前 OceanBase主要解决数据更新一致性、高性能的跨表读事务、范围查询、join、数据全量及增量dump、批量数据导入。 目前OceanBase已经应用于淘宝收藏夹，用于存储淘宝用户收藏条目和具体的商品、店铺信息，每天支持4～5千万的更新操作。等待上线的应用还包括CTU、SNS等，每天更新超过20亿，更新数据量超过2.5TB，并会逐步在淘宝内部推广。 OceanBase 0.3.1在Github开源，开源版本为Revision:12336。 官网：http://alibaba.github.io/oceanbase/ 二、Amazon SimpleDB贡献者：亚马逊 Amazon SimpleDB是一个分散式数据库，以Erlang撰写。同与Amazon EC2和亚马逊的S3一样作为一项Web 服务，属于亚马逊网络服务的一部分。 正如EC2和S3，SimpleDB的按照存储量，在互联网上的传输量和吞吐量收取费用。 在2008年12月1日，亚马逊推出了新的定价策略，提供了免费1 GB的数据和25机器小时的自由层(Free Tire)。 将其中的数据转移到其他亚马逊网络服务是免费的。 它是一个可大规模伸缩、用 Erlang 编写的高可用数据存储。 官网：http://aws.amazon.com/cn/simpledb/ 三、Vertica贡献者：惠普 简介：惠普2011年2月份起始3月21号完成收购Vertica。Vertica基于列存储。基于列存储的设计相比传统面向行存储的数据库具有巨大的优势。同时Vertica支持MPP（massively parallel processing）等技术，查询数据时Vertica只需取得需要的列，而不是被选择行的所有数据，其平均性能可提高50x-1000x倍。（查询性能高速度快） Vertica的设计者多次表示他们的产品围绕着高性能和高可用性设计。由于对MPP技术的支持，可提供对粒度，可伸缩性和可用性的优势。每个节点完全独立运作，完全无共享架构，降低对共享资源的系统竞争。 Vertica的数据库使用标准的SQL查询，同时Vertica的架构非常适合云计算，包括虚拟化，分布式多节点运行等，并且可以和Hadoop/MapReduce进行集成。 Vertica官网：http://www.vertica.com/ 四、Cassandra贡献者：facebook 相关文章：开源分布式NoSQL数据库系统——Cassandra Cassandra与HBase的大数据对决 谁是胜者？ 简介：Cassandra是一套开源分布式NoSQL数据库系统。它最初由Facebook开发，用于储存收件箱等简单格式数据，集GoogleBigTable的数据模型与Amazon Dynamo的完全分布式的架构于一身Facebook于2008将 Cassandra 开源，此后，由于Cassandra良好的可扩放性，被Digg、Twitter等知名Web 2.0网站所采纳，成为了一种流行的分布式结构化数据存储方案。 Cassandra是一个混合型的非关系的数据库，类似于Google的BigTable。其主要功能比Dynamo （分布式的Key-Value存储系统）更丰富，但支持度却不如文档存储MongoDB（介于关系数据库和非关系数据库之间的开源产品，是非关系数据库当中功能最丰富，最像关系数据库的。支持的数据结构非常松散，是类似json的bjson格式，因此可以存储比较复杂的数据类型）。Cassandra最初由Facebook开发，后转变成了开源项目。它是一个网络社交云计算方面理想的数据库。以Amazon专有的完全分布式的Dynamo为基础，结合了Google BigTable基于列族（Column Family）的数据模型。P2P去中心化的存储。很多方面都可以称之为Dynamo 2.0。 Cassandra官网：http://cassandra.apache.org/ 五、HyperTable 简介：Hypertable是一个开源、高性能、可伸缩的数据库，它采用与Google的Bigtable相似的模型。在过去数年中，Google为在PC集群 上运行的可伸缩计算基础设施设计建造了三个关键部分。 第一个关键的基础设施是Google File System（GFS），这是一个高可用的文件系统，提供了一个全局的命名空间。它通过跨机器（和跨机架）的文件数据复制来达到高可用性，并因此免受传统 文件存储系统无法避免的许多失败的影响，比如电源、内存和网络端口等失败。第二个基础设施是名为Map-Reduce的计算框架，它与GFS紧密协作，帮 助处理收集到的海量数据。第三个基础设施是Bigtable，它是传统数据库的替代。Bigtable让你可以通过一些主键来组织海量数据，并实现高效的 查询。Hypertable是Bigtable的一个开源实现，并且根据我们的想法进行了一些改进。 HyperTable官网：http://hypertable.org/ 六、FoundationDB简介：支持ACID事务处理的NoSQL数据库，提供非常好的性能、数据一致性和操作弹性。 2015年1月2日，FoundationDB已经发布了其key-value数据库的3.0版本，主要专注于可伸缩性和性能上的改善。FoundationDB的CEO David Rosenthal在一篇博客上宣布了新的版本，其中展示了FoundationDB 3.0在可伸缩性方面的数据，它可以在一个32位的c3.8xlarge EC2实例上每秒写入1440万次；这在性能上是之前版本的36倍。 除了性能和可伸缩性的改善之外，FoundationDB 3.0还包含了对监控支持的改善。这种监控机制不仅仅是简单的机器检查，它添加了对多种潜在的硬件瓶颈的诊断，并且把那些高层级的信息整合到现有监控基础架构中。 官网：https://foundationdb.com/ 七：HBase贡献者： Fay Chang 所撰写的“Bigtable 简介：HBase是一个分布式的、面向列的开源数据库，该技术来源于 Fay Chang 所撰写的Google论文“Bigtable：一个结构化数据的分布式存储系统”。就像Bigtable利用了Google文件系统（File System）所提供的分布式数据存储一样，HBase在Hadoop之上提供了类似于Bigtable的能力。HBase是Apache的Hadoop项目的子项目。HBase不同于一般的关系数据库，它是一个适合于非结构化数据存储的数据库。另一个不同的是HBase基于列的而不是基于行的模式。 官网：http://hbase.apache.org/ 文件存储一、CouchDB简介：CouchDB是用Erlang开发的面向文档的数据库系统，最近刚刚发布了1.0版本（2010年7月14日）。CouchDB不是一个传统的关系数据库，而是面向文档的数据库，其数据存储方式有点类似lucene的index文件格式，CouchDB最大的意义在于它是一个面向web应用的新一代存储系统，事实上，CouchDB的口号就是：下一代的Web应用存储系统。 特点： 一、CouchDB是分布式的数据库，他可以把存储系统分布到n台物理的节点上面，并且很好的协调和同步节点之间的数据读写一致性。这当然也得靠Erlang无与伦比的并发特性才能做到。对于基于web的大规模应用文档应用，分布式可以让它不必像传统的关系数据库那样分库拆表，在应用代码层进行大量的改动。 二、CouchDB是面向文档的数据库，存储半结构化的数据，比较类似lucene的index结构，特别适合存储文档，因此很适合CMS，电话本，地址本等应用，在这些应用场合，文档数据库要比关系数据库更加方便，性能更好。 三、CouchDB支持REST API，可以让用户使用JavaScript来操作CouchDB数据库，也可以用JavaScript编写查询语句，我们可以想像一下，用AJAX技术结合CouchDB开发出来的CMS系统会是多么的简单和方便。 其实CouchDB只是Erlang应用的冰山一角，在最近几年，基于Erlang的应用也得到的蓬勃的发展，特别是在基于web的大规模，分布式应用领域，几乎都是Erlang的优势项目。 官网：http://couchdb.apache.org/ 二、MongoDB简介：MongoDB 是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。 MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。他支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。 相关文章：MongoDB的基本特性与内部构造 大数据吃香 创业公司MongoDB估值达16亿美元 特点 它的特点是高性能、易部署、易使用，存储数据非常方便。主要功能特性有： *面向集合存储，易存储对象类型的数据。 mongodb集群参考 mongodb集群参考 *模式自由。 *支持动态查询。 *支持完全索引，包含内部对象。 *支持查询。 *支持复制和故障恢复。 *使用高效的二进制数据存储，包括大型对象（如视频等）。 *自动处理碎片，以支持云计算层次的扩展性。 *支持RUBY，PYTHON，JAVA，C++，PHP，C#等多种语言。 *文件存储格式为BSON（一种JSON的扩展）。 *可通过网络访问。 官网：https://www.mongodb.org/ 三、Tachyon贡献者：Haoyuan Li（李浩源） 简介：Tachyon是一个分布式内存文件系统，可以在集群里以访问内存的速度来访问存在tachyon里的文件。把Tachyon是架构在最底层的分布式文件存储和上层的各种计算框架之间的一种中间件。主要职责是将那些不需要落地到DFS里的文件，落地到分布式内存文件系统中，来达到共享内存，从而提高效率。同时可以减少内存冗余，GC时间等。 Tachyon架构 Tachyon的架构是传统的Master—slave架构，这里和Hadoop类似，TachyonMaster里WorkflowManager是 Master进程，因为是为了防止单点问题，通过Zookeeper做了HA，可以部署多台Standby Master。Slave是由Worker Daemon和Ramdisk构成。这里个人理解只有Worker Daemon是基于JVM的，Ramdisk是一个off heap memory。Master和Worker直接的通讯协议是Thrift。 下图来自Tachyon的作者Haoyuan Li： 下载地址：https://github.com/amplab/tachyon 四、KFS简介：GFS的C++开源版本，Kosmos distributed file system (KFS)是一个专门为数据密集型应用（搜索引擎，数据挖掘等）而设计的存储系统，类似于Google的GFS和Hadoop的HDFS分布式文件系统。 KFS使用C++实现，支持的客户端包括C++，Java和Python。KFS系统由三部分组成，分别是metaserver、chunkserver和client library。 官网：http://code.google.com/p/kosmosfs/ 五、HDFS 简介：Hadoop分布式文件系统(HDFS)被设计成适合运行在通用硬件(commodity hardware)上的分布式文件系统。它和现有的分布式文件系统有很多共同点。但同时，它和其他的分布式文件系统的区别也是很明显的。HDFS是一个高度容错性的系统，适合部署在廉价的机器上。HDFS能提供高吞吐量的数据访问，非常适合大规模数据集上的应用。HDFS放宽了一部分POSIX约束，来实现流式读取文件系统数据的目的。HDFS在最开始是作为Apache Nutch搜索引擎项目的基础架构而开发的。HDFS是Apache Hadoop Core项目的一部分。 官网：http://hadoop.apache.org/ 资源管理一、Twitter Mesos开发者：Twitter研发人员John Oskasson 简介：Apache Mesos是由加州大学伯克利分校的AMPLab首先开发的一款开源群集管理软件，支持Hadoop、ElasticSearch、Spark、Storm 和Kafka等架构，由于其开源性质越来越受到一些大型云计算公司的青睐，例如Twitter、Facebook等。 参考文章：Mesos渐入主流,Twitter模式有望 “无限复制”-CSDN.NET 官网：http://mesos.apache.org/ 二、Hadoop YarnHadoop 新 MapReduce 框架 Yarn。为从根本上解决旧 MapReduce 框架的性能瓶颈，促进 Hadoop 框架的更长远发展，从 0.23.0 版本开始，Hadoop 的 MapReduce 框架完全重构，发生了根本的变化。新的 Hadoop MapReduce 框架命名为 MapReduceV2 或者叫 Yarn，其架构图如下图所示： Yarn 框架相对于老的 MapReduce 框架什么优势呢？我们可以看到： 1、这个设计大大减小了 JobTracker（也就是现在的 ResourceManager）的资源消耗，并且让监测每一个 Job 子任务 (tasks) 状态的程序分布式化了，更安全、更优美。 2、在新的 Yarn 中，ApplicationMaster 是一个可变更的部分，用户可以对不同的编程模型写自己的 AppMst，让更多类型的编程模型能够跑在 Hadoop 集群中，可以参考 hadoop Yarn 官方配置模板中的 mapred-site.xml 配置。 3、对于资源的表示以内存为单位 ( 在目前版本的 Yarn 中，没有考虑 cpu 的占用 )，比之前以剩余 slot 数目更合理。 4、老的框架中，JobTracker 一个很大的负担就是监控 job 下的 tasks 的运行状况，现在，这个部分就扔给 ApplicationMaster 做了，而 ResourceManager 中有一个模块叫做 ApplicationsMasters( 注意不是 ApplicationMaster)，它是监测 ApplicationMaster 的行状况，如果出问题，会将其在其他机器上重启。 5、Container 是 Yarn 为了将来作资源隔离而提出的一个框架。这一点应该借鉴了 Mesos 的工作，目前是一个框架，仅仅提供 java 虚拟机内存的隔离 ,hadoop 团队的设计思路应该后续能支持更多的资源调度和控制 , 既然资源表示成内存量，那就没有了之前的 map slot/reduce slot 分开造成集群资源闲置的尴尬情况。 官网：http://hadoop.apache.org/ 日志收集系统一、Facebook Scribe 贡献者：Facebook 简介：Scribe是Facebook开源的日志收集系统，在Facebook内部已经得到大量的应用。它能够从各种日志源上收集日志，存储到一个中央存储系统（可以是NFS，分布式文件系统等）上，以便于进行集中统计分析处理。它为日志的“分布式收集，统一处理”提供了一个可扩展的，高容错的方案。当中央存储系统的网络或者机器出现故障时，scribe会将日志转存到本地或者另一个位置，当中央存储系统恢复后，scribe会将转存的日志重新传输给中央存储系统。其通常与Hadoop结合使用，scribe用于向HDFS中push日志，而Hadoop通过MapReduce作业进行定期处理。 Scribe的系统架构 代码托管：https://github.com/facebook/scribe 二、Cloudera Flume 贡献者：Cloudera 简介：Flume是Cloudera提供的一个高可用的，高可靠的，分布式的海量日志采集、聚合和传输的系统，Flume支持在日志系统中定制各类数据发送方，用于收集数据；同时，Flume提供对数据进行简单处理，并写到各种数据接受方（可定制）的能力。 Flume提供了从console（控制台）、RPC（Thrift-RPC）、text（文件）、tail（UNIX tail）、syslog（syslog日志系统，支持TCP和UDP等2种模式），exec（命令执行）等数据源上收集数据的能力。 当前Flume有两个版本Flume 0.9X版本的统称Flume-og，Flume1.X版本的统称Flume-ng。由于Flume-ng经过重大重构，与Flume-og有很大不同，使用时请注意区分。 Cloudera Flume构架： 官网：http://flume.apache.org/ 三、logstash简介：logstash 是一个应用程序日志、事件的传输、处理、管理和搜索的平台。你可以用它来统一对应用程序日志进行收集管理，提供 Web 接口用于查询和统计。他可以对你的日志进行收集、分析，并将其存储供以后使用（如，搜索），您可以使用它。说到搜索，logstash带有一个web界面，搜索和展示所有日志。 官网：http://www.logstash.net/ 四、kibana简介：Kibana 是一个为 Logstash 和 ElasticSearch 提供的日志分析的 Web 接口。可使用它对日志进行高效的搜索、可视化、分析等各种操作。kibana 也是一个开源和免费的工具，他可以帮助您汇总、分析和搜索重要数据日志并提供友好的web界面。他可以为 Logstash 和 ElasticSearch 提供的日志分析的 Web 界面。 主页： http://kibana.org/ 代码托管： https://github.com/rashidkpc/Kibana/downloads 消息系统一、StormMQ简介：MQMessageQueue消息队列产品 StormMQ，是一种服务程序。 官网：http://stormmq.com/ 二、ZeroMQ简介：这是个类似于Socket的一系列接口，他跟Socket的区别是：普通的socket是端到端的（1:1的关系），而ZMQ却是可以N：M 的关系，人们对BSD套接字的了解较多的是点对点的连接，点对点连接需要显式地建立连接、销毁连接、选择协议（TCP/UDP）和处理错误等，而ZMQ屏蔽了这些细节，让你的网络编程更为简单。ZMQ用于node与node间的通信，node可以是主机或者是进程。 引用官方的说法： “ZMQ(以下ZeroMQ简称ZMQ)是一个简单好用的传输层，像框架一样的一个socket library，他使得Socket编程更加简单、简洁和性能更高。是一个消息处理队列库，可在多个线程、内核和主机盒之间弹性伸缩。ZMQ的明确目标是“成为标准网络协议栈的一部分，之后进入Linux内核”。现在还未看到它们的成功。但是，它无疑是极具前景的、并且是人们更加需要的“传统”BSD套接字之上的一 层封装。ZMQ让编写高性能网络应用程序极为简单和有趣。” 官网：http://zeromq.org/ 三、RabbitMQ简介：RabbitMQ是一个受欢迎的消息代理，通常用于应用程序之间或者程序的不同组件之间通过消息来进行集成。本文简单介绍了如何使用 RabbitMQ，假定你已经配置好了rabbitmq服务器。 RabbitMQ是用Erlang，对于主要的编程语言都有驱动或者客户端。我们这里要用的是Java，所以先要获得Java客户端。 像RabbitMQ这样的消息代理可用来模拟不同的场景，例如点对点的消息分发或者订阅/推送。我们的程序足够简单，有两个基本的组件，一个生产者用于产生消息，还有一个消费者用来使用产生的消息。 官网：https://www.rabbitmq.com/ 四、Apache ActiveMQ简介：ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现，尽管JMS规范出台已经是很久的事情了，但是JMS在当今的J2EE应用中间仍然扮演着特殊的地位。 特性： ⒈ 多种语言和协议编写客户端。语言: Java,C,C++,C#,Ruby,Perl,Python,PHP。应用协议： OpenWire,Stomp REST,WS Notification,XMPP,AMQP ⒉ 完全支持JMS1.1和J2EE 1.4规范 （持久化，XA消息，事务) ⒊ 对Spring的支持，ActiveMQ可以很容易内嵌到使用Spring的系统里面去，而且也支持Spring2.0的特性 ⒋ 通过了常见J2EE服务器（如 Geronimo,JBoss 4,GlassFish,WebLogic)的测试，其中通过JCA 1.5 resource adaptors的配置，可以让ActiveMQ可以自动的部署到任何兼容J2EE 1.4 商业服务器上 ⒌ 支持多种传送协议：in-VM,TCP,SSL,NIO,UDP,JGroups,JXTA ⒍ 支持通过JDBC和journal提供高速的消息持久化 ⒎ 从设计上保证了高性能的集群，客户端-服务器，点对点 ⒏ 支持Ajax ⒐ 支持与Axis的整合 ⒑ 可以很容易得调用内嵌JMS provider，进行测试 官网：http://activemq.apache.org/ 五、Jafka贡献者：LinkedIn 简介：Jafka 是一个开源的、高性能的、跨语言分布式消息系统，使用GitHub托管。Jafka 最早是由Apache孵化的Kafka（由LinkedIn捐助给Apache）克隆而来。由于是一个开放式的数据传输协议，因此除了Java开发语言受到支持，Python、Ruby、C、C++等其他语言也能够很好的得到支持。 特性： 1、消息持久化非常快，服务端存储消息的开销为O(1)，并且基于文件系统，能够持久化TB级的消息而不损失性能。 2、吞吐量取决于网络带宽。 3、完全的分布式系统，broker、producer、consumer都原生自动支持分布式。自动实现复杂均衡。 4、内核非常小，整个系统（包括服务端和客户端）只有一个272KB的jar包，内部机制也不复杂，适合进行内嵌或者二次开发 。整个服务端加上依赖组件共3.5MB。 5、消息格式以及通信机制非常简单，适合进行跨语言开发。目前自带的Python3.x的客户端支持发送消息和接收消息。 官网：http://kafka.apache.org/ 六、Apache Kafka贡献者：LinkedIn 简介：Apache Kafka是由Apache软件基金会开发的一个开源消息系统项目，由Scala写成。Kafka最初是由LinkedIn开发，并于2011年初开源。2012年10月从Apache Incubator毕业。该项目的目标是为处理实时数据提供一个统一、高通量、低等待的平台。 Kafka是一个分布式的、分区的、多复本的日志提交服务。它通过一种独一无二的设计提供了一个消息系统的功能。 Kafka集群可以在一个指定的时间内保持所有发布上来的消息，不管这些消息有没有被消费。打个比方，如果这个时间设置为两天，那么在消息发布的两天以内，这条消息都是可以被消费的，但是在两天后，这条消息就会被系统丢弃以释放空间。Kafka的性能不会受数据量的大小影响，因此保持大量的数据不是一个问题。 官网：http://kafka.apache.org/ 分布式服务一、ZooKeeper贡献者：Google 简介：ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、名字服务、分布式同步、组服务等。 ZooKeeper是以Fast Paxos算法为基础的，paxos算法存在活锁的问题，即当有多个proposer交错提交时，有可能互相排斥导致没有一个proposer能提交成功，而Fast Paxos作了一些优化，通过选举产生一个leader，只有leader才能提交propose，具体算法可见Fast Paxos。因此，要想弄懂ZooKeeper首先得对Fast Paxos有所了解。 架构： 官网：http://zookeeper.apache.org/ RPC（Remote Procedure Call Protocol）——远程过程调用协议 一、Apache Avro简介：Apache Avro是Hadoop下的一个子项目。它本身既是一个序列化框架，同时也实现了RPC的功能。Avro官网描述Avro的特性和功能如下： 丰富的数据结构类型；快速可压缩的二进制数据形式；存储持久数据的文件容器；提供远程过程调用RPC；简单的动态语言结合功能。相比于Apache Thrift 和Google的Protocol Buffers，Apache Avro具有以下特点： 支持动态模式。Avro不需要生成代码，这有利于搭建通用的数据处理系统，同时避免了代码入侵。数据无须加标签。读取数据前，Avro能够获取模式定义，这使得Avro在数据编码时只需要保留更少的类型信息，有利于减少序列化后的数据大小。官网：http://avro.apache.org/ 二、Facebook Thrift贡献者：Facebook 简介：Thrift源于大名鼎鼎的facebook之手，在2007年facebook提交Apache基金会将Thrift作为一个开源项目，对于当时的facebook来说创造thrift是为了解决facebook系统中各系统间大数据量的传输通信以及系统之间语言环境不同需要跨平台的特性。 thrift可以支持多种程序语言，例如: C++, C#, Cocoa, Erlang, Haskell, Java, Ocami, Perl, PHP, Python, Ruby, Smalltalk. 在多种不同的语言之间通信thrift可以作为二进制的高性能的通讯中间件，支持数据(对象)序列化和多种类型的RPC服务。 Thrift适用于程序对程 序静态的数据交换，需要先确定好他的数据结构，他是完全静态化的，当数据结构发生变化时，必须重新编辑IDL文件，代码生成，再编译载入的流程，跟其他IDL工具相比较可以视为是Thrift的弱项，Thrift适用于搭建大型数据交换及存储的通用工具，对于大型系统中的内部数据传输相对于JSON和xml无论在性能、传输大小上有明显的优势。 Thrift 主要由5个部分组成： · 类型系统以及 IDL 编译器：负责由用户给定的 IDL 文件生成相应语言的接口代码 · TProtocol：实现 RPC 的协议层，可以选择多种不同的对象串行化方式，如 JSON, Binary。 · TTransport：实现 RPC 的传输层，同样可以选择不同的传输层实现，如socket, 非阻塞的 socket, MemoryBuffer 等。 · TProcessor：作为协议层和用户提供的服务实现之间的纽带，负责调用服务实现的接口。 · TServer：聚合 TProtocol, TTransport 和 TProcessor 几个对象。 上述的这5个部件都是在 Thrift 的源代码中通过为不同语言提供库来实现的，这些库的代码在 Thrift 源码目录的 lib 目录下面，在使用 Thrift 之前需要先熟悉与自己的语言对应的库提供的接口。 Facebook Thrift构架： 官网：http://thrift.apache.org/ 集群管理一、Nagios简介：Nagios是一款开源的免费网络监视工具，能有效监控Windows、Linux和Unix的主机状态，交换机路由器等网络设置，打印机等。在系统或服务状态异常时发出邮件或短信报警第一时间通知网站运维人员，在状态恢复后发出正常的邮件或短信通知。 Nagios可运行在Linux/Unix平台之上，同时提供一个可选的基于浏览器的WEB界面以方便系统管理人员查看网络状态，各种系统问题，以及日志等等。 官网：http://www.nagios.org/ 二、Ganglia简介：Ganglia是UC Berkeley发起的一个开源集群监视项目，设计用于测量数以千计的节点。Ganglia的核心包含gmond、gmetad以及一个Web前端。主要是用来监控系统性能，如：cpu 、mem、硬盘利用率， I/O负载、网络流量情况等，通过曲线很容易见到每个节点的工作状态，对合理调整、分配系统资源，提高系统整体性能起到重要作用。 官网：http://ganglia.sourceforge.net/ 三、Apache Ambari简介：Apache Ambari是一种基于Web的工具，支持Apache Hadoop集群的供应、管理和监控。Ambari目前已支持大多数Hadoop组件，包括HDFS、MapReduce、Hive、Pig、 Hbase、Zookeper、Sqoop和Hcatalog等。 Apache Ambari 支持HDFS、MapReduce、Hive、Pig、Hbase、Zookeper、Sqoop和Hcatalog等的集中管理。也是5个顶级hadoop管理工具之一。 Ambari主要取得了以下成绩： 通过一步一步的安装向导简化了集群供应。预先配置好关键的运维指标（metrics），可以直接查看Hadoop Core（HDFS和MapReduce）及相关项目（如HBase、Hive和HCatalog）是否健康。支持作业与任务执行的可视化与分析，能够更好地查看依赖和性能。通过一个完整的RESTful API把监控信息暴露出来，集成了现有的运维工具。用户界面非常直观，用户可以轻松有效地查看信息并控制集群。Ambari使用Ganglia收集度量指标，用Nagios支持系统报警，当需要引起管理员的关注时（比如，节点停机或磁盘剩余空间不足等问题），系统将向其发送邮件。 此外，Ambari能够安装安全的（基于Kerberos）Hadoop集群，以此实现了对Hadoop 安全的支持，提供了基于角色的用户认证、授权和审计功能，并为用户管理集成了LDAP和Active Directory。 官网：http://ambari.apache.org/ 基础设施一、LevelDB贡献者：Jeff Dean和Sanjay Ghemawat 简介：Leveldb是一个google实现的非常高效的kv数据库，目前的版本1.2能够支持billion级别的数据量了。 在这个数量级别下还有着非常高的性能，主要归功于它的良好的设计。特别是LMS算法。LevelDB 是单进程的服务，性能非常之高，在一台4核Q6600的CPU机器上，每秒钟写数据超过40w，而随机读的性能每秒钟超过10w。 Leveldb框架： 官网：http://code.google.com/p/leveldb/ 二、SSTable简介：如果说Protocol Buffer是谷歌独立数据记录的通用语言 ，那么有序字符串表（SSTable，Sorted String Table）则是用于存储，处理和数据集交换的最流行​​的数据输出格式。正如它的名字本身，SSTable是有效存储大量键-值对的简单抽象，对高吞吐量顺序读/写进行了优化。 SSTable是Bigtable中至关重要的一块，对于LevelDB来说也是如此。 三、RecordIO贡献者：Google 简介：我们大家都在用文件来存储数据。文件是存储在磁盘上的。如果在一些不稳定的介质上，文件很容损坏。即时文件某个位置出现一点小小的问题，整个文件就废了。 下面我来介绍Google的一个做法，可以比较好的解决这个问题。那就是recordio文件格式。recoidio的存储单元是一个一个record。这个record可以根据业务的需要自行定义。但Google有一种建议的处理方式就是使用protobuf。 reocordio底层的格式其实很简单。一个record由四部分组成： MagicNumber (32 bits)Uncompressed data payload size (64 bits)Compressed data payload size (64 bits), or 0 if the data is not compressedPayload, possibly compressed.详细格式如下图所示： 到这里，大家可能已经知道，recordio之所以能对付坏数据，其实就是在这个MagicNumber（校验值）。 四、Flat Buffers贡献者：Google 简介：谷歌开源高效、跨平台的序列化库FlatBuffers。 该库的构建是专门为游戏开发人员的性能需求提供支持，它将序列化数据存储在缓存中，这些数据既可以存储在文件中，又可以通过网络原样传输，而不需要任何解析开销。 FlatBuffers有如下一些关键特性—— 访问序列化数据不需要打包/拆包节省内存而且访问速度快——缓存只占用访问数据所需要的内存；不需要任何额外的内存。灵活性——通过可选字段向前向后兼容代码规模小强类型——错误在编译时捕获，而不是在运行时便利性——生成的C++头文件代码简洁。如果需要，有一项可选功能可以用来在运行时高效解析Schema和JSON-like格式的文本。跨平台——使用C++编写，不依赖STL之外的库，因此可以用于任何有C++编辑器的平台。当前，该项目包含构建方法和在Android、Linux、Windows和OSX等操作系统上使用该库的示例。与Protocol Buffers或JSON Parsing这样的可选方案相比，FlatBuffers的优势在于开销更小，这主要是由于它没有解析过程。 代码托管：https://github.com/google/flatbuffers 五、Protocol Buffers贡献者：Google 简介：Protocol Buffers是Google公司开发的一种数据描述语言，类似于XML能够将结构化数据序列化，可用于数据存储、通信协议等方面。它不依赖于语言和平台并且可扩展性极强。现阶段官方支持C++、JAVA、Python等三种编程语言，但可以找到大量的几乎涵盖所有语言的第三方拓展包。 通过它，你可以定义你的数据的结构，并生成基于各种语言的代码。这些你定义的数据流可以轻松地在传递并不破坏你已有的程序。并且你也可以更新这些数据而现有的程序也不会受到任何的影响。 Protocol Buffers经常被简称为protobuf。 官网：http://code.google.com/p/protobuf/ 六、Consistent Hashing（哈希算法）简介：一致性哈希算法在1997年由麻省理工学院提出的一种分布式哈希（DHT）实现算法，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷和CARP十分类似。一致性哈希修正了CARP使用的简 单哈希算法带来的问题，使得分布式哈希（DHT）可以在P2P环境中真正得到应用。 一致性hash算法提出了在动态变化的Cache环境中，判定哈希算法好坏的四个定义： 1、平衡性(Balance)：平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。 2、单调性(Monotonicity)：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。 3、分散性(Spread)：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。 4、负载(Load)：负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。 在分布式集群中，对机器的添加删除，或者机器故障后自动脱离集群这些操作是分布式集群管理最基本的功能。如果采用常用的hash(object)%N算法，那么在有机器添加或者删除后，很多原有的数据就无法找到了，这样严重的违反了单调性原则。 七、Netty贡献者：JBOSS 简介：Netty是由JBOSS提供的一个java开源框架。Netty提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。 也就是说，Netty 是一个基于NIO的客户，服务器端编程框架，使用Netty 可以确保你快速和简单的开发出一个网络应用，例如实现了某种协议的客户，服务端应用。Netty相当简化和流线化了网络应用的编程开发过程，例如，TCP和UDP的socket服务开发。 “快速”和“简单”并不意味着会让你的最终应用产生维护性或性能上的问题。Netty 是一个吸收了多种协议的实现经验，这些协议包括FTP,SMTP,HTTP，各种二进制，文本协议，并经过相当精心设计的项目，最终，Netty 成功的找到了一种方式，在保证易于开发的同时还保证了其应用的性能，稳定性和伸缩性。 官网：http://netty.io/ 八、BloomFilter简介：Bloom filter 是由 Howard Bloom 在 1970 年提出的二进制向量数据结构，它具有很好的空间和时间效率，被用来检测一个元素是不是集合中的一个成员。如果检测结果为是，该元素不一定在集合中；但如果检测结果为否，该元素一定不在集合中。因此Bloom filter具有100%的召回率。这样每个检测请求返回有“在集合内（可能错误）”和“不在集合内（绝对不在集合内）”两种情况，可见 Bloom filter 是牺牲了正确率和时间以节省空间。 Bloom filter 优点就是它的插入和查询时间都是常数，另外它查询元素却不保存元素本身，具有良好的安全性。 搜索引擎一、Nutch简介：Nutch 是一个开源Java 实现的搜索引擎。它提供了我们运行自己的搜索引擎所需的全部工具。包括全文搜索和Web爬虫。 尽管Web搜索是漫游Internet的基本要求, 但是现有web搜索引擎的数目却在下降. 并且这很有可能进一步演变成为一个公司垄断了几乎所有的web搜索为其谋取商业利益.这显然 不利于广大Internet用户. Nutch为我们提供了这样一个不同的选择. 相对于那些商用的搜索引擎, Nutch作为开放源代码 搜索引擎将会更加透明, 从而更值得大家信赖. 现在所有主要的搜索引擎都采用私有的排序算法, 而不会解释为什么一个网页会排在一个特定的位置. 除此之外, 有的搜索引擎依照网站所付的 费用, 而不是根据它们本身的价值进行排序. 与它们不同, Nucth没有什么需要隐瞒, 也没有 动机去扭曲搜索的结果. Nutch将尽自己最大的努力为用户提供最好的搜索结果. Nutch目前最新的版本为version v2.2.1。 官网：https://nutch.apache.org/ 二、Lucene开发者：Doug Cutting（Hadoop之父，你懂的） 简介：Lucene是apache软件基金会4 jakarta项目组的一个子项目，是一个开放源代码的全文检索引擎工具包，即它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎（英文与德文两种西方语言）。Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者是以此为基础建立起完整的全文检索引擎。 官网：http://lucene.apache.org/ 三、SolrCloud简介：SolrCloud是Solr4.0版本以后基于Solr和Zookeeper的分布式搜索方案。SolrCloud是Solr的基于Zookeeper一种部署方式。Solr可以以多种方式部署，例如单机方式，多机Master-Slaver方式。 原理图： SolrCloud有几个特色功能： 集中式的配置信息使用ZK进行集中配置。启动时可以指定把Solr的相关配置文件上传 Zookeeper，多机器共用。这些ZK中的配置不会再拿到本地缓存，Solr直接读取ZK中的配置信息。配置文件的变动，所有机器都可以感知到。另外，Solr的一些任务也是通过ZK作为媒介发布的。目的是为了容错。接收到任务，但在执行任务时崩溃的机器，在重启后，或者集群选出候选者时，可以再次执行这个未完成的任务。 自动容错SolrCloud对索引分片，并对每个分片创建多个Replication。每个Replication都可以对外提供服务。一个Replication挂掉不会影响索引服务。更强大的是，它还能自动的在其它机器上帮你把失败机器上的索引Replication重建并投入使用。 近实时搜索立即推送式的replication（也支持慢推送）。可以在秒内检索到新加入索引。 查询时自动负载均衡SolrCloud索引的多个Replication可以分布在多台机器上，均衡查询压力。如果查询压力大，可以通过扩展机器，增加Replication来减缓。 自动分发的索引和索引分片发送文档到任何节点，它都会转发到正确节点。 事务日志事务日志确保更新无丢失，即使文档没有索引到磁盘。 四、Solr简介：Solr是一个独立的企业级搜索应用服务器，它对外提供类似于Web-service的API接口。用户可以通过http请求，向搜索引擎服务器提交一定格式的XML文件，生成索引；也可以通过Http Get操作提出查找请求，并得到XML格式的返回结果。 Solr是一个高性能，采用Java5开发，基于Lucene的全文搜索服务器。同时对其进行了扩展，提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展并对查询性能进行了优化，并且提供了一个完善的功能管理界面，是一款非常优秀的全文搜索引擎。 官网：https://lucene.apache.org/solr/ 五、ElasticSearch简介：ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是第二最流行的企业搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。 官网：http://www.elasticsearch.org/ 六、Sphinx简介：Sphinx是一个基于SQL的全文检索引擎，可以结合MySQL,PostgreSQL做全文搜索，它可以提供比数据库本身更专业的搜索功能，使得应用程序更容易实现专业化的全文检索。Sphinx特别为一些脚本语言设计搜索API接口，如PHP,Python,Perl,Ruby等，同时为MySQL也设计了一个存储引擎插件。 Sphinx单一索引最大可包含1亿条记录，在1千万条记录情况下的查询速度为0.x秒（毫秒级）。Sphinx创建索引的速度为：创建100万条记录的索引只需 3～4分钟，创建1000万条记录的索引可以在50分钟内完成，而只包含最新10万条记录的增量索引，重建一次只需几十秒。 官网：http://sphinxsearch.com 七、SenseiDB贡献者：linkedin 简介：SenseiDB是一个NoSQL数据库，它专注于高更新率以及复杂半结构化搜索查询。熟悉Lucene和Solor的用户会发现，SenseiDB背后有许多似曾相识的概念。SenseiDB部署在多节点集群中，其中每个节点可以包括N块数据片。Apache Zookeeper用于管理节点，它能够保持现有配置，并可以将任意改动（如拓扑修改）传输到整个节点群中。SenseiDB集群还需要一种模式用于定义将要使用的数据模型。 从SenseiDB集群中获取数据的唯一方法是通过Gateways（它 没有“INSERT”方法）。每个集群都连接到一个单一gateway。你需要了解很重要的一点是，由于SenseiDB本身没法处理原子性 （Atomicity）和隔离性（Isolation），因此只能通过外部在gateway层进行限制。另外，gateway必须确保数据流按照预期的方 式运作。内置的gateway有以下几种形式： 来自文件来自JMS队列通过JDBC来自Apache Kafka官网：http://senseidb.com 数据挖掘一、Mahout 简介：Apache Mahout 是 Apache Software Foundation (ASF) 开发的一个全新的开源项目，其主要目标是创建一些可伸缩的机器学习算法，供开发人员在 Apache 在许可下免费使用。该项目已经发展到了它的最二个年头，目前只有一个公共发行版。Mahout 包含许多实现，包括集群、分类、CP 和进化程序。此外，通过使用 Apache Hadoop 库，Mahout 可以有效地扩展到云中。 虽然在开源领域中相对较为年轻，但 Mahout 已经提供了大量功能，特别是在集群和 CF 方面。Mahout 的主要特性包括： Taste CF。Taste 是 Sean Owen 在 SourceForge 上发起的一个针对 CF 的开源项目，并在 2008 年被赠予 Mahout。一些支持 Map-Reduce 的集群实现包括 k-Means、模糊 k-Means、Canopy、Dirichlet 和 Mean-Shift。Distributed Naive Bayes 和 Complementary Naive Bayes 分类实现。针对进化编程的分布式适用性功能。Matrix 和矢量库。上述算法的示例。官网：http://mahout.apache.org/ IaasIaaS（Infrastructure as a Service），即基础设施即服务。 一、OpenStack简介：OpenStack是一个由NASA（美国国家航空航天局）和Rackspace合作研发并发起的，以Apache许可证授权的自由软件和开放源代码项目。 OpenStack是一个开源的云计算管理平台项目，由几个主要的组件组合起来完成具体工作。OpenStack支持几乎所有类型的云环境，项目目标是提供实施简单、可大规模扩展、丰富、标准统一的云计算管理平台。OpenStack通过各种互补的服务提供了基础设施即服务（IaaS）的解决方案，每个服务提供API以进行集成。 6个核心项目：Nova（计算，Compute），Swift（对象存储，Object），Glance（镜像，Image），Keystone（身份，Identity），Horizon（自助门户，Dashboard），Quantum &amp; Melange（网络&amp;地址管理），另外还有若干社区项目，如Rackspace（负载均衡）、Rackspace（关系型数据库）。 相关阅读： 什么是OpenStack？ 成功部署OpenStack的十大要点 官网：https://www.openstack.org/ 二、Docker贡献者：dotCloud 简介：Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）。几乎没有性能开销,可以很容易地在机器和数据中心中运行。最重要的是,他们不依赖于任何语言、框架或包括系统。 官网：http://www.docker.io/ 三、Kubernetes贡献者：Google 简介：Kubernetes是Google开源的容器集群管理系统。它构建Ddocker技术之上，为容器化的应用提供资源调度、部署运行、服务发现、扩容缩容等整一套功能，本质上可看作是基于容器技术的mini-PaaS平台。 Kubernetes从另一个角度对资源进行抽象，它让开发人员和管理人员共同着眼于服务的行为和性能的提升，而不是仅仅关注对单一的组件或者是基础资源。 那么Kubernetes集群到底提供了哪些单一容器所没有功能?它主要关注的是对服务级别的控制而并非仅仅是对容器级别的控制，Kubernetes提供了一种“机智”的管理方式，它将服务看成一个整体。在Kubernete的解决方案中，一个服务甚至可以自我扩展，自我诊断，并且容易升级。例如，在Google中，我们使用机器学习技术来保证每个运行的服务的当前状态都是最高效的。 代码托管：https://github.com/GoogleCloudPlatform/kubernetes/ 四、Imctfy贡献者：Google 简介：Google开源了自己所用Linux容器系统的开源版本lmctfy，读音为lem-kut-fee。包括一个C++库（使用了C++11，文档可以参考头文件）和命令行界面。目前的版本是0.1，只提供了CPU与内存隔离。项目还在密集开发中。 mctfy本身是针对某些特定使用场景设计和实现的，目前拥有一台机器上所有容器时运行情况最好，不推荐与LXC和其他容器系统一起使用（虽然也可行）。已在Ubuntu 12.04+和Ubuntu 3.3与3.8内核上测试。 代码托管：https://github.com/google/Imctfy/ 监控管理一、Dapper贡献者：Google 简介：Dapper是一个轻量的ORM(对象关系映射（英语：Object Relational Mapping，简称ORM，或O/RM，或O/R mapping）。并不单纯的是一个DBHelper.因为在Dapper中数据其实就是一个对象。Dapper扩展与IDbConnection上，所以事实上它的倾入性很低。我用了StructureMap。如果不喜欢可以自己更换，或者自己实现下。 代码就一个SqlMapper.cs文件,主要是IDbConnection的扩展方法，编译后就40K的一个很小的dll。 特性： Dapper很快。Dapper的速度接近与IDataReader。Dapper支持主流数据库 Mysql,SqlLite,Mssql2000,Mssql2005,Oracle等一系列的数据库支持多表并联的对象。支持一对多 多对多的关系，并且没侵入性。原理通过Emit反射IDataReader的序列队列，来快速的得到和产生对象Dapper语法十分简单。并且无须迁就数据库的设计官方站点 http://code.google.com/p/dapper-dot-net/ 代码托管：http://bigbully.github.io/Dapper-translation/ 二、Zipkin贡献者：Twitter 简介：Zipkin （分布式跟踪系统）是 Twitter 的一个开源项目，允许开发者收集 Twitter 各个服务上的监控数据，并提供查询接口。该系统让开发者可通过一个 Web 前端轻松的收集和分析数据，例如用户每次请求服务的处理时间等，可方便的监测系统中存在的瓶颈。 官方网站：http://twitter.github.io/zipkin/ 代码托管：https://github.com/twitter/zipkin/ ————————————-End.——————————————- 感谢:36大数据(http://www.36dsj.com/) 转载来源:http://www.36dsj.com/archives/24852http://www.36dsj.com/archives/25042]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
</search>
